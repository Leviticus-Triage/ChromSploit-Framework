#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ChromSploit Framework - Exploit Chain Menu
Advanced exploit chain management with AI recommendations
"""

import os
import sys
from typing import List, Dict, Optional
from datetime import datetime

# Add parent directory to path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from core.menu import Menu
from core.utils import Colors, print_banner, clear_screen
from core.enhanced_logger import get_logger
from core.exploit_chain import get_chain_manager, ExploitChain, ChainStatus
from core.module_loader import get_module_loader


class ExploitChainMenu(Menu):
    """Menu for exploit chain management"""
    
    def __init__(self):
        super().__init__()
        self.logger = get_logger()
        self.chain_manager = get_chain_manager()
        self.module_loader = get_module_loader()
        
        # Try to load AI orchestrator
        self.ai_orchestrator = self.module_loader.load_module('ai_orchestrator')
        
        # Add menu items
        self.add_item("1", "View Exploit Chains", self.view_chains)
        self.add_item("2", "Create New Chain", self.create_chain)
        self.add_item("3", "Create from Template", self.create_from_template)
        self.add_item("4", "Execute Chain", self.execute_chain)
        self.add_item("5", "AI-Powered Chain Builder", self.ai_chain_builder)
        self.add_item("6", "Chain Status Monitor", self.monitor_chains)
        self.add_item("7", "Import/Export Chains", self.import_export_menu)
        self.add_item("0", "Back", self.exit)
    
    def display(self):
        """Display exploit chain menu"""
        clear_screen()
        print_banner()
        print(f"\n{Colors.HEADER}=== Exploit Chain Management ==={Colors.ENDC}\n")
        
        # Show AI status
        if self.ai_orchestrator:
            print(f"{Colors.OKGREEN}[âœ“] AI Orchestrator: Available{Colors.ENDC}")
        else:
            print(f"{Colors.WARNING}[!] AI Orchestrator: Using fallback{Colors.ENDC}")
        
        # Show chain summary
        chains = self.chain_manager.list_chains()
        active_chains = len([c for c in chains if c['status'] == 'running'])
        print(f"{Colors.OKBLUE}Chains: {len(chains)} total, {active_chains} active{Colors.ENDC}\n")
        
        super().display()
    
    def view_chains(self):
        """View all exploit chains"""
        clear_screen()
        print(f"\n{Colors.HEADER}=== Exploit Chains ==={Colors.ENDC}\n")
        
        chains = self.chain_manager.list_chains()
        
        if not chains:
            print(f"{Colors.WARNING}[!] No exploit chains found{Colors.ENDC}")
        else:
            for i, chain in enumerate(chains, 1):
                status_color = self._get_status_color(chain['status'])
                print(f"{Colors.OKBLUE}[{i}]{Colors.ENDC} {chain['name']}")
                print(f"    Status: {status_color}{chain['status'].upper()}{Colors.ENDC}")
                print(f"    Progress: {chain['progress']}")
                if chain['start_time']:
                    print(f"    Started: {chain['start_time']}")
                    print(f"    Runtime: {chain['execution_time']:.1f}s")
                print()
        
        input(f"\n{Colors.WARNING}Press Enter to continue...{Colors.ENDC}")
    
    def create_chain(self):
        """Create new exploit chain"""
        clear_screen()
        print(f"\n{Colors.HEADER}=== Create New Exploit Chain ==={Colors.ENDC}\n")
        
        name = input(f"{Colors.WARNING}Chain Name: {Colors.ENDC}")
        description = input(f"{Colors.WARNING}Description: {Colors.ENDC}")
        
        if not name:
            print(f"{Colors.FAIL}[!] Chain name is required{Colors.ENDC}")
            input(f"{Colors.WARNING}Press Enter to continue...{Colors.ENDC}")
            return
        
        chain = self.chain_manager.create_chain(name, description)
        
        print(f"\n{Colors.OKGREEN}[+] Chain created: {chain.id}{Colors.ENDC}")
        
        # Add steps interactively
        while True:
            print(f"\n{Colors.HEADER}Add Exploit Step:{Colors.ENDC}")
            print("Available CVEs:")
            print("1. CVE-2025-4664 (Chrome Data Leak)")
            print("2. CVE-2025-2783 (Chrome Mojo Sandbox Escape)")
            print("3. CVE-2025-2857 (Firefox Sandbox Escape)")
            print("4. CVE-2025-30397 (Edge WebAssembly JIT)")
            print("0. Finish adding steps")
            
            choice = input(f"\n{Colors.WARNING}Select CVE (0-4): {Colors.ENDC}")
            
            if choice == "0":
                break
            
            cve_map = {
                "1": "CVE-2025-4664",
                "2": "CVE-2025-2783",
                "3": "CVE-2025-2857",
                "4": "CVE-2025-30397"
            }
            
            cve_id = cve_map.get(choice)
            if not cve_id:
                print(f"{Colors.FAIL}[!] Invalid selection{Colors.ENDC}")
                continue
            
            step_desc = input(f"{Colors.WARNING}Step description: {Colors.ENDC}")
            target_url = input(f"{Colors.WARNING}Target URL (optional): {Colors.ENDC}")
            
            parameters = {}
            if target_url:
                parameters['target_url'] = target_url
            
            # Add timeout and failure action
            timeout = input(f"{Colors.WARNING}Timeout (seconds, default 300): {Colors.ENDC}")
            failure_action = input(f"{Colors.WARNING}On failure (stop/continue, default stop): {Colors.ENDC}")
            
            try:
                timeout_val = int(timeout) if timeout else 300
                failure_val = failure_action if failure_action in ['stop', 'continue'] else 'stop'
                
                step_id = chain.add_step(
                    cve_id=cve_id,
                    description=step_desc or f"Execute {cve_id}",
                    parameters=parameters,
                    timeout=timeout_val,
                    failure_action=failure_val
                )
                
                print(f"{Colors.OKGREEN}[+] Step added: {step_id}{Colors.ENDC}")
                
            except ValueError:
                print(f"{Colors.FAIL}[!] Invalid timeout value{Colors.ENDC}")
        
        print(f"\n{Colors.OKGREEN}[+] Chain '{name}' created with {len(chain.steps)} steps{Colors.ENDC}")
        input(f"{Colors.WARNING}Press Enter to continue...{Colors.ENDC}")
    
    def create_from_template(self):
        """Create chain from template"""
        clear_screen()
        print(f"\n{Colors.HEADER}=== Create Chain from Template ==={Colors.ENDC}\n")
        
        print("Available Templates:")
        print("1. Chrome Full Compromise")
        print("2. Multi-Browser Attack")
        print("3. Custom Template")
        
        choice = input(f"\n{Colors.WARNING}Select template: {Colors.ENDC}")
        
        template_map = {
            "1": "chrome_full_compromise",
            "2": "multi_browser_attack"
        }
        
        template_name = template_map.get(choice)
        
        if choice == "3":
            self._create_custom_template()
            return
        elif not template_name:
            print(f"{Colors.FAIL}[!] Invalid selection{Colors.ENDC}")
            input(f"{Colors.WARNING}Press Enter to continue...{Colors.ENDC}")
            return
        
        # Get custom parameters
        print(f"\n{Colors.HEADER}Template Parameters:{Colors.ENDC}")
        target_url = input(f"{Colors.WARNING}Target URL: {Colors.ENDC}")
        
        custom_params = {}
        if target_url:
            custom_params['target_url'] = target_url
        
        chain = self.chain_manager.create_from_template(template_name, custom_params)
        
        if chain:
            print(f"\n{Colors.OKGREEN}[+] Chain created from template: {chain.name}{Colors.ENDC}")
            print(f"    Chain ID: {chain.id}")
            print(f"    Steps: {len(chain.steps)}")
        else:
            print(f"{Colors.FAIL}[!] Failed to create chain from template{Colors.ENDC}")
        
        input(f"\n{Colors.WARNING}Press Enter to continue...{Colors.ENDC}")
    
    def execute_chain(self):
        """Execute an exploit chain"""
        clear_screen()
        print(f"\n{Colors.HEADER}=== Execute Exploit Chain ==={Colors.ENDC}\n")
        
        chains = self.chain_manager.list_chains()
        
        if not chains:
            print(f"{Colors.WARNING}[!] No chains available{Colors.ENDC}")
            input(f"{Colors.WARNING}Press Enter to continue...{Colors.ENDC}")
            return
        
        # List chains
        for i, chain in enumerate(chains, 1):
            status_color = self._get_status_color(chain['status'])
            print(f"{Colors.OKBLUE}[{i}]{Colors.ENDC} {chain['name']} - {status_color}{chain['status']}{Colors.ENDC}")
        
        try:
            choice = int(input(f"\n{Colors.WARNING}Select chain to execute: {Colors.ENDC}"))
            if 1 <= choice <= len(chains):
                selected_chain = chains[choice - 1]
                chain_id = selected_chain['id']
                
                if selected_chain['status'] == 'running':
                    print(f"{Colors.WARNING}[!] Chain is already running{Colors.ENDC}")
                    input(f"{Colors.WARNING}Press Enter to continue...{Colors.ENDC}")
                    return
                
                print(f"\n{Colors.OKBLUE}[*] Starting execution of '{selected_chain['name']}'...{Colors.ENDC}")
                
                # Execute chain asynchronously
                result = self.chain_manager.execute_chain(chain_id, async_execution=True)
                
                if result:
                    print(f"{Colors.OKGREEN}[+] Chain execution started{Colors.ENDC}")
                    print(f"    Chain ID: {chain_id}")
                    print(f"    Status: {result.status.value}")
                    print(f"    Monitor progress in 'Chain Status Monitor'")
                else:
                    print(f"{Colors.FAIL}[!] Failed to start chain execution{Colors.ENDC}")
            else:
                print(f"{Colors.FAIL}[!] Invalid selection{Colors.ENDC}")
                
        except ValueError:
            print(f"{Colors.FAIL}[!] Invalid input{Colors.ENDC}")
        
        input(f"\n{Colors.WARNING}Press Enter to continue...{Colors.ENDC}")
    
    def ai_chain_builder(self):
        """AI-powered chain builder"""
        clear_screen()
        print(f"\n{Colors.HEADER}=== AI-Powered Chain Builder ==={Colors.ENDC}\n")
        
        if not self.ai_orchestrator:
            print(f"{Colors.FAIL}[!] AI Orchestrator not available{Colors.ENDC}")
            print("Using fallback rule-based recommendations...")
        
        print("Provide target information for AI analysis:")
        
        # Collect target data
        target_data = {}
        target_data['browser'] = input(f"{Colors.WARNING}Target Browser (chrome/firefox/edge): {Colors.ENDC}") or 'chrome'
        target_data['version'] = input(f"{Colors.WARNING}Browser Version: {Colors.ENDC}") or '125.0.0.0'
        target_data['os_type'] = input(f"{Colors.WARNING}Operating System (windows/linux/macos): {Colors.ENDC}") or 'windows'
        target_data['os_version'] = input(f"{Colors.WARNING}OS Version: {Colors.ENDC}") or '10'
        target_data['architecture'] = input(f"{Colors.WARNING}Architecture (x64/x86): {Colors.ENDC}") or 'x64'
        target_data['user_privileges'] = input(f"{Colors.WARNING}User Privileges (admin/user): {Colors.ENDC}") or 'user'
        target_data['network_context'] = input(f"{Colors.WARNING}Network Context (local/remote): {Colors.ENDC}") or 'remote'
        
        # Security features
        print(f"\n{Colors.HEADER}Security Features (y/n):{Colors.ENDC}")
        security_features = []
        if input(f"{Colors.WARNING}ASLR enabled? (y/n): {Colors.ENDC}").lower() == 'y':
            security_features.append('aslr')
        if input(f"{Colors.WARNING}DEP enabled? (y/n): {Colors.ENDC}").lower() == 'y':
            security_features.append('dep')
        if input(f"{Colors.WARNING}Antivirus present? (y/n): {Colors.ENDC}").lower() == 'y':
            security_features.append('av')
        
        target_data['security_features'] = security_features
        target_data['additional_info'] = {
            'sandboxed': True,
            'av_present': 'av' in security_features,
            'patched': input(f"{Colors.WARNING}Recently patched? (y/n): {Colors.ENDC}").lower() == 'y'
        }
        
        print(f"\n{Colors.OKBLUE}[*] Analyzing target with AI...{Colors.ENDC}")
        
        try:
            if self.ai_orchestrator:
                analysis = self.ai_orchestrator.analyze_target(target_data)
            else:
                # Fallback analysis
                analysis = self._fallback_ai_analysis(target_data)
            
            # Display AI recommendations
            print(f"\n{Colors.HEADER}=== AI Analysis Results ==={Colors.ENDC}")
            print(f"Recommended Exploit: {Colors.OKGREEN}{analysis['recommended_exploit']}{Colors.ENDC}")
            print(f"Confidence: {Colors.OKBLUE}{analysis['confidence']:.1%}{Colors.ENDC}")
            print(f"Success Probability: {Colors.WARNING}{analysis.get('success_probability', 0.7):.1%}{Colors.ENDC}")
            print(f"Risk Level: {self._get_risk_color(analysis.get('risk_level', 'medium'))}{analysis.get('risk_level', 'medium').upper()}{Colors.ENDC}")
            print(f"Reasoning: {analysis.get('reasoning', 'AI analysis completed')}")
            
            if analysis.get('alternatives'):
                print(f"\nAlternative Exploits: {', '.join(analysis['alternatives'])}")
            
            # Ask if user wants to create chain
            create_chain = input(f"\n{Colors.WARNING}Create exploit chain based on AI recommendations? (y/n): {Colors.ENDC}")
            
            if create_chain.lower() == 'y':
                chain_name = input(f"{Colors.WARNING}Chain name: {Colors.ENDC}") or "AI-Generated Chain"
                
                chain = self.chain_manager.create_chain(
                    chain_name,
                    f"AI-generated chain for {target_data['browser']} on {target_data['os_type']}"
                )
                
                # Add primary exploit
                recommended_params = analysis.get('target_analysis', {}).get('recommended_parameters', {})
                recommended_params.update(target_data)
                
                chain.add_step(
                    cve_id=analysis['recommended_exploit'],
                    description=f"AI-recommended primary exploit",
                    parameters=recommended_params
                )
                
                # Add alternative exploits if confidence is not high
                if analysis['confidence'] < 0.8 and analysis.get('alternatives'):
                    for alt_cve in analysis['alternatives'][:2]:  # Add up to 2 alternatives
                        chain.add_step(
                            cve_id=alt_cve,
                            description=f"Alternative exploit: {alt_cve}",
                            parameters=recommended_params,
                            failure_action='continue'
                        )
                
                print(f"\n{Colors.OKGREEN}[+] AI-generated chain created: {chain.name}{Colors.ENDC}")
                print(f"    Chain ID: {chain.id}")
                print(f"    Steps: {len(chain.steps)}")
            
        except Exception as e:
            self.logger.error(f"AI analysis failed: {e}")
            print(f"{Colors.FAIL}[!] AI analysis failed: {e}{Colors.ENDC}")
        
        input(f"\n{Colors.WARNING}Press Enter to continue...{Colors.ENDC}")
    
    def monitor_chains(self):
        """Monitor chain execution status"""
        clear_screen()
        print(f"\n{Colors.HEADER}=== Chain Status Monitor ==={Colors.ENDC}\n")
        
        chains = self.chain_manager.list_chains()
        
        if not chains:
            print(f"{Colors.WARNING}[!] No chains to monitor{Colors.ENDC}")
            input(f"{Colors.WARNING}Press Enter to continue...{Colors.ENDC}")
            return
        
        while True:
            clear_screen()
            print(f"\n{Colors.HEADER}=== Chain Status Monitor ==={Colors.ENDC}")
            print(f"Updated: {datetime.now().strftime('%H:%M:%S')}\n")
            
            chains = self.chain_manager.list_chains()
            running_chains = [c for c in chains if c['status'] == 'running']
            
            if not running_chains:
                print(f"{Colors.WARNING}[!] No chains currently running{Colors.ENDC}")
            else:
                for chain in running_chains:
                    status_color = self._get_status_color(chain['status'])
                    print(f"{Colors.OKBLUE}{chain['name']}{Colors.ENDC}")
                    print(f"  Status: {status_color}{chain['status'].upper()}{Colors.ENDC}")
                    print(f"  Progress: {chain['progress']}")
                    print(f"  Runtime: {chain['execution_time']:.1f}s")
                    print()
            
            print(f"\n{Colors.WARNING}Commands:{Colors.ENDC}")
            print("s - Stop a chain")
            print("r - Refresh")
            print("q - Quit monitor")
            
            choice = input(f"\n{Colors.WARNING}Choice: {Colors.ENDC}").lower()
            
            if choice == 'q':
                break
            elif choice == 's':
                self._stop_chain_interactive(chains)
            elif choice == 'r':
                continue
            
            # Auto-refresh every 2 seconds if no input
            import time
            time.sleep(2)
    
    def import_export_menu(self):
        """Import/Export chains submenu"""
        while True:
            clear_screen()
            print(f"\n{Colors.HEADER}=== Import/Export Chains ==={Colors.ENDC}\n")
            
            print("1. Export Chain")
            print("2. Import Chain")
            print("0. Back")
            
            choice = input(f"\n{Colors.WARNING}Choice: {Colors.ENDC}")
            
            if choice == "1":
                self._export_chain()
            elif choice == "2":
                self._import_chain()
            elif choice == "0":
                break
    
    def _export_chain(self):
        """Export a chain to file"""
        chains = self.chain_manager.list_chains()
        
        if not chains:
            print(f"{Colors.WARNING}[!] No chains to export{Colors.ENDC}")
            input(f"{Colors.WARNING}Press Enter to continue...{Colors.ENDC}")
            return
        
        # List chains
        for i, chain in enumerate(chains, 1):
            print(f"{Colors.OKBLUE}[{i}]{Colors.ENDC} {chain['name']}")
        
        try:
            choice = int(input(f"\n{Colors.WARNING}Select chain to export: {Colors.ENDC}"))
            if 1 <= choice <= len(chains):
                chain_id = chains[choice - 1]['id']
                filename = input(f"{Colors.WARNING}Export filename (without extension): {Colors.ENDC}")
                
                if not filename:
                    filename = f"chain_{chain_id}"
                
                filepath = f"/tmp/{filename}.json"
                
                if self.chain_manager.export_chain(chain_id, filepath):
                    print(f"{Colors.OKGREEN}[+] Chain exported to: {filepath}{Colors.ENDC}")
                else:
                    print(f"{Colors.FAIL}[!] Export failed{Colors.ENDC}")
            else:
                print(f"{Colors.FAIL}[!] Invalid selection{Colors.ENDC}")
                
        except ValueError:
            print(f"{Colors.FAIL}[!] Invalid input{Colors.ENDC}")
        
        input(f"\n{Colors.WARNING}Press Enter to continue...{Colors.ENDC}")
    
    def _import_chain(self):
        """Import a chain from file"""
        filepath = input(f"{Colors.WARNING}Import file path: {Colors.ENDC}")
        
        if not os.path.exists(filepath):
            print(f"{Colors.FAIL}[!] File not found: {filepath}{Colors.ENDC}")
            input(f"{Colors.WARNING}Press Enter to continue...{Colors.ENDC}")
            return
        
        chain = self.chain_manager.import_chain(filepath)
        
        if chain:
            print(f"{Colors.OKGREEN}[+] Chain imported successfully: {chain.name}{Colors.ENDC}")
            print(f"    Chain ID: {chain.id}")
            print(f"    Steps: {len(chain.steps)}")
        else:
            print(f"{Colors.FAIL}[!] Import failed{Colors.ENDC}")
        
        input(f"\n{Colors.WARNING}Press Enter to continue...{Colors.ENDC}")
    
    def _create_custom_template(self):
        """Create custom chain template"""
        print(f"\n{Colors.HEADER}Custom Template Builder{Colors.ENDC}")
        print("This feature allows you to create reusable chain templates")
        print("Custom template creation would be implemented here")
        input(f"\n{Colors.WARNING}Press Enter to continue...{Colors.ENDC}")
    
    def _stop_chain_interactive(self, chains: List[Dict]):
        """Interactive chain stopping"""
        running_chains = [c for c in chains if c['status'] == 'running']
        
        if not running_chains:
            print(f"{Colors.WARNING}[!] No running chains to stop{Colors.ENDC}")
            return
        
        for i, chain in enumerate(running_chains, 1):
            print(f"{Colors.OKBLUE}[{i}]{Colors.ENDC} {chain['name']}")
        
        try:
            choice = int(input(f"\n{Colors.WARNING}Select chain to stop: {Colors.ENDC}"))
            if 1 <= choice <= len(running_chains):
                chain_id = running_chains[choice - 1]['id']
                
                if self.chain_manager.stop_chain(chain_id):
                    print(f"{Colors.OKGREEN}[+] Chain stopped{Colors.ENDC}")
                else:
                    print(f"{Colors.FAIL}[!] Failed to stop chain{Colors.ENDC}")
            else:
                print(f"{Colors.FAIL}[!] Invalid selection{Colors.ENDC}")
                
        except ValueError:
            print(f"{Colors.FAIL}[!] Invalid input{Colors.ENDC}")
    
    def _fallback_ai_analysis(self, target_data: Dict) -> Dict:
        """Fallback AI analysis when orchestrator unavailable"""
        browser = target_data.get('browser', '').lower()
        os_type = target_data.get('os_type', '').lower()
        
        # Simple rule-based recommendations
        if 'chrome' in browser:
            if 'windows' in os_type:
                recommended = 'CVE-2025-2783'
                confidence = 0.8
                reasoning = "Chrome on Windows - Mojo sandbox escape recommended"
            else:
                recommended = 'CVE-2025-4664'
                confidence = 0.75
                reasoning = "Chrome browser - data leak exploit suitable"
        elif 'firefox' in browser:
            recommended = 'CVE-2025-2857'
            confidence = 0.85
            reasoning = "Firefox browser - IPDL handle confusion exploit"
        elif 'edge' in browser:
            recommended = 'CVE-2025-30397'
            confidence = 0.9
            reasoning = "Edge browser - WebAssembly JIT exploit optimal"
        else:
            recommended = 'CVE-2025-4664'
            confidence = 0.6
            reasoning = "Unknown browser - using generic Chrome exploit"
        
        return {
            'recommended_exploit': recommended,
            'confidence': confidence,
            'success_probability': 0.7,
            'risk_level': 'medium',
            'reasoning': reasoning + ' (fallback analysis)',
            'alternatives': [],
            'fallback': True
        }
    
    def _get_status_color(self, status: str) -> str:
        """Get color for chain status"""
        colors = {
            'pending': Colors.OKBLUE,
            'running': Colors.WARNING,
            'success': Colors.OKGREEN,
            'failed': Colors.FAIL,
            'partial': Colors.WARNING,
            'stopped': Colors.ENDC
        }
        return colors.get(status, Colors.ENDC)
    
    def _get_risk_color(self, risk_level: str) -> str:
        """Get color for risk level"""
        colors = {
            'low': Colors.OKGREEN,
            'medium': Colors.WARNING,
            'high': Colors.FAIL
        }
        return colors.get(risk_level, Colors.ENDC)


if __name__ == "__main__":
    # Test the menu
    menu = ExploitChainMenu()
    menu.run()