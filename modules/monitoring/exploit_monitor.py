#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Exploit Monitoring & Analytics
Real-time monitoring and statistics for exploit execution
"""

import time
import json
import logging
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass, asdict
from datetime import datetime, timezone
from collections import defaultdict
from pathlib import Path

logger = logging.getLogger(__name__)


@dataclass
class ExploitAttempt:
    """Single exploit attempt record"""
    exploit_id: str
    target_browser: str
    target_version: str
    timestamp: float
    success: bool
    execution_time: float
    error_message: Optional[str] = None
    payload_size: Optional[int] = None
    obfuscation_level: Optional[str] = None


@dataclass
class ExploitStatistics:
    """Statistics for an exploit"""
    exploit_id: str
    total_attempts: int
    successful_attempts: int
    failed_attempts: int
    success_rate: float
    average_execution_time: float
    browser_distribution: Dict[str, int]
    version_distribution: Dict[str, int]
    last_execution: Optional[float] = None


class ExploitMonitor:
    """Monitor and track exploit execution"""
    
    def __init__(self, data_dir: Optional[Path] = None):
        self.data_dir = data_dir or Path(__file__).parent.parent.parent / "data" / "monitoring"
        self.data_dir.mkdir(parents=True, exist_ok=True)
        
        self.attempts: List[ExploitAttempt] = []
        self.statistics: Dict[str, ExploitStatistics] = {}
        self.active_exploits: Dict[str, Dict[str, Any]] = {}
        
        # Load historical data
        self._load_historical_data()
    
    def _load_historical_data(self):
        """Load historical monitoring data"""
        history_file = self.data_dir / "exploit_history.json"
        
        if history_file.exists():
            try:
                with open(history_file, 'r') as f:
                    data = json.load(f)
                    self.attempts = [ExploitAttempt(**attempt) for attempt in data.get("attempts", [])]
                    self._update_statistics()
                    logger.info(f"Loaded {len(self.attempts)} historical exploit attempts")
            except Exception as e:
                logger.warning(f"Could not load historical data: {e}")
    
    def _save_historical_data(self):
        """Save historical monitoring data"""
        history_file = self.data_dir / "exploit_history.json"
        
        try:
            data = {
                "attempts": [asdict(attempt) for attempt in self.attempts[-1000:]],  # Keep last 1000
                "last_updated": datetime.now(timezone.utc).isoformat()
            }
            
            with open(history_file, 'w') as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            logger.error(f"Could not save historical data: {e}")
    
    def track_exploit_start(self, exploit_id: str, target_browser: str, 
                           target_version: str, **kwargs) -> str:
        """Track exploit start"""
        attempt_id = f"{exploit_id}_{int(time.time() * 1000)}"
        
        self.active_exploits[attempt_id] = {
            "exploit_id": exploit_id,
            "target_browser": target_browser,
            "target_version": target_version,
            "start_time": time.time(),
            "metadata": kwargs
        }
        
        logger.info(f"[Monitor] Started tracking exploit: {exploit_id} on {target_browser} {target_version}")
        return attempt_id
    
    def track_exploit_end(self, attempt_id: str, success: bool, 
                         error_message: Optional[str] = None, **kwargs):
        """Track exploit end"""
        if attempt_id not in self.active_exploits:
            logger.warning(f"[Monitor] Attempt ID not found: {attempt_id}")
            return
        
        attempt_data = self.active_exploits.pop(attempt_id)
        execution_time = time.time() - attempt_data["start_time"]
        
        attempt = ExploitAttempt(
            exploit_id=attempt_data["exploit_id"],
            target_browser=attempt_data["target_browser"],
            target_version=attempt_data["target_version"],
            timestamp=attempt_data["start_time"],
            success=success,
            execution_time=execution_time,
            error_message=error_message,
            payload_size=kwargs.get("payload_size"),
            obfuscation_level=kwargs.get("obfuscation_level")
        )
        
        self.attempts.append(attempt)
        self._update_statistics()
        self._save_historical_data()
        
        logger.info(f"[Monitor] Exploit {attempt_data['exploit_id']} {'succeeded' if success else 'failed'} "
                   f"in {execution_time:.2f}s")
    
    def _update_statistics(self):
        """Update statistics from attempts"""
        self.statistics = {}
        
        # Group by exploit_id
        by_exploit = defaultdict(list)
        for attempt in self.attempts:
            by_exploit[attempt.exploit_id].append(attempt)
        
        for exploit_id, attempts in by_exploit.items():
            successful = [a for a in attempts if a.success]
            failed = [a for a in attempts if not a.success]
            
            browser_dist = defaultdict(int)
            version_dist = defaultdict(int)
            
            for attempt in attempts:
                browser_dist[attempt.target_browser] += 1
                version_dist[attempt.target_version] += 1
            
            avg_time = sum(a.execution_time for a in attempts) / len(attempts) if attempts else 0.0
            last_execution = max(a.timestamp for a in attempts) if attempts else None
            
            self.statistics[exploit_id] = ExploitStatistics(
                exploit_id=exploit_id,
                total_attempts=len(attempts),
                successful_attempts=len(successful),
                failed_attempts=len(failed),
                success_rate=len(successful) / len(attempts) if attempts else 0.0,
                average_execution_time=avg_time,
                browser_distribution=dict(browser_dist),
                version_distribution=dict(version_dist),
                last_execution=last_execution
            )
    
    def get_statistics(self, exploit_id: Optional[str] = None) -> Dict[str, Any]:
        """Get statistics for exploit(s)"""
        if exploit_id:
            if exploit_id in self.statistics:
                return asdict(self.statistics[exploit_id])
            return {}
        
        return {eid: asdict(stats) for eid, stats in self.statistics.items()}
    
    def get_success_rate(self, exploit_id: str) -> float:
        """Get success rate for an exploit"""
        if exploit_id in self.statistics:
            return self.statistics[exploit_id].success_rate
        return 0.0
    
    def get_performance_metrics(self) -> Dict[str, Any]:
        """Get overall performance metrics"""
        if not self.attempts:
            return {
                "total_attempts": 0,
                "total_successful": 0,
                "total_failed": 0,
                "overall_success_rate": 0.0,
                "average_execution_time": 0.0
            }
        
        successful = [a for a in self.attempts if a.success]
        
        return {
            "total_attempts": len(self.attempts),
            "total_successful": len(successful),
            "total_failed": len(self.attempts) - len(successful),
            "overall_success_rate": len(successful) / len(self.attempts),
            "average_execution_time": sum(a.execution_time for a in self.attempts) / len(self.attempts)
        }
    
    def generate_report(self, exploit_id: Optional[str] = None) -> Dict[str, Any]:
        """Generate monitoring report"""
        report = {
            "generated_at": datetime.now(timezone.utc).isoformat(),
            "performance_metrics": self.get_performance_metrics(),
            "statistics": self.get_statistics(exploit_id)
        }
        
        return report
    
    def get_recent_attempts(self, limit: int = 10) -> List[Dict[str, Any]]:
        """Get recent exploit attempts"""
        recent = sorted(self.attempts, key=lambda x: x.timestamp, reverse=True)[:limit]
        return [asdict(attempt) for attempt in recent]
    
    def get_browser_distribution(self) -> Dict[str, int]:
        """Get browser distribution across all attempts"""
        distribution = defaultdict(int)
        for attempt in self.attempts:
            distribution[attempt.target_browser] += 1
        return dict(distribution)
    
    def get_top_exploits(self, limit: int = 5) -> List[Tuple[str, float]]:
        """Get top exploits by success rate"""
        sorted_exploits = sorted(
            self.statistics.items(),
            key=lambda x: x[1].success_rate,
            reverse=True
        )[:limit]
        
        return [(eid, stats.success_rate) for eid, stats in sorted_exploits]


# Singleton instance
_monitor_instance = None

def get_exploit_monitor() -> ExploitMonitor:
    """Get global exploit monitor instance"""
    global _monitor_instance
    if _monitor_instance is None:
        _monitor_instance = ExploitMonitor()
    return _monitor_instance
