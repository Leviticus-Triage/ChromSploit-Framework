#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Exploit Caching System
Cache payloads, obfuscation results, and browser detection results
"""

import hashlib
import json
import time
import logging
from typing import Dict, Any, Optional
from pathlib import Path
from dataclasses import dataclass, asdict
from datetime import datetime, timedelta

logger = logging.getLogger(__name__)


@dataclass
class CacheEntry:
    """Cache entry structure"""
    key: str
    value: Any
    timestamp: float
    expires_at: Optional[float] = None
    hits: int = 0
    last_accessed: Optional[float] = None


class ExploitCache:
    """Caching system for exploit-related data"""
    
    def __init__(self, cache_dir: Optional[Path] = None, max_size: int = 1000, 
                 default_ttl: int = 3600):
        self.cache_dir = cache_dir or Path(__file__).parent.parent.parent / "data" / "cache"
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        self.max_size = max_size
        self.default_ttl = default_ttl  # Default TTL in seconds
        
        self.memory_cache: Dict[str, CacheEntry] = {}
        self.cache_file = self.cache_dir / "cache.json"
        
        # Load persistent cache
        self._load_cache()
    
    def _generate_key(self, prefix: str, *args, **kwargs) -> str:
        """Generate cache key"""
        key_data = {
            "prefix": prefix,
            "args": args,
            "kwargs": sorted(kwargs.items())
        }
        key_str = json.dumps(key_data, sort_keys=True)
        return hashlib.sha256(key_str.encode()).hexdigest()
    
    def get(self, key: str) -> Optional[Any]:
        """Get value from cache"""
        if key not in self.memory_cache:
            return None
        
        entry = self.memory_cache[key]
        
        # Check expiration
        if entry.expires_at and time.time() > entry.expires_at:
            del self.memory_cache[key]
            return None
        
        # Update access statistics
        entry.hits += 1
        entry.last_accessed = time.time()
        
        return entry.value
    
    def set(self, key: str, value: Any, ttl: Optional[int] = None) -> None:
        """Set value in cache"""
        ttl = ttl or self.default_ttl
        expires_at = time.time() + ttl
        
        entry = CacheEntry(
            key=key,
            value=value,
            timestamp=time.time(),
            expires_at=expires_at,
            hits=0,
            last_accessed=time.time()
        )
        
        # Evict if cache is full
        if len(self.memory_cache) >= self.max_size:
            self._evict_oldest()
        
        self.memory_cache[key] = entry
        self._save_cache()
    
    def _evict_oldest(self):
        """Evict oldest cache entry"""
        if not self.memory_cache:
            return
        
        # Find oldest entry (by last_accessed or timestamp)
        oldest_key = min(
            self.memory_cache.keys(),
            key=lambda k: self.memory_cache[k].last_accessed or self.memory_cache[k].timestamp
        )
        
        del self.memory_cache[oldest_key]
        logger.debug(f"Evicted cache entry: {oldest_key}")
    
    def invalidate(self, key: str) -> bool:
        """Invalidate cache entry"""
        if key in self.memory_cache:
            del self.memory_cache[key]
            self._save_cache()
            return True
        return False
    
    def clear(self):
        """Clear all cache"""
        self.memory_cache.clear()
        self._save_cache()
    
    def get_payload_cache_key(self, exploit_id: str, parameters: Dict[str, Any]) -> str:
        """Get cache key for payload"""
        return self._generate_key("payload", exploit_id, **parameters)
    
    def cache_payload(self, exploit_id: str, parameters: Dict[str, Any], 
                     payload: str, ttl: Optional[int] = None) -> str:
        """Cache exploit payload"""
        key = self.get_payload_cache_key(exploit_id, parameters)
        self.set(key, payload, ttl)
        return key
    
    def get_cached_payload(self, exploit_id: str, parameters: Dict[str, Any]) -> Optional[str]:
        """Get cached payload"""
        key = self.get_payload_cache_key(exploit_id, parameters)
        return self.get(key)
    
    def get_obfuscation_cache_key(self, payload: str, obfuscation_level: str) -> str:
        """Get cache key for obfuscation"""
        return self._generate_key("obfuscation", payload, obfuscation_level=obfuscation_level)
    
    def cache_obfuscation(self, payload: str, obfuscation_level: str, 
                         obfuscated: str, ttl: Optional[int] = None) -> str:
        """Cache obfuscation result"""
        key = self.get_obfuscation_cache_key(payload, obfuscation_level)
        self.set(key, obfuscated, ttl)
        return key
    
    def get_cached_obfuscation(self, payload: str, obfuscation_level: str) -> Optional[str]:
        """Get cached obfuscation"""
        key = self.get_obfuscation_cache_key(payload, obfuscation_level)
        return self.get(key)
    
    def get_browser_detection_cache_key(self, user_agent: str) -> str:
        """Get cache key for browser detection"""
        return self._generate_key("browser_detection", user_agent)
    
    def cache_browser_detection(self, user_agent: str, browser_info: Dict[str, Any], 
                               ttl: Optional[int] = None) -> str:
        """Cache browser detection result"""
        key = self.get_browser_detection_cache_key(user_agent)
        self.set(key, browser_info, ttl or 86400)  # 24 hours for browser detection
        return key
    
    def get_cached_browser_detection(self, user_agent: str) -> Optional[Dict[str, Any]]:
        """Get cached browser detection"""
        key = self.get_browser_detection_cache_key(user_agent)
        return self.get(key)
    
    def get_stats(self) -> Dict[str, Any]:
        """Get cache statistics"""
        total_entries = len(self.memory_cache)
        total_hits = sum(entry.hits for entry in self.memory_cache.values())
        
        # Count by type
        payload_keys = sum(1 for k in self.memory_cache.keys() if k.startswith("payload"))
        obfuscation_keys = sum(1 for k in self.memory_cache.keys() if k.startswith("obfuscation"))
        detection_keys = sum(1 for k in self.memory_cache.keys() if k.startswith("browser_detection"))
        
        return {
            "total_entries": total_entries,
            "total_hits": total_hits,
            "payload_entries": payload_keys,
            "obfuscation_entries": obfuscation_keys,
            "detection_entries": detection_keys,
            "max_size": self.max_size,
            "usage_percent": (total_entries / self.max_size * 100) if self.max_size > 0 else 0
        }
    
    def _save_cache(self):
        """Save cache to disk"""
        try:
            # Only save non-expired entries
            valid_entries = {
                k: asdict(v) for k, v in self.memory_cache.items()
                if not v.expires_at or time.time() < v.expires_at
            }
            
            data = {
                "entries": valid_entries,
                "saved_at": datetime.now().isoformat()
            }
            
            with open(self.cache_file, 'w') as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            logger.warning(f"Could not save cache: {e}")
    
    def _load_cache(self):
        """Load cache from disk"""
        if not self.cache_file.exists():
            return
        
        try:
            with open(self.cache_file, 'r') as f:
                data = json.load(f)
            
            now = time.time()
            loaded = 0
            
            for key, entry_data in data.get("entries", {}).items():
                # Check if expired
                if entry_data.get("expires_at") and now > entry_data["expires_at"]:
                    continue
                
                entry = CacheEntry(**entry_data)
                self.memory_cache[key] = entry
                loaded += 1
            
            logger.info(f"Loaded {loaded} cache entries from disk")
        except Exception as e:
            logger.warning(f"Could not load cache: {e}")


# Singleton instance
_cache_instance = None

def get_exploit_cache() -> ExploitCache:
    """Get global exploit cache instance"""
    global _cache_instance
    if _cache_instance is None:
        _cache_instance = ExploitCache()
    return _cache_instance
