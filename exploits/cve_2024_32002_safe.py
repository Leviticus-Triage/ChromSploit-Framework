#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
CVE-2024-32002: Git Remote Code Execution (SAFE VERSION)
Safe simulation of Git RCE vulnerability for educational purposes
"""

import os
import json
import time
import tempfile
from pathlib import Path
from typing import Dict, List, Any, Optional

from .safe_exploit_base import SafeExploitBase, SafetyMode


class CVE2024_32002_Safe(SafeExploitBase):
    """Safe implementation of CVE-2024-32002 Git RCE exploit"""
    
    def __init__(self):
        super().__init__(
            cve_id="CVE-2024-32002",
            name="Git Remote Code Execution via Symbolic Links",
            description="Git RCE vulnerability through symbolic link and submodule manipulation"
        )
        
        # Default safe configuration
        self.config.update({
            'payload_type': 'webshell',
            'callback_ip': '127.0.0.1',
            'callback_port': 4444,
            'repository_name': 'safe-demo-repo',
            'serve_repository': False,  # Don't start real servers in safe mode
            'cleanup_on_exit': True
        })
        
        self.repository_path = None
        self.simulation_artifacts = []
    
    def _validate_payloads(self) -> bool:
        """Validate payloads are safe"""
        # In safe mode, we don't use real payloads
        return self.safety_mode != SafetyMode.AUTHORIZED or self.config['callback_ip'] in ['127.0.0.1', 'localhost']
    
    def _execute_simulation(self, target_url: str = None) -> Dict[str, Any]:
        """Execute safe simulation of Git RCE"""
        try:
            self._log_safe("Starting Git RCE simulation - no actual exploitation will occur")
            
            # Create temporary directory for simulation
            self.repository_path = tempfile.mkdtemp(prefix='cve_2024_32002_sim_')
            self.simulation_artifacts.append(self.repository_path)
            
            # Phase 1: Simulate repository creation
            self._log_safe("Phase 1: Creating simulated malicious repository structure")
            repo_structure = self._create_simulated_repository()
            
            # Phase 2: Simulate vulnerability
            self._log_safe("Phase 2: Simulating symbolic link vulnerability")
            vuln_simulation = self._simulate_vulnerability()
            
            # Phase 3: Create educational artifacts
            self._log_safe("Phase 3: Creating educational demonstration files")
            demo_files = self._create_demonstration_files()
            
            # Phase 4: Generate safe proof-of-concept
            self._log_safe("Phase 4: Generating safe proof-of-concept")
            poc_data = self._generate_safe_poc()
            
            # Create comprehensive result
            result = {
                'success': True,
                'cve_id': self.cve_id,
                'mode': 'simulation',
                'description': 'Safe simulation of Git RCE vulnerability',
                'repository_path': self.repository_path,
                'simulation_data': {
                    'repository_structure': repo_structure,
                    'vulnerability_simulation': vuln_simulation,
                    'demonstration_files': demo_files,
                    'poc_data': poc_data
                },
                'educational_info': {
                    'vulnerability_explanation': self._get_vulnerability_explanation(),
                    'exploitation_steps': self._get_exploitation_steps(),
                    'mitigation_advice': self._get_mitigation_advice()
                },
                'artifacts_created': self.simulation_artifacts,
                'safety_notice': "This is a safe simulation. No actual exploitation occurred."
            }
            
            self._log_safe("Git RCE simulation completed successfully")
            return result
            
        except Exception as e:
            self._log_error(f"Simulation failed: {e}")
            return self._create_safe_failure_response(str(e))
    
    def _create_simulated_repository(self) -> Dict[str, Any]:
        """Create simulated Git repository structure"""
        repo_structure = {
            'directories': [],
            'files': [],
            'symbolic_links': []
        }
        
        # Create basic Git structure
        git_dir = os.path.join(self.repository_path, '.git')
        os.makedirs(git_dir, exist_ok=True)
        repo_structure['directories'].append('.git')
        
        # Create hooks directory
        hooks_dir = os.path.join(git_dir, 'hooks')
        os.makedirs(hooks_dir, exist_ok=True)
        repo_structure['directories'].append('.git/hooks')
        
        # Create modules directory for symlink simulation
        modules_dir = os.path.join(self.repository_path, 'modules')
        os.makedirs(modules_dir, exist_ok=True)
        repo_structure['directories'].append('modules')
        
        # Create safe demonstration files
        demo_hook = os.path.join(hooks_dir, 'post-commit-demo')
        with open(demo_hook, 'w') as f:
            f.write('#!/bin/bash\n')
            f.write('# CVE-2024-32002 Demonstration Hook (SAFE)\n')
            f.write('echo "This is a safe demonstration hook"\n')
            f.write('echo "In a real attack, this would execute malicious code"\n')
        repo_structure['files'].append('.git/hooks/post-commit-demo')
        
        # Create .gitmodules simulation
        gitmodules_path = os.path.join(self.repository_path, '.gitmodules')
        with open(gitmodules_path, 'w') as f:
            f.write('[submodule "demo"]\n')
            f.write('\tpath = modules/demo\n')
            f.write('\turl = https://safe.demo/repo.git\n')
            f.write('\t# This demonstrates how malicious submodules could be configured\n')
        repo_structure['files'].append('.gitmodules')
        
        # Simulate symbolic link (as text file in safe mode)
        symlink_demo = os.path.join(modules_dir, 'symlink-demo.txt')
        with open(symlink_demo, 'w') as f:
            f.write('SYMBOLIC LINK DEMONSTRATION\n')
            f.write('Target: ../.git/hooks\n')
            f.write('In a real attack, this would be an actual symbolic link\n')
            f.write('pointing to the Git hooks directory for exploitation\n')
        repo_structure['symbolic_links'].append({
            'source': 'modules/hooks',
            'target': '../.git/hooks',
            'simulated_as': 'modules/symlink-demo.txt'
        })
        
        return repo_structure
    
    def _simulate_vulnerability(self) -> Dict[str, Any]:
        """Simulate the vulnerability behavior"""
        return {
            'vulnerability_type': 'Symbolic Link Directory Traversal',
            'affected_component': 'Git submodule handling',
            'attack_vector': 'Malicious repository with crafted symbolic links',
            'simulation_steps': [
                {
                    'step': 1,
                    'action': 'Repository cloned by victim',
                    'result': 'Malicious repository structure downloaded'
                },
                {
                    'step': 2,
                    'action': 'Submodule initialization triggered',
                    'result': 'Symbolic link confusion exploited'
                },
                {
                    'step': 3,
                    'action': 'Git hooks directory overwritten',
                    'result': 'Malicious hooks installed (simulated)'
                },
                {
                    'step': 4,
                    'action': 'Git operation triggers hook',
                    'result': 'Code execution achieved (simulated)'
                }
            ],
            'exploit_success': True,
            'simulated_impact': 'Remote code execution with user privileges'
        }
    
    def _create_demonstration_files(self) -> List[str]:
        """Create educational demonstration files"""
        demo_files = []
        
        # Create exploitation explanation
        explanation_file = os.path.join(self.repository_path, 'CVE-2024-32002-EXPLANATION.md')
        with open(explanation_file, 'w') as f:
            f.write("""# CVE-2024-32002: Git RCE Vulnerability Demonstration

## Overview
This is a SAFE demonstration of the Git remote code execution vulnerability.
No actual exploitation is performed.

## How the Vulnerability Works

1. **Symbolic Link Confusion**: The attacker creates a repository with symbolic links
   that point to sensitive directories like `.git/hooks`.

2. **Submodule Manipulation**: Malicious submodules are configured to exploit the
   symbolic link handling during clone/update operations.

3. **Hook Installation**: Through the symbolic link traversal, malicious Git hooks
   are installed in the victim's repository.

4. **Code Execution**: When Git operations trigger the hooks, arbitrary code is
   executed with the user's privileges.

## Safe Demonstration

This demonstration shows the repository structure and explains the exploitation
process without performing any actual attacks. All files created are harmless
and for educational purposes only.

## Mitigation

- Keep Git updated to the latest version
- Be cautious when cloning repositories from untrusted sources
- Review submodule configurations before initialization
- Use `git config --global core.symlinks false` to disable symlink support
""")
        demo_files.append(explanation_file)
        self.simulation_artifacts.append(explanation_file)
        
        # Create safe hook demonstration
        safe_hook = os.path.join(self.repository_path, 'SAFE-HOOK-DEMO.sh')
        with open(safe_hook, 'w') as f:
            f.write("""#!/bin/bash
# CVE-2024-32002 Safe Hook Demonstration
# This shows what a malicious hook might look like, but with safe operations

echo "=== CVE-2024-32002 Safe Demonstration ==="
echo "This is a demonstration of what a malicious Git hook could do"
echo "In a real attack, this would:"
echo "  - Execute system commands"
echo "  - Establish reverse shells"
echo "  - Exfiltrate sensitive data"
echo "  - Modify files or install backdoors"
echo ""
echo "Current user: $(whoami)"
echo "Current directory: $(pwd)"
echo "Git version: $(git --version)"
echo ""
echo "No actual malicious actions are performed in this demonstration"
echo "=== End of Safe Demonstration ==="
""")
        os.chmod(safe_hook, 0o755)
        demo_files.append(safe_hook)
        self.simulation_artifacts.append(safe_hook)
        
        return demo_files
    
    def _generate_safe_poc(self) -> Dict[str, Any]:
        """Generate safe proof-of-concept data"""
        timestamp = int(time.time())
        poc_file = os.path.join(self.repository_path, f'poc_simulation_{timestamp}.json')
        
        poc_data = {
            'cve_id': self.cve_id,
            'timestamp': timestamp,
            'simulation_mode': True,
            'payload_type': self.config['payload_type'],
            'demonstration_data': {
                'repository_url': f'file://{self.repository_path}',
                'clone_command': f'git clone file://{self.repository_path} (SAFE DEMO)',
                'hooks_that_would_trigger': [
                    'post-commit',
                    'post-receive',
                    'post-checkout',
                    'pre-push'
                ],
                'potential_impact': 'Remote code execution with user privileges'
            },
            'safety_verification': {
                'real_exploitation': False,
                'network_connections': False,
                'file_modifications': 'Only in temporary directory',
                'system_changes': False
            }
        }
        
        with open(poc_file, 'w') as f:
            json.dump(poc_data, f, indent=2)
        
        self.simulation_artifacts.append(poc_file)
        return poc_data
    
    def _get_vulnerability_explanation(self) -> str:
        """Get detailed vulnerability explanation"""
        return """
CVE-2024-32002 is a critical vulnerability in Git that allows remote code execution
through the manipulation of symbolic links and submodules.

The vulnerability occurs when:
1. A malicious repository contains symbolic links pointing to sensitive directories
2. The repository uses submodules configured to exploit these symbolic links
3. During clone or submodule update operations, Git follows the symbolic links
4. This allows attackers to write files outside the intended directory structure
5. By targeting the .git/hooks directory, arbitrary code execution is achieved

This is particularly dangerous because:
- It requires no user interaction beyond cloning/updating a repository
- The attack is cross-platform (affects Windows, Linux, macOS)
- Git hooks execute with full user privileges
- The vulnerability can be triggered through various Git operations
"""
    
    def _get_exploitation_steps(self) -> List[str]:
        """Get exploitation steps for educational purposes"""
        return [
            "1. Attacker creates a malicious Git repository",
            "2. Repository contains symbolic links pointing to ../.git/hooks",
            "3. Submodules are configured to write through these symbolic links",
            "4. Victim clones the repository with --recurse-submodules",
            "5. Git follows the symbolic links during submodule initialization",
            "6. Malicious hooks are written to the .git/hooks directory",
            "7. Any Git operation that triggers hooks executes attacker's code",
            "8. Attacker gains code execution with victim's privileges"
        ]
    
    def _get_mitigation_advice(self) -> List[str]:
        """Get mitigation advice"""
        return [
            "Update Git to the latest patched version immediately",
            "Disable symbolic link support: git config --global core.symlinks false",
            "Be extremely cautious when cloning repositories from untrusted sources",
            "Review .gitmodules file before initializing submodules",
            "Use 'git clone' without --recurse-submodules for untrusted repos",
            "Implement repository scanning in CI/CD pipelines",
            "Consider using Git in a sandboxed environment for untrusted code",
            "Regularly audit Git hooks in your repositories",
            "Enable Git's safe directory feature for additional protection"
        ]
    
    def _execute_real(self, target_url: str = None) -> Dict[str, Any]:
        """Execute real exploit (only when properly authorized)"""
        if not self.authorization.is_authorized(self.cve_id):
            return self._create_safe_failure_response("Unauthorized access attempt")
        
        self._log_warning("Executing REAL Git RCE exploit - authorization verified")
        self._create_audit_log("REAL_EXECUTION_AUTHORIZED")
        
        # Real execution would go here, but we still add safety measures
        # Even in authorized mode, we should limit potential damage
        
        result = {
            'success': True,
            'cve_id': self.cve_id,
            'mode': 'authorized',
            'warning': 'Real exploitation mode - use with extreme caution',
            'target': target_url or 'local simulation',
            'limitations': [
                'Callbacks restricted to local addresses',
                'Payloads logged for audit purposes',
                'Automatic cleanup after execution'
            ]
        }
        
        return result
    
    def cleanup(self):
        """Clean up simulation artifacts"""
        self._log_safe("Cleaning up simulation artifacts")
        
        for artifact in self.simulation_artifacts:
            try:
                if os.path.isfile(artifact):
                    os.remove(artifact)
                elif os.path.isdir(artifact):
                    import shutil
                    shutil.rmtree(artifact)
            except Exception as e:
                self._log_warning(f"Failed to clean up {artifact}: {e}")
        
        self.simulation_artifacts.clear()


# Compatibility wrapper for existing code
class CVE2024_32002_Exploit(CVE2024_32002_Safe):
    """Compatibility wrapper - redirects to safe implementation"""
    
    def __init__(self):
        super().__init__()
        self._log_warning("Using safe implementation of CVE-2024-32002")


def execute_exploit(parameters: Dict[str, Any]) -> Dict[str, Any]:
    """Execute exploit with given parameters"""
    exploit = CVE2024_32002_Safe()
    
    # Set parameters
    for key, value in parameters.items():
        exploit.set_parameter(key, value)
    
    # Check for authorization
    if parameters.get('auth_code'):
        exploit.set_safety_mode(SafetyMode.AUTHORIZED, parameters['auth_code'])
    elif parameters.get('mode'):
        exploit.set_safety_mode(parameters['mode'])
    
    # Execute
    result = exploit.execute(parameters.get('target_url'))
    
    # Store exploit instance for cleanup
    result['_exploit_instance'] = exploit
    
    return result