#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ChromSploit Framework - Exploit Chain Management
Automated workflow combining multiple CVEs and attack techniques
"""

import os
import json
import time
import uuid
from typing import Dict, List, Any, Optional, Tuple, Callable
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
import logging
import threading

logger = logging.getLogger(__name__)


class ChainStatus(Enum):
    """Exploit chain execution status"""
    PENDING = "pending"
    RUNNING = "running"
    SUCCESS = "success"
    FAILED = "failed"
    PARTIAL = "partial"
    STOPPED = "stopped"


class ExploitStatus(Enum):
    """Individual exploit status"""
    PENDING = "pending"
    RUNNING = "running"
    SUCCESS = "success"
    FAILED = "failed"
    SKIPPED = "skipped"


@dataclass
class ExploitStep:
    """Individual exploit step in the chain"""
    id: str
    cve_id: str
    description: str
    parameters: Dict[str, Any]
    dependencies: List[str] = field(default_factory=list)
    timeout: int = 300  # 5 minutes default
    retry_count: int = 1
    success_condition: Optional[Callable] = None
    failure_action: str = "stop"  # stop, continue, retry
    order: int = 0
    
    # Runtime state
    status: ExploitStatus = ExploitStatus.PENDING
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None
    result: Optional[Dict] = None
    error: Optional[str] = None
    retry_attempts: int = 0


@dataclass
class ChainResult:
    """Result of exploit chain execution"""
    chain_id: str
    status: ChainStatus
    total_steps: int
    successful_steps: int
    failed_steps: int
    skipped_steps: int
    start_time: datetime
    end_time: Optional[datetime]
    execution_time: Optional[float]
    steps: List[ExploitStep]
    final_state: Dict[str, Any]
    artifacts: Dict[str, Any] = field(default_factory=dict)


class ExploitChain:
    """Manages automated exploit chains"""
    
    def __init__(self, name: str, description: str = ""):
        self.id = str(uuid.uuid4())
        self.name = name
        self.description = description
        self.steps: List[ExploitStep] = []
        self.global_state: Dict[str, Any] = {}
        self.status = ChainStatus.PENDING
        self.created_at = datetime.now()
        
        # Configuration
        self.stop_on_failure = True
        self.parallel_execution = False
        self.max_parallel_steps = 3
        
        # Callbacks
        self.step_callbacks: Dict[str, List[Callable]] = {
            'before_step': [],
            'after_step': [],
            'on_success': [],
            'on_failure': []
        }
        
        # Runtime
        self.current_step = 0
        self.start_time: Optional[datetime] = None
        self.end_time: Optional[datetime] = None
        self.execution_thread: Optional[threading.Thread] = None
        self.stop_requested = False
    
    def add_step(self, cve_id: str, description: str, parameters: Dict[str, Any],
                 dependencies: List[str] = None, timeout: int = 300,
                 retry_count: int = 1, failure_action: str = "stop") -> str:
        """Add a step to the exploit chain"""
        step_id = str(uuid.uuid4())
        step = ExploitStep(
            id=step_id,
            cve_id=cve_id,
            description=description,
            parameters=parameters,
            dependencies=dependencies or [],
            timeout=timeout,
            retry_count=retry_count,
            failure_action=failure_action,
            order=len(self.steps)
        )
        self.steps.append(step)
        return step_id
    
    def add_callback(self, event: str, callback: Callable):
        """Add callback for chain events"""
        if event in self.step_callbacks:
            self.step_callbacks[event].append(callback)
    
    def set_global_parameter(self, key: str, value: Any):
        """Set global parameter available to all steps"""
        self.global_state[key] = value
    
    def execute(self, async_execution: bool = False) -> ChainResult:
        """Execute the exploit chain"""
        if async_execution:
            self.execution_thread = threading.Thread(target=self._execute_chain)
            self.execution_thread.start()
            # Return preliminary result
            return ChainResult(
                chain_id=self.id,
                status=ChainStatus.RUNNING,
                total_steps=len(self.steps),
                successful_steps=0,
                failed_steps=0,
                skipped_steps=0,
                start_time=datetime.now(),
                end_time=None,
                execution_time=None,
                steps=self.steps.copy(),
                final_state=self.global_state.copy()
            )
        else:
            return self._execute_chain()
    
    def _execute_chain(self) -> ChainResult:
        """Internal chain execution logic"""
        self.status = ChainStatus.RUNNING
        self.start_time = datetime.now()
        
        logger.info(f"Starting exploit chain '{self.name}' with {len(self.steps)} steps")
        
        successful_steps = 0
        failed_steps = 0
        skipped_steps = 0
        
        try:
            # Sort steps by order and dependencies
            sorted_steps = self._resolve_dependencies()
            
            for step in sorted_steps:
                if self.stop_requested:
                    step.status = ExploitStatus.SKIPPED
                    skipped_steps += 1
                    continue
                
                # Execute step
                success = self._execute_step(step)
                
                if success:
                    successful_steps += 1
                else:
                    failed_steps += 1
                    
                    if step.failure_action == "stop" or self.stop_on_failure:
                        logger.warning(f"Stopping chain due to failed step: {step.id}")
                        # Mark remaining steps as skipped
                        for remaining_step in sorted_steps[sorted_steps.index(step) + 1:]:
                            remaining_step.status = ExploitStatus.SKIPPED
                            skipped_steps += 1
                        break
                    elif step.failure_action == "retry" and step.retry_attempts < step.retry_count:
                        # Retry the step
                        step.retry_attempts += 1
                        step.status = ExploitStatus.PENDING
                        success = self._execute_step(step)
                        if success:
                            successful_steps += 1
                            failed_steps -= 1
                        
            # Determine final status
            if failed_steps == 0 and skipped_steps == 0:
                self.status = ChainStatus.SUCCESS
            elif successful_steps > 0:
                self.status = ChainStatus.PARTIAL
            else:
                self.status = ChainStatus.FAILED
                
        except Exception as e:
            logger.error(f"Exploit chain execution failed: {e}")
            self.status = ChainStatus.FAILED
            
        finally:
            self.end_time = datetime.now()
            
        # Create result
        execution_time = (self.end_time - self.start_time).total_seconds() if self.end_time else None
        
        result = ChainResult(
            chain_id=self.id,
            status=self.status,
            total_steps=len(self.steps),
            successful_steps=successful_steps,
            failed_steps=failed_steps,
            skipped_steps=skipped_steps,
            start_time=self.start_time,
            end_time=self.end_time,
            execution_time=execution_time,
            steps=self.steps.copy(),
            final_state=self.global_state.copy()
        )
        
        logger.info(f"Exploit chain '{self.name}' completed: {self.status.value}")
        return result
    
    def _execute_step(self, step: ExploitStep) -> bool:
        """Execute individual exploit step"""
        step.status = ExploitStatus.RUNNING
        step.start_time = datetime.now()
        
        logger.info(f"Executing step {step.cve_id}: {step.description}")
        
        # Trigger before_step callbacks
        self._trigger_callbacks('before_step', step)
        
        try:
            # Merge global state with step parameters
            merged_params = {**self.global_state, **step.parameters}
            
            # Execute the exploit
            success, result = self._execute_exploit(step.cve_id, merged_params)
            
            step.result = result
            
            if success:
                step.status = ExploitStatus.SUCCESS
                
                # Update global state with results
                if isinstance(result, dict):
                    self.global_state.update(result.get('state', {}))
                
                # Trigger success callbacks
                self._trigger_callbacks('on_success', step)
                
                logger.info(f"Step {step.cve_id} completed successfully")
                return True
            else:
                step.status = ExploitStatus.FAILED
                step.error = result.get('error', 'Unknown error') if isinstance(result, dict) else str(result)
                
                # Trigger failure callbacks
                self._trigger_callbacks('on_failure', step)
                
                logger.error(f"Step {step.cve_id} failed: {step.error}")
                return False
                
        except Exception as e:
            step.status = ExploitStatus.FAILED
            step.error = str(e)
            logger.error(f"Step {step.cve_id} failed with exception: {e}")
            return False
            
        finally:
            step.end_time = datetime.now()
            # Trigger after_step callbacks
            self._trigger_callbacks('after_step', step)
    
    def _execute_exploit(self, cve_id: str, parameters: Dict[str, Any]) -> Tuple[bool, Any]:
        """Execute specific CVE exploit"""
        try:
            # Import exploit modules dynamically
            if cve_id == "CVE-2025-4664":
                from exploits.cve_2025_4664 import execute_exploit
            elif cve_id == "CVE-2025-2783":
                from exploits.cve_2025_2783 import execute_exploit
            elif cve_id == "CVE-2025-2857":
                from exploits.cve_2025_2857 import execute_exploit
            elif cve_id == "CVE-2025-30397":
                from exploits.cve_2025_30397 import execute_exploit
            else:
                # Try generic exploit execution
                from core.exploitation_chain import execute_generic_exploit
                return execute_generic_exploit(cve_id, parameters)
            
            # Execute the exploit
            result = execute_exploit(parameters)
            return True, result
            
        except ImportError:
            logger.error(f"Exploit module for {cve_id} not found")
            return False, {"error": f"Exploit module for {cve_id} not found"}
        except Exception as e:
            logger.error(f"Error executing {cve_id}: {e}")
            return False, {"error": str(e)}
    
    def _resolve_dependencies(self) -> List[ExploitStep]:
        """Resolve step dependencies and return sorted execution order"""
        # Simple topological sort for now
        sorted_steps = []
        remaining_steps = self.steps.copy()
        
        while remaining_steps:
            # Find steps with no unresolved dependencies
            ready_steps = []
            for step in remaining_steps:
                dependencies_met = True
                for dep_id in step.dependencies:
                    if not any(s.id == dep_id and s.status == ExploitStatus.SUCCESS 
                             for s in sorted_steps):
                        dependencies_met = False
                        break
                if dependencies_met:
                    ready_steps.append(step)
            
            if not ready_steps:
                # Circular dependency or missing dependency
                logger.warning("Circular or missing dependencies detected, using order-based execution")
                sorted_steps.extend(sorted(remaining_steps, key=lambda s: s.order))
                break
            
            # Add ready steps sorted by order
            ready_steps.sort(key=lambda s: s.order)
            sorted_steps.extend(ready_steps)
            
            # Remove ready steps from remaining
            for step in ready_steps:
                remaining_steps.remove(step)
        
        return sorted_steps
    
    def _trigger_callbacks(self, event: str, step: ExploitStep):
        """Trigger callbacks for specific event"""
        for callback in self.step_callbacks.get(event, []):
            try:
                callback(self, step)
            except Exception as e:
                logger.error(f"Error in {event} callback: {e}")
    
    def stop(self):
        """Stop the exploit chain execution"""
        self.stop_requested = True
        self.status = ChainStatus.STOPPED
        logger.info(f"Stop requested for exploit chain '{self.name}'")
    
    def get_status(self) -> Dict[str, Any]:
        """Get current chain execution status"""
        completed_steps = sum(1 for step in self.steps 
                            if step.status in [ExploitStatus.SUCCESS, ExploitStatus.FAILED, ExploitStatus.SKIPPED])
        
        return {
            'id': self.id,
            'name': self.name,
            'status': self.status.value,
            'progress': f"{completed_steps}/{len(self.steps)}",
            'current_step': self.current_step,
            'start_time': self.start_time.isoformat() if self.start_time else None,
            'execution_time': (datetime.now() - self.start_time).total_seconds() if self.start_time else 0
        }


class ExploitChainManager:
    """Manages multiple exploit chains"""
    
    def __init__(self):
        self.chains: Dict[str, ExploitChain] = {}
        self.chain_templates: Dict[str, Dict] = {}
        self._load_templates()
    
    def _load_templates(self):
        """Load predefined chain templates"""
        self.chain_templates = {
            'chrome_full_compromise': {
                'name': 'Chrome Full Compromise Chain',
                'description': 'Complete Chrome browser compromise workflow',
                'steps': [
                    {
                        'cve_id': 'CVE-2025-4664',
                        'description': 'Chrome data leak for reconnaissance',
                        'parameters': {'mode': 'recon'},
                        'timeout': 120
                    },
                    {
                        'cve_id': 'CVE-2025-2783',
                        'description': 'Chrome sandbox escape',
                        'parameters': {'payload_type': 'reverse_shell'},
                        'dependencies': [],
                        'timeout': 300
                    }
                ]
            },
            'multi_browser_attack': {
                'name': 'Multi-Browser Attack Chain',
                'description': 'Attack multiple browsers sequentially',
                'steps': [
                    {
                        'cve_id': 'CVE-2025-4664',
                        'description': 'Chrome data leak',
                        'parameters': {'target': 'chrome'},
                        'failure_action': 'continue'
                    },
                    {
                        'cve_id': 'CVE-2025-2857',
                        'description': 'Firefox sandbox escape',
                        'parameters': {'target': 'firefox'},
                        'failure_action': 'continue'
                    },
                    {
                        'cve_id': 'CVE-2025-30397',
                        'description': 'Edge WebAssembly exploit',
                        'parameters': {'target': 'edge'},
                        'failure_action': 'continue'
                    }
                ]
            }
        }
    
    def create_chain(self, name: str, description: str = "") -> ExploitChain:
        """Create new exploit chain"""
        chain = ExploitChain(name, description)
        self.chains[chain.id] = chain
        return chain
    
    def create_from_template(self, template_name: str, custom_params: Dict = None) -> Optional[ExploitChain]:
        """Create chain from predefined template"""
        if template_name not in self.chain_templates:
            logger.error(f"Template {template_name} not found")
            return None
        
        template = self.chain_templates[template_name]
        chain = self.create_chain(template['name'], template['description'])
        
        # Add steps from template
        for step_config in template['steps']:
            # Merge custom parameters
            params = step_config['parameters'].copy()
            if custom_params:
                params.update(custom_params)
            
            chain.add_step(
                cve_id=step_config['cve_id'],
                description=step_config['description'],
                parameters=params,
                dependencies=step_config.get('dependencies', []),
                timeout=step_config.get('timeout', 300),
                failure_action=step_config.get('failure_action', 'stop')
            )
        
        logger.info(f"Created chain from template '{template_name}'")
        return chain
    
    def get_chain(self, chain_id: str) -> Optional[ExploitChain]:
        """Get exploit chain by ID"""
        return self.chains.get(chain_id)
    
    def list_chains(self) -> List[Dict[str, Any]]:
        """List all exploit chains"""
        return [chain.get_status() for chain in self.chains.values()]
    
    def execute_chain(self, chain_id: str, async_execution: bool = True) -> Optional[ChainResult]:
        """Execute exploit chain"""
        chain = self.get_chain(chain_id)
        if not chain:
            logger.error(f"Chain {chain_id} not found")
            return None
        
        return chain.execute(async_execution)
    
    def stop_chain(self, chain_id: str) -> bool:
        """Stop exploit chain execution"""
        chain = self.get_chain(chain_id)
        if not chain:
            return False
        
        chain.stop()
        return True
    
    def delete_chain(self, chain_id: str) -> bool:
        """Delete exploit chain"""
        if chain_id in self.chains:
            chain = self.chains[chain_id]
            if chain.status == ChainStatus.RUNNING:
                chain.stop()
            del self.chains[chain_id]
            return True
        return False
    
    def export_chain(self, chain_id: str, filepath: str) -> bool:
        """Export chain configuration to file"""
        chain = self.get_chain(chain_id)
        if not chain:
            return False
        
        try:
            export_data = {
                'name': chain.name,
                'description': chain.description,
                'created_at': chain.created_at.isoformat(),
                'steps': [
                    {
                        'cve_id': step.cve_id,
                        'description': step.description,
                        'parameters': step.parameters,
                        'dependencies': step.dependencies,
                        'timeout': step.timeout,
                        'retry_count': step.retry_count,
                        'failure_action': step.failure_action,
                        'order': step.order
                    }
                    for step in chain.steps
                ]
            }
            
            with open(filepath, 'w') as f:
                json.dump(export_data, f, indent=2)
            
            logger.info(f"Exported chain {chain_id} to {filepath}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to export chain: {e}")
            return False
    
    def import_chain(self, filepath: str) -> Optional[ExploitChain]:
        """Import chain configuration from file"""
        try:
            with open(filepath, 'r') as f:
                import_data = json.load(f)
            
            chain = self.create_chain(
                import_data['name'],
                import_data['description']
            )
            
            # Add steps
            for step_data in import_data['steps']:
                chain.add_step(
                    cve_id=step_data['cve_id'],
                    description=step_data['description'],
                    parameters=step_data['parameters'],
                    dependencies=step_data.get('dependencies', []),
                    timeout=step_data.get('timeout', 300),
                    retry_count=step_data.get('retry_count', 1),
                    failure_action=step_data.get('failure_action', 'stop')
                )
            
            logger.info(f"Imported chain from {filepath}")
            return chain
            
        except Exception as e:
            logger.error(f"Failed to import chain: {e}")
            return None


# Global instance
_chain_manager = None

def get_chain_manager() -> ExploitChainManager:
    """Get or create exploit chain manager instance"""
    global _chain_manager
    if _chain_manager is None:
        _chain_manager = ExploitChainManager()
    return _chain_manager