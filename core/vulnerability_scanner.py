#!/usr/bin/env python3
"""
Advanced vulnerability scanner with Nuclei integration and CVE database.
Provides comprehensive vulnerability assessment capabilities.
"""

import json
import subprocess
import requests
import sqlite3
import threading
import time
from pathlib import Path
from typing import Dict, List, Optional, Set, Any, Tuple
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
import re
import yaml

from .enhanced_logger import get_logger
from .error_handler import get_error_handler, handle_errors
from .simulation import get_simulation_engine


class VulnerabilityLevel(Enum):
    """Vulnerability severity levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class VulnerabilityCategory(Enum):
    """Vulnerability categories"""
    WEB_APPLICATION = "web-application"
    NETWORK = "network"
    INFRASTRUCTURE = "infrastructure"
    DATABASE = "database"
    AUTHENTICATION = "authentication"
    AUTHORIZATION = "authorization"
    INJECTION = "injection"
    XSS = "xss"
    CSRF = "csrf"
    BROKEN_ACCESS = "broken-access"
    SECURITY_MISCONFIGURATION = "security-misconfiguration"
    INSECURE_COMPONENTS = "insecure-components"
    INSUFFICIENT_LOGGING = "insufficient-logging"
    OTHER = "other"


@dataclass
class CVEInfo:
    """CVE information from database"""
    cve_id: str
    description: str
    cvss_score: float
    cvss_vector: str
    severity: VulnerabilityLevel
    published_date: datetime
    modified_date: datetime
    references: List[str] = field(default_factory=list)
    cwe_ids: List[str] = field(default_factory=list)
    affected_products: List[str] = field(default_factory=list)


@dataclass
class VulnerabilityResult:
    """Individual vulnerability scan result"""
    vulnerability_id: str
    name: str
    description: str
    severity: VulnerabilityLevel
    category: VulnerabilityCategory
    target: str
    port: Optional[int] = None
    service: Optional[str] = None
    proof_of_concept: Optional[str] = None
    remediation: Optional[str] = None
    references: List[str] = field(default_factory=list)
    cve_ids: List[str] = field(default_factory=list)
    cvss_score: Optional[float] = None
    confidence: str = "medium"  # high, medium, low
    timestamp: datetime = field(default_factory=datetime.now)
    raw_output: Optional[str] = None


@dataclass
class ScanProfile:
    """Vulnerability scan profile configuration"""
    name: str
    description: str
    templates: List[str] = field(default_factory=list)
    severity_filter: List[VulnerabilityLevel] = field(default_factory=list)
    category_filter: List[VulnerabilityCategory] = field(default_factory=list)
    timeout: int = 300
    threads: int = 25
    rate_limit: int = 150
    custom_headers: Dict[str, str] = field(default_factory=dict)
    exclude_templates: List[str] = field(default_factory=list)


@dataclass
class ScanTarget:
    """Target for vulnerability scanning"""
    target: str
    port: Optional[int] = None
    service: Optional[str] = None
    protocol: str = "http"
    custom_params: Dict[str, Any] = field(default_factory=dict)


@dataclass
class VulnerabilityScanResult:
    """Complete vulnerability scan results"""
    scan_id: str
    targets: List[ScanTarget]
    profile: ScanProfile
    vulnerabilities: List[VulnerabilityResult] = field(default_factory=list)
    scan_duration: float = 0.0
    start_time: datetime = field(default_factory=datetime.now)
    end_time: Optional[datetime] = None
    total_requests: int = 0
    status: str = "running"  # running, completed, failed, cancelled


class CVEDatabase:
    """CVE database manager for vulnerability information"""
    
    def __init__(self, db_path: str = "data/cve_database.db"):
        self.db_path = Path(db_path)
        self.db_path.parent.mkdir(exist_ok=True)
        self.logger = get_logger()
        
        self.init_database()
    
    @handle_errors
    def init_database(self):
        """Initialize CVE database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS cves (
                cve_id TEXT PRIMARY KEY,
                description TEXT,
                cvss_score REAL,
                cvss_vector TEXT,
                severity TEXT,
                published_date TEXT,
                modified_date TEXT,
                references TEXT,
                cwe_ids TEXT,
                affected_products TEXT
            )
        ''')
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS vulnerability_mappings (
                template_id TEXT,
                cve_id TEXT,
                confidence REAL,
                PRIMARY KEY (template_id, cve_id)
            )
        ''')
        
        conn.commit()
        conn.close()
        
        self.logger.info("CVE database initialized")
    
    @handle_errors
    def update_cve_database(self, force_update: bool = False):
        """Update CVE database from NVD API"""
        last_update_file = self.db_path.parent / "last_cve_update.txt"
        
        # Check if update is needed
        if not force_update and last_update_file.exists():
            try:
                last_update = datetime.fromisoformat(last_update_file.read_text().strip())
                if datetime.now() - last_update < timedelta(days=7):
                    self.logger.info("CVE database is up to date")
                    return
            except:
                pass
        
        self.logger.info("Updating CVE database from NVD...")
        
        # This would fetch from NVD API in a real implementation
        # For now, we'll create some sample data
        sample_cves = [
            {
                "cve_id": "CVE-2023-12345",
                "description": "Cross-site scripting vulnerability in web application",
                "cvss_score": 6.1,
                "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N",
                "severity": "medium",
                "published_date": "2023-01-15T00:00:00",
                "modified_date": "2023-01-15T00:00:00",
                "references": ["https://example.com/advisory"],
                "cwe_ids": ["CWE-79"],
                "affected_products": ["Example Web App 1.0"]
            }
        ]
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        for cve in sample_cves:
            cursor.execute('''
                INSERT OR REPLACE INTO cves 
                (cve_id, description, cvss_score, cvss_vector, severity, 
                 published_date, modified_date, references, cwe_ids, affected_products)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                cve["cve_id"], cve["description"], cve["cvss_score"], 
                cve["cvss_vector"], cve["severity"], cve["published_date"],
                cve["modified_date"], json.dumps(cve["references"]),
                json.dumps(cve["cwe_ids"]), json.dumps(cve["affected_products"])
            ))
        
        conn.commit()
        conn.close()
        
        # Update timestamp
        last_update_file.write_text(datetime.now().isoformat())
        
        self.logger.info(f"CVE database updated with {len(sample_cves)} entries")
    
    @handle_errors
    def get_cve_info(self, cve_id: str) -> Optional[CVEInfo]:
        """Get CVE information by ID"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT cve_id, description, cvss_score, cvss_vector, severity,
                   published_date, modified_date, references, cwe_ids, affected_products
            FROM cves WHERE cve_id = ?
        ''', (cve_id,))
        
        row = cursor.fetchone()
        conn.close()
        
        if row:
            return CVEInfo(
                cve_id=row[0],
                description=row[1],
                cvss_score=row[2],
                cvss_vector=row[3],
                severity=VulnerabilityLevel(row[4]),
                published_date=datetime.fromisoformat(row[5]),
                modified_date=datetime.fromisoformat(row[6]),
                references=json.loads(row[7]) if row[7] else [],
                cwe_ids=json.loads(row[8]) if row[8] else [],
                affected_products=json.loads(row[9]) if row[9] else []
            )
        
        return None
    
    @handle_errors
    def search_cves(self, query: str, severity: Optional[VulnerabilityLevel] = None) -> List[CVEInfo]:
        """Search CVEs by description or product"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        sql = '''
            SELECT cve_id, description, cvss_score, cvss_vector, severity,
                   published_date, modified_date, references, cwe_ids, affected_products
            FROM cves 
            WHERE (description LIKE ? OR affected_products LIKE ?)
        '''
        params = [f"%{query}%", f"%{query}%"]
        
        if severity:
            sql += " AND severity = ?"
            params.append(severity.value)
        
        sql += " ORDER BY cvss_score DESC LIMIT 50"
        
        cursor.execute(sql, params)
        rows = cursor.fetchall()
        conn.close()
        
        results = []
        for row in rows:
            results.append(CVEInfo(
                cve_id=row[0],
                description=row[1],
                cvss_score=row[2],
                cvss_vector=row[3],
                severity=VulnerabilityLevel(row[4]),
                published_date=datetime.fromisoformat(row[5]),
                modified_date=datetime.fromisoformat(row[6]),
                references=json.loads(row[7]) if row[7] else [],
                cwe_ids=json.loads(row[8]) if row[8] else [],
                affected_products=json.loads(row[9]) if row[9] else []
            ))
        
        return results


class NucleiScanner:
    """Nuclei template engine integration"""
    
    def __init__(self, nuclei_path: str = "nuclei", templates_dir: str = "nuclei-templates"):
        self.nuclei_path = nuclei_path
        self.templates_dir = Path(templates_dir)
        self.logger = get_logger()
        
        self.check_nuclei_installation()
    
    @handle_errors
    def check_nuclei_installation(self):
        """Check if Nuclei is installed and accessible"""
        try:
            result = subprocess.run([self.nuclei_path, "-version"], 
                                  capture_output=True, text=True, timeout=10)
            if result.returncode == 0:
                self.logger.info(f"Nuclei found: {result.stdout.strip()}")
                return True
        except (subprocess.TimeoutExpired, FileNotFoundError):
            pass
        
        self.logger.warning("Nuclei not found - vulnerability scanning will be simulated")
        return False
    
    @handle_errors
    def update_templates(self):
        """Update Nuclei templates"""
        try:
            result = subprocess.run([self.nuclei_path, "-update-templates"], 
                                  capture_output=True, text=True, timeout=300)
            if result.returncode == 0:
                self.logger.info("Nuclei templates updated successfully")
                return True
        except (subprocess.TimeoutExpired, FileNotFoundError) as e:
            self.logger.error(f"Failed to update Nuclei templates: {e}")
        
        return False
    
    @handle_errors
    def list_templates(self, category: Optional[str] = None) -> List[Dict[str, Any]]:
        """List available Nuclei templates"""
        templates = []
        
        if not self.templates_dir.exists():
            self.logger.warning("Nuclei templates directory not found")
            return templates
        
        # Find template files
        for template_file in self.templates_dir.rglob("*.yaml"):
            try:
                with open(template_file, 'r', encoding='utf-8') as f:
                    template_data = yaml.safe_load(f)
                    
                    if not template_data or 'info' not in template_data:
                        continue
                    
                    info = template_data['info']
                    template_info = {
                        'id': template_data.get('id', template_file.stem),
                        'name': info.get('name', ''),
                        'description': info.get('description', ''),
                        'severity': info.get('severity', 'info'),
                        'category': info.get('classification', {}).get('category', 'other'),
                        'tags': info.get('tags', []),
                        'file_path': str(template_file),
                        'author': info.get('author', '')
                    }
                    
                    if category and template_info['category'] != category:
                        continue
                    
                    templates.append(template_info)
                    
            except Exception as e:
                self.logger.debug(f"Error parsing template {template_file}: {e}")
        
        return templates
    
    @handle_errors
    def run_scan(self, targets: List[str], templates: List[str] = None, 
                 profile: Optional[ScanProfile] = None) -> List[VulnerabilityResult]:
        """Run Nuclei scan"""
        if not targets:
            return []
        
        # Build Nuclei command
        cmd = [self.nuclei_path]
        
        # Add targets
        for target in targets:
            cmd.extend(["-u", target])
        
        # Add templates
        if templates:
            for template in templates:
                cmd.extend(["-t", template])
        else:
            cmd.extend(["-t", str(self.templates_dir)])
        
        # Add profile options
        if profile:
            if profile.severity_filter:
                severities = ",".join([s.value for s in profile.severity_filter])
                cmd.extend(["-severity", severities])
            
            if profile.threads:
                cmd.extend(["-c", str(profile.threads)])
            
            if profile.rate_limit:
                cmd.extend(["-rl", str(profile.rate_limit)])
            
            if profile.timeout:
                cmd.extend(["-timeout", str(profile.timeout)])
        
        # Output format
        cmd.extend(["-json", "-silent"])
        
        self.logger.info(f"Running Nuclei scan: {' '.join(cmd)}")
        
        vulnerabilities = []
        
        try:
            # Run Nuclei scan
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, 
                                     stderr=subprocess.PIPE, text=True)
            
            # Parse JSON output line by line
            for line in process.stdout:
                if line.strip():
                    try:
                        result = json.loads(line.strip())
                        vuln = self.parse_nuclei_result(result)
                        if vuln:
                            vulnerabilities.append(vuln)
                    except json.JSONDecodeError as e:
                        self.logger.debug(f"Error parsing Nuclei output: {e}")
            
            process.wait()
            
        except (subprocess.TimeoutExpired, FileNotFoundError) as e:
            self.logger.error(f"Nuclei scan failed: {e}")
        
        self.logger.info(f"Nuclei scan completed: {len(vulnerabilities)} vulnerabilities found")
        return vulnerabilities
    
    @handle_errors
    def parse_nuclei_result(self, result: Dict[str, Any]) -> Optional[VulnerabilityResult]:
        """Parse Nuclei JSON result into VulnerabilityResult"""
        try:
            info = result.get('info', {})
            
            # Extract CVE IDs from tags or classification
            cve_ids = []
            tags = info.get('tags', [])
            for tag in tags:
                if tag.startswith('cve-'):
                    cve_ids.append(tag.upper().replace('-', '-'))
            
            # Get classification info
            classification = info.get('classification', {})
            
            # Map severity
            severity_map = {
                'critical': VulnerabilityLevel.CRITICAL,
                'high': VulnerabilityLevel.HIGH,
                'medium': VulnerabilityLevel.MEDIUM,
                'low': VulnerabilityLevel.LOW,
                'info': VulnerabilityLevel.INFO
            }
            severity = severity_map.get(info.get('severity', 'info'), VulnerabilityLevel.INFO)
            
            # Map category
            category_map = {
                'injection': VulnerabilityCategory.INJECTION,
                'xss': VulnerabilityCategory.XSS,
                'csrf': VulnerabilityCategory.CSRF,
                'auth': VulnerabilityCategory.AUTHENTICATION,
                'config': VulnerabilityCategory.SECURITY_MISCONFIGURATION,
                'network': VulnerabilityCategory.NETWORK,
                'database': VulnerabilityCategory.DATABASE
            }
            category = category_map.get(classification.get('category', 'other'), 
                                      VulnerabilityCategory.OTHER)
            
            # Extract target info
            target_url = result.get('matched-at', result.get('host', ''))
            
            vulnerability = VulnerabilityResult(
                vulnerability_id=result.get('template-id', ''),
                name=info.get('name', ''),
                description=info.get('description', ''),
                severity=severity,
                category=category,
                target=target_url,
                proof_of_concept=result.get('extracted-results', [''])[0] if result.get('extracted-results') else None,
                references=info.get('reference', []),
                cve_ids=cve_ids,
                cvss_score=classification.get('cvss-score'),
                confidence="high",  # Nuclei results are generally high confidence
                raw_output=json.dumps(result, indent=2)
            )
            
            return vulnerability
            
        except Exception as e:
            self.logger.error(f"Error parsing Nuclei result: {e}")
            return None


class CustomVulnerabilityChecks:
    """Custom vulnerability checks for common issues"""
    
    def __init__(self):
        self.logger = get_logger()
    
    @handle_errors
    def check_http_security_headers(self, target: str) -> List[VulnerabilityResult]:
        """Check for missing HTTP security headers"""
        vulnerabilities = []
        
        try:
            response = requests.get(target, timeout=10, verify=False)
            headers = response.headers
            
            # Check for missing security headers
            security_headers = {
                'Strict-Transport-Security': {
                    'name': 'Missing HSTS Header',
                    'description': 'HTTP Strict Transport Security header is missing',
                    'severity': VulnerabilityLevel.MEDIUM
                },
                'Content-Security-Policy': {
                    'name': 'Missing CSP Header',
                    'description': 'Content Security Policy header is missing',
                    'severity': VulnerabilityLevel.MEDIUM
                },
                'X-Frame-Options': {
                    'name': 'Missing X-Frame-Options Header',
                    'description': 'X-Frame-Options header is missing - clickjacking possible',
                    'severity': VulnerabilityLevel.LOW
                },
                'X-Content-Type-Options': {
                    'name': 'Missing X-Content-Type-Options Header',
                    'description': 'X-Content-Type-Options header is missing',
                    'severity': VulnerabilityLevel.LOW
                },
                'Referrer-Policy': {
                    'name': 'Missing Referrer-Policy Header',
                    'description': 'Referrer-Policy header is missing',
                    'severity': VulnerabilityLevel.INFO
                }
            }
            
            for header, info in security_headers.items():
                if header not in headers:
                    vuln = VulnerabilityResult(
                        vulnerability_id=f"missing-{header.lower()}",
                        name=info['name'],
                        description=info['description'],
                        severity=info['severity'],
                        category=VulnerabilityCategory.SECURITY_MISCONFIGURATION,
                        target=target,
                        remediation=f"Add {header} header to HTTP responses",
                        confidence="high"
                    )
                    vulnerabilities.append(vuln)
            
            # Check for information disclosure headers
            disclosure_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version']
            for header in disclosure_headers:
                if header in headers:
                    vuln = VulnerabilityResult(
                        vulnerability_id=f"info-disclosure-{header.lower()}",
                        name=f"Information Disclosure via {header} Header",
                        description=f"Server information disclosed via {header} header: {headers[header]}",
                        severity=VulnerabilityLevel.INFO,
                        category=VulnerabilityCategory.SECURITY_MISCONFIGURATION,
                        target=target,
                        proof_of_concept=f"{header}: {headers[header]}",
                        remediation=f"Remove or modify {header} header",
                        confidence="high"
                    )
                    vulnerabilities.append(vuln)
            
        except Exception as e:
            self.logger.debug(f"Error checking HTTP headers for {target}: {e}")
        
        return vulnerabilities
    
    @handle_errors
    def check_ssl_configuration(self, target: str) -> List[VulnerabilityResult]:
        """Check SSL/TLS configuration"""
        vulnerabilities = []
        
        try:
            import ssl
            import socket
            from urllib.parse import urlparse
            
            parsed = urlparse(target)
            if parsed.scheme != 'https':
                return vulnerabilities
            
            hostname = parsed.hostname
            port = parsed.port or 443
            
            # Check SSL certificate
            context = ssl.create_default_context()
            
            with socket.create_connection((hostname, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    protocol = ssock.version()
                    cipher = ssock.cipher()
                    
                    # Check for weak protocols
                    if protocol in ['TLSv1', 'TLSv1.1']:
                        vuln = VulnerabilityResult(
                            vulnerability_id="weak-tls-protocol",
                            name="Weak TLS Protocol",
                            description=f"Server supports weak TLS protocol: {protocol}",
                            severity=VulnerabilityLevel.MEDIUM,
                            category=VulnerabilityCategory.SECURITY_MISCONFIGURATION,
                            target=target,
                            proof_of_concept=f"TLS Protocol: {protocol}",
                            remediation="Disable TLSv1.0 and TLSv1.1, use TLSv1.2 or TLSv1.3",
                            confidence="high"
                        )
                        vulnerabilities.append(vuln)
                    
                    # Check certificate expiration
                    if cert:
                        import datetime
                        not_after = datetime.datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                        days_until_expiry = (not_after - datetime.datetime.now()).days
                        
                        if days_until_expiry < 30:
                            severity = VulnerabilityLevel.HIGH if days_until_expiry < 7 else VulnerabilityLevel.MEDIUM
                            vuln = VulnerabilityResult(
                                vulnerability_id="ssl-cert-expiring",
                                name="SSL Certificate Expiring Soon",
                                description=f"SSL certificate expires in {days_until_expiry} days",
                                severity=severity,
                                category=VulnerabilityCategory.SECURITY_MISCONFIGURATION,
                                target=target,
                                proof_of_concept=f"Certificate expires: {cert['notAfter']}",
                                remediation="Renew SSL certificate before expiration",
                                confidence="high"
                            )
                            vulnerabilities.append(vuln)
            
        except Exception as e:
            self.logger.debug(f"Error checking SSL for {target}: {e}")
        
        return vulnerabilities
    
    @handle_errors
    def check_directory_traversal(self, target: str) -> List[VulnerabilityResult]:
        """Basic directory traversal check"""
        vulnerabilities = []
        
        # Common directory traversal payloads
        payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2f%65%74%63%2f%70%61%73%73%77%64"
        ]
        
        try:
            for payload in payloads:
                test_url = f"{target.rstrip('/')}/{payload}"
                response = requests.get(test_url, timeout=5, verify=False)
                
                # Look for indicators of successful traversal
                indicators = ["root:", "daemon:", "bin:", "[drivers]", "localhost"]
                
                for indicator in indicators:
                    if indicator in response.text.lower():
                        vuln = VulnerabilityResult(
                            vulnerability_id="directory-traversal",
                            name="Directory Traversal Vulnerability",
                            description="Application allows directory traversal attacks",
                            severity=VulnerabilityLevel.HIGH,
                            category=VulnerabilityCategory.WEB_APPLICATION,
                            target=target,
                            proof_of_concept=f"URL: {test_url}\nResponse contains: {indicator}",
                            remediation="Implement proper input validation and sanitization",
                            confidence="medium"
                        )
                        vulnerabilities.append(vuln)
                        break
                
                if vulnerabilities:  # Stop after first successful detection
                    break
                    
        except Exception as e:
            self.logger.debug(f"Error checking directory traversal for {target}: {e}")
        
        return vulnerabilities


class VulnerabilityScanner:
    """Main vulnerability scanner coordinating all scanning engines"""
    
    def __init__(self, output_dir: str = "vuln_scan_data"):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        self.logger = get_logger()
        self.simulation = get_simulation_engine()
        
        self.cve_db = CVEDatabase()
        self.nuclei_scanner = NucleiScanner()
        self.custom_checks = CustomVulnerabilityChecks()
        
        self.scan_results: Dict[str, VulnerabilityScanResult] = {}
        
        self.setup_default_profiles()
    
    @handle_errors
    def setup_default_profiles(self):
        """Setup default scan profiles"""
        self.profiles = {
            "quick": ScanProfile(
                name="Quick Scan",
                description="Fast scan with critical and high severity checks",
                severity_filter=[VulnerabilityLevel.CRITICAL, VulnerabilityLevel.HIGH],
                timeout=60,
                threads=10,
                rate_limit=50
            ),
            "standard": ScanProfile(
                name="Standard Scan", 
                description="Balanced scan with medium+ severity checks",
                severity_filter=[VulnerabilityLevel.CRITICAL, VulnerabilityLevel.HIGH, VulnerabilityLevel.MEDIUM],
                timeout=300,
                threads=25,
                rate_limit=150
            ),
            "comprehensive": ScanProfile(
                name="Comprehensive Scan",
                description="Thorough scan including all severity levels",
                timeout=600,
                threads=50,
                rate_limit=200
            ),
            "web_app": ScanProfile(
                name="Web Application Scan",
                description="Focused scan for web application vulnerabilities",
                category_filter=[VulnerabilityCategory.WEB_APPLICATION, VulnerabilityCategory.INJECTION, 
                               VulnerabilityCategory.XSS, VulnerabilityCategory.CSRF],
                timeout=300,
                threads=20,
                rate_limit=100
            ),
            "network": ScanProfile(
                name="Network Scan",
                description="Network service and infrastructure vulnerabilities",
                category_filter=[VulnerabilityCategory.NETWORK, VulnerabilityCategory.INFRASTRUCTURE],
                timeout=180,
                threads=15,
                rate_limit=75
            )
        }
    
    @handle_errors
    def create_scan_targets(self, targets: List[str], ports: List[int] = None) -> List[ScanTarget]:
        """Create scan targets from target list"""
        scan_targets = []
        
        for target in targets:
            if ports:
                for port in ports:
                    protocol = "https" if port in [443, 8443] else "http"
                    scan_targets.append(ScanTarget(
                        target=f"{protocol}://{target}:{port}",
                        port=port,
                        protocol=protocol
                    ))
            else:
                # Default HTTP/HTTPS
                scan_targets.extend([
                    ScanTarget(target=f"http://{target}", protocol="http"),
                    ScanTarget(target=f"https://{target}", protocol="https")
                ])
        
        return scan_targets
    
    @handle_errors
    def run_vulnerability_scan(self, targets: List[str], profile_name: str = "standard",
                             custom_profile: Optional[ScanProfile] = None) -> str:
        """Run comprehensive vulnerability scan"""
        if self.simulation.is_simulation_mode():
            return self.simulation.simulate_vulnerability_scan(targets, profile_name)
        
        # Get scan profile
        profile = custom_profile or self.profiles.get(profile_name, self.profiles["standard"])
        
        # Create scan targets
        scan_targets = self.create_scan_targets(targets)
        
        # Generate scan ID
        scan_id = f"scan_{int(time.time())}"
        
        # Initialize scan result
        scan_result = VulnerabilityScanResult(
            scan_id=scan_id,
            targets=scan_targets,
            profile=profile,
            start_time=datetime.now()
        )
        
        self.scan_results[scan_id] = scan_result
        
        self.logger.info(f"Starting vulnerability scan {scan_id} with profile '{profile.name}'")
        
        try:
            start_time = time.time()
            
            # 1. Run Nuclei scans
            target_urls = [target.target for target in scan_targets]
            nuclei_results = self.nuclei_scanner.run_scan(target_urls, profile=profile)
            scan_result.vulnerabilities.extend(nuclei_results)
            
            # 2. Run custom checks
            for target in scan_targets:
                if target.protocol == "http" or target.protocol == "https":
                    # HTTP security headers
                    custom_vulns = self.custom_checks.check_http_security_headers(target.target)
                    scan_result.vulnerabilities.extend(custom_vulns)
                    
                    # SSL configuration (for HTTPS)
                    if target.protocol == "https":
                        ssl_vulns = self.custom_checks.check_ssl_configuration(target.target)
                        scan_result.vulnerabilities.extend(ssl_vulns)
                    
                    # Directory traversal
                    dt_vulns = self.custom_checks.check_directory_traversal(target.target)
                    scan_result.vulnerabilities.extend(dt_vulns)
            
            # 3. Enrich with CVE information
            self.enrich_with_cve_data(scan_result.vulnerabilities)
            
            # Complete scan
            scan_result.scan_duration = time.time() - start_time
            scan_result.end_time = datetime.now()
            scan_result.status = "completed"
            
            # Save results
            self.save_scan_results(scan_id)
            
            self.logger.info(f"Vulnerability scan {scan_id} completed: {len(scan_result.vulnerabilities)} vulnerabilities found")
            
        except Exception as e:
            scan_result.status = "failed"
            scan_result.end_time = datetime.now()
            self.logger.error(f"Vulnerability scan {scan_id} failed: {e}")
        
        return scan_id
    
    @handle_errors
    def enrich_with_cve_data(self, vulnerabilities: List[VulnerabilityResult]):
        """Enrich vulnerability results with CVE data"""
        for vuln in vulnerabilities:
            if vuln.cve_ids:
                for cve_id in vuln.cve_ids:
                    cve_info = self.cve_db.get_cve_info(cve_id)
                    if cve_info:
                        if not vuln.cvss_score:
                            vuln.cvss_score = cve_info.cvss_score
                        if not vuln.references:
                            vuln.references = cve_info.references
    
    @handle_errors
    def save_scan_results(self, scan_id: str):
        """Save scan results to file"""
        if scan_id not in self.scan_results:
            return
        
        scan_result = self.scan_results[scan_id]
        output_file = self.output_dir / f"vuln_scan_{scan_id}.json"
        
        data = {
            'scan_id': scan_id,
            'profile': {
                'name': scan_result.profile.name,
                'description': scan_result.profile.description,
                'severity_filter': [s.value for s in scan_result.profile.severity_filter],
                'category_filter': [c.value for c in scan_result.profile.category_filter]
            },
            'targets': [
                {
                    'target': target.target,
                    'port': target.port,
                    'service': target.service,
                    'protocol': target.protocol
                } for target in scan_result.targets
            ],
            'scan_info': {
                'start_time': scan_result.start_time.isoformat(),
                'end_time': scan_result.end_time.isoformat() if scan_result.end_time else None,
                'duration': scan_result.scan_duration,
                'status': scan_result.status,
                'total_vulnerabilities': len(scan_result.vulnerabilities)
            },
            'vulnerabilities': [
                {
                    'id': vuln.vulnerability_id,
                    'name': vuln.name,
                    'description': vuln.description,
                    'severity': vuln.severity.value,
                    'category': vuln.category.value,
                    'target': vuln.target,
                    'port': vuln.port,
                    'service': vuln.service,
                    'proof_of_concept': vuln.proof_of_concept,
                    'remediation': vuln.remediation,
                    'references': vuln.references,
                    'cve_ids': vuln.cve_ids,
                    'cvss_score': vuln.cvss_score,
                    'confidence': vuln.confidence,
                    'timestamp': vuln.timestamp.isoformat()
                } for vuln in scan_result.vulnerabilities
            ]
        }
        
        with open(output_file, 'w') as f:
            json.dump(data, f, indent=2)
        
        self.logger.info(f"Scan results saved to {output_file}")
    
    @handle_errors
    def get_scan_results(self, scan_id: str) -> Optional[VulnerabilityScanResult]:
        """Get scan results by ID"""
        return self.scan_results.get(scan_id)
    
    @handle_errors
    def get_scan_summary(self, scan_id: str) -> Optional[Dict[str, Any]]:
        """Get scan summary"""
        scan_result = self.get_scan_results(scan_id)
        if not scan_result:
            return None
        
        # Count vulnerabilities by severity
        severity_counts = {}
        category_counts = {}
        
        for vuln in scan_result.vulnerabilities:
            severity_counts[vuln.severity.value] = severity_counts.get(vuln.severity.value, 0) + 1
            category_counts[vuln.category.value] = category_counts.get(vuln.category.value, 0) + 1
        
        return {
            'scan_id': scan_id,
            'profile_name': scan_result.profile.name,
            'start_time': scan_result.start_time.isoformat(),
            'end_time': scan_result.end_time.isoformat() if scan_result.end_time else None,
            'duration': scan_result.scan_duration,
            'status': scan_result.status,
            'targets_count': len(scan_result.targets),
            'total_vulnerabilities': len(scan_result.vulnerabilities),
            'severity_breakdown': severity_counts,
            'category_breakdown': category_counts,
            'critical_count': severity_counts.get('critical', 0),
            'high_count': severity_counts.get('high', 0),
            'medium_count': severity_counts.get('medium', 0),
            'low_count': severity_counts.get('low', 0),
            'info_count': severity_counts.get('info', 0)
        }
    
    @handle_errors
    def list_scans(self) -> List[Dict[str, Any]]:
        """List all scans"""
        scans = []
        for scan_id in self.scan_results:
            summary = self.get_scan_summary(scan_id)
            if summary:
                scans.append(summary)
        
        return sorted(scans, key=lambda x: x['start_time'], reverse=True)
    
    @handle_errors
    def delete_scan(self, scan_id: str) -> bool:
        """Delete scan results"""
        if scan_id in self.scan_results:
            del self.scan_results[scan_id]
            
            # Delete file
            output_file = self.output_dir / f"vuln_scan_{scan_id}.json"
            if output_file.exists():
                output_file.unlink()
            
            self.logger.info(f"Scan {scan_id} deleted")
            return True
        
        return False
    
    @handle_errors
    def export_scan_report(self, scan_id: str, format: str = "json") -> Optional[str]:
        """Export scan report in various formats"""
        scan_result = self.get_scan_results(scan_id)
        if not scan_result:
            return None
        
        if format == "json":
            output_file = self.output_dir / f"report_{scan_id}.json"
            self.save_scan_results(scan_id)
            return str(output_file)
        
        elif format == "html":
            return self.generate_html_report(scan_result)
        
        elif format == "csv":
            return self.generate_csv_report(scan_result)
        
        return None
    
    @handle_errors
    def generate_html_report(self, scan_result: VulnerabilityScanResult) -> str:
        """Generate HTML vulnerability report"""
        output_file = self.output_dir / f"report_{scan_result.scan_id}.html"
        
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Vulnerability Scan Report - {scan_result.scan_id}</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .header {{ background: #f4f4f4; padding: 20px; border-radius: 5px; }}
                .severity-critical {{ color: #dc3545; font-weight: bold; }}
                .severity-high {{ color: #fd7e14; font-weight: bold; }}
                .severity-medium {{ color: #ffc107; font-weight: bold; }}
                .severity-low {{ color: #28a745; }}
                .severity-info {{ color: #17a2b8; }}
                .vulnerability {{ border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 5px; }}
                .vuln-header {{ font-size: 18px; font-weight: bold; margin-bottom: 10px; }}
                table {{ width: 100%; border-collapse: collapse; margin: 20px 0; }}
                th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
                th {{ background-color: #f2f2f2; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>Vulnerability Scan Report</h1>
                <p><strong>Scan ID:</strong> {scan_result.scan_id}</p>
                <p><strong>Profile:</strong> {scan_result.profile.name}</p>
                <p><strong>Start Time:</strong> {scan_result.start_time.strftime('%Y-%m-%d %H:%M:%S')}</p>
                <p><strong>Duration:</strong> {scan_result.scan_duration:.2f} seconds</p>
                <p><strong>Total Vulnerabilities:</strong> {len(scan_result.vulnerabilities)}</p>
            </div>
        """
        
        # Summary table
        summary = self.get_scan_summary(scan_result.scan_id)
        if summary:
            html_content += """
            <h2>Summary</h2>
            <table>
                <tr><th>Severity</th><th>Count</th></tr>
            """
            for severity in ['critical', 'high', 'medium', 'low', 'info']:
                count = summary['severity_breakdown'].get(severity, 0)
                html_content += f'<tr><td class="severity-{severity}">{severity.title()}</td><td>{count}</td></tr>'
            
            html_content += "</table>"
        
        # Vulnerabilities
        html_content += "<h2>Vulnerabilities</h2>"
        
        for vuln in sorted(scan_result.vulnerabilities, key=lambda x: (x.severity.value, x.name)):
            html_content += f"""
            <div class="vulnerability">
                <div class="vuln-header">
                    <span class="severity-{vuln.severity.value}">[{vuln.severity.value.upper()}]</span>
                    {vuln.name}
                </div>
                <p><strong>Target:</strong> {vuln.target}</p>
                <p><strong>Description:</strong> {vuln.description}</p>
                {f'<p><strong>Proof of Concept:</strong> <pre>{vuln.proof_of_concept}</pre></p>' if vuln.proof_of_concept else ''}
                {f'<p><strong>Remediation:</strong> {vuln.remediation}</p>' if vuln.remediation else ''}
                {f'<p><strong>CVE IDs:</strong> {", ".join(vuln.cve_ids)}</p>' if vuln.cve_ids else ''}
                {f'<p><strong>CVSS Score:</strong> {vuln.cvss_score}</p>' if vuln.cvss_score else ''}
            </div>
            """
        
        html_content += "</body></html>"
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(html_content)
        
        return str(output_file)
    
    @handle_errors
    def generate_csv_report(self, scan_result: VulnerabilityScanResult) -> str:
        """Generate CSV vulnerability report"""
        import csv
        
        output_file = self.output_dir / f"report_{scan_result.scan_id}.csv"
        
        with open(output_file, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            
            # Header
            writer.writerow([
                'Vulnerability ID', 'Name', 'Severity', 'Category', 'Target', 
                'Port', 'Description', 'CVE IDs', 'CVSS Score', 'Confidence',
                'Proof of Concept', 'Remediation', 'Timestamp'
            ])
            
            # Data
            for vuln in scan_result.vulnerabilities:
                writer.writerow([
                    vuln.vulnerability_id, vuln.name, vuln.severity.value, 
                    vuln.category.value, vuln.target, vuln.port, vuln.description,
                    ', '.join(vuln.cve_ids), vuln.cvss_score, vuln.confidence,
                    vuln.proof_of_concept, vuln.remediation, vuln.timestamp.isoformat()
                ])
        
        return str(output_file)


# Global vulnerability scanner instance
_vulnerability_scanner = None

def get_vulnerability_scanner() -> VulnerabilityScanner:
    """Get global vulnerability scanner instance"""
    global _vulnerability_scanner
    if _vulnerability_scanner is None:
        _vulnerability_scanner = VulnerabilityScanner()
    return _vulnerability_scanner